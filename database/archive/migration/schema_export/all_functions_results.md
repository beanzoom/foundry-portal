Export all user-owned functions with complete definitions:

[
  {
    "schema_name": "public",
    "function_name": "check_email_queue_health",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.check_email_queue_health()\n RETURNS TABLE(metric text, value bigint, status text)\n LANGUAGE sql\nAS $function$\r\n    SELECT 'Pending Emails' as metric,\r\n           COUNT(*) as value,\r\n           CASE\r\n               WHEN COUNT(*) > 100 THEN 'WARNING: High backlog'\r\n               WHEN COUNT(*) > 50 THEN 'CAUTION: Growing backlog'\r\n               ELSE 'OK'\r\n           END as status\r\n    FROM email_queue\r\n    WHERE status = 'pending'\r\n\r\n    UNION ALL\r\n\r\n    SELECT 'Failed Emails (24h)' as metric,\r\n           COUNT(*) as value,\r\n           CASE\r\n               WHEN COUNT(*) > 10 THEN 'WARNING: High failure rate'\r\n               WHEN COUNT(*) > 5 THEN 'CAUTION: Some failures'\r\n               ELSE 'OK'\r\n           END as status\r\n    FROM email_queue\r\n    WHERE status = 'failed'\r\n        AND created_at > now() - interval '24 hours'\r\n\r\n    UNION ALL\r\n\r\n    SELECT 'Sent Emails (24h)' as metric,\r\n           COUNT(*) as value,\r\n           'INFO' as status\r\n    FROM email_queue\r\n    WHERE status = 'sent'\r\n        AND updated_at > now() - interval '24 hours'\r\n\r\n    UNION ALL\r\n\r\n    SELECT 'Oldest Pending (minutes)' as metric,\r\n           EXTRACT(EPOCH FROM (now() - MIN(created_at)))/60 as value,\r\n           CASE\r\n               WHEN EXTRACT(EPOCH FROM (now() - MIN(created_at)))/60 > 60 THEN 'WARNING: Old emails pending'\r\n               WHEN EXTRACT(EPOCH FROM (now() - MIN(created_at)))/60 > 30 THEN 'CAUTION: Emails aging'\r\n               ELSE 'OK'\r\n           END as status\r\n    FROM email_queue\r\n    WHERE status = 'pending';\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "complete_email_batch",
    "arguments": "p_batch_id uuid, p_emails_sent integer, p_emails_failed integer, p_error_message text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.complete_email_batch(p_batch_id uuid, p_emails_sent integer, p_emails_failed integer, p_error_message text DEFAULT NULL::text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  UPDATE email_notification_batches\r\n  SET status = CASE\r\n        WHEN p_emails_failed > 0 AND p_emails_sent = 0 THEN 'failed'\r\n        WHEN p_emails_failed > 0 THEN 'partial'\r\n        ELSE 'completed'\r\n      END,\r\n      emails_sent = p_emails_sent,\r\n      emails_failed = p_emails_failed,\r\n      processed_count = p_emails_sent,\r\n      failed_count = p_emails_failed,\r\n      completed_at = now(),\r\n      error_message = p_error_message,\r\n      updated_at = now()\r\n  WHERE id = p_batch_id;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "create_email_batch",
    "arguments": "p_content_id uuid, p_content_type text, p_target_audience text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_email_batch(p_content_id uuid, p_content_type text, p_target_audience text DEFAULT 'all'::text)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_batch_id UUID;\r\nBEGIN\r\n  -- Call the portal schema function\r\n  SELECT portal.create_email_batch(p_content_id, p_content_type, p_target_audience) INTO v_batch_id;\r\n  RETURN v_batch_id;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "create_update_email_batch",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_update_email_batch()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_recipients JSONB;\r\n  v_recipient_array JSONB[];\r\n  v_user RECORD;\r\nBEGIN\r\n  -- Only create batch on status change to 'published'\r\n  IF NEW.status = 'published' AND (OLD.status IS NULL OR OLD.status != 'published') THEN\r\n\r\n    -- Build recipients array\r\n    v_recipient_array := ARRAY[]::JSONB[];\r\n\r\n    FOR v_user IN\r\n      SELECT id as user_id, email, first_name, last_name\r\n      FROM public.profiles\r\n      WHERE role IN ('portal_member', 'admin', 'super_admin', 'investor')\r\n        AND email IS NOT NULL\r\n    LOOP\r\n      v_recipient_array := array_append(\r\n        v_recipient_array,\r\n        jsonb_build_object(\r\n          'user_id', v_user.user_id::TEXT,\r\n          'email', v_user.email,\r\n          'first_name', v_user.first_name,\r\n          'last_name', v_user.last_name\r\n        )\r\n      );\r\n    END LOOP;\r\n\r\n    -- Convert array to JSONB\r\n    v_recipients := to_jsonb(v_recipient_array);\r\n\r\n    -- Create the batch in portal schema\r\n    INSERT INTO portal.email_notification_batches (\r\n      notification_type,\r\n      content_id,\r\n      content_title,\r\n      content_data,\r\n      status\r\n    ) VALUES (\r\n      'update_published',\r\n      NEW.id,\r\n      NEW.title,\r\n      jsonb_build_object(\r\n        'content', NEW.content,\r\n        'update_type', NEW.update_type,\r\n        'target_audience', COALESCE(NEW.target_audience, 'all'),\r\n        'published_at', COALESCE(NEW.published_at, NOW()),\r\n        'recipients', v_recipients\r\n      ),\r\n      'pending'\r\n    );\r\n\r\n    RAISE NOTICE 'Created email batch for update % with % recipients', NEW.title, array_length(v_recipient_array, 1);\r\n  END IF;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_email_stats",
    "arguments": "p_days integer",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_email_stats(p_days integer DEFAULT 30)\n RETURNS TABLE(total_emails bigint, sent_emails bigint, failed_emails bigint, pending_emails bigint, avg_retry_count numeric, emails_today bigint, emails_this_week bigint, emails_this_month bigint)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT\r\n    COUNT(*) AS total_emails,\r\n    COUNT(*) FILTER (WHERE status = 'sent') AS sent_emails,\r\n    COUNT(*) FILTER (WHERE status = 'failed') AS failed_emails,\r\n    COUNT(*) FILTER (WHERE status = 'pending') AS pending_emails,\r\n    AVG(retry_count) AS avg_retry_count,\r\n    COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE) AS emails_today,\r\n    COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE - INTERVAL '7 days') AS emails_this_week,\r\n    COUNT(*) FILTER (WHERE created_at >= DATE_TRUNC('month', CURRENT_DATE)) AS emails_this_month\r\n  FROM public.email_logs\r\n  WHERE created_at >= NOW() - INTERVAL '1 day' * p_days;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_next_email_batch",
    "arguments": "p_batch_size integer",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_next_email_batch(p_batch_size integer DEFAULT 10)\n RETURNS TABLE(queue_id uuid, event_type text, event_id text, template_id text, to_email text, to_user_id uuid, event_payload jsonb, metadata jsonb)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    UPDATE email_queue\r\n    SET\r\n        status = 'processing',\r\n        attempts = attempts + 1,\r\n        last_attempt_at = now(),\r\n        updated_at = now()\r\n    WHERE id IN (\r\n        SELECT id\r\n        FROM email_queue\r\n        WHERE status IN ('queued', 'pending')  -- Accept both queued and pending\r\n            AND scheduled_for <= now()\r\n            AND (expires_at IS NULL OR expires_at > now())\r\n        ORDER BY priority ASC, scheduled_for ASC\r\n        LIMIT p_batch_size\r\n        FOR UPDATE SKIP LOCKED\r\n    )\r\n    RETURNING\r\n        id as queue_id,\r\n        email_queue.event_type,\r\n        email_queue.event_id,\r\n        email_queue.template_id,\r\n        email_queue.to_email,\r\n        email_queue.to_user_id,\r\n        email_queue.event_payload,\r\n        email_queue.metadata;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_notification_stats",
    "arguments": "p_hours integer",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_notification_stats(p_hours integer DEFAULT 24)\n RETURNS json\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n  v_stats JSON;\r\nBEGIN\r\n  WITH stats AS (\r\n    SELECT\r\n      COUNT(*) FILTER (WHERE status = 'pending') as pending_count,\r\n      COUNT(*) FILTER (WHERE status = 'processing') as processing_count,\r\n      COUNT(*) FILTER (WHERE status = 'sent' AND sent_at >= NOW() - (p_hours || ' hours')::interval) as sent_count,\r\n      COUNT(*) FILTER (WHERE status = 'failed' AND error_count >= max_retries) as failed_count,\r\n      COUNT(*) FILTER (WHERE status = 'failed' AND error_count < max_retries) as retry_count,\r\n      AVG(EXTRACT(EPOCH FROM (sent_at - created_at))) FILTER (WHERE status = 'sent') as avg_send_time_seconds,\r\n      MAX(created_at) FILTER (WHERE status = 'pending') as oldest_pending\r\n    FROM public.email_notifications\r\n    WHERE created_at >= NOW() - (p_hours || ' hours')::interval\r\n  ),\r\n  event_stats AS (\r\n    SELECT\r\n      event_id,\r\n      COUNT(*) as count\r\n    FROM public.email_notifications\r\n    WHERE created_at >= NOW() - (p_hours || ' hours')::interval\r\n    GROUP BY event_id\r\n    ORDER BY count DESC\r\n    LIMIT 10\r\n  )\r\n  SELECT jsonb_build_object(\r\n    'summary', row_to_json(stats),\r\n    'by_event', json_agg(row_to_json(event_stats))\r\n  ) INTO v_stats\r\n  FROM stats, event_stats\r\n  GROUP BY stats.*;\r\n\r\n  RETURN v_stats;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_pending_email_batch",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_pending_email_batch()\n RETURNS TABLE(batch_id uuid, notification_type text, content_id text, content_title text, content_data jsonb, recipients jsonb)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT\r\n        b.id as batch_id,\r\n        b.notification_type,\r\n        b.content_id,\r\n        CASE\r\n            WHEN b.notification_type = 'update_published' THEN\r\n                COALESCE(b.content_data->>'update_title', 'Update')\r\n            WHEN b.notification_type = 'survey_published' THEN\r\n                COALESCE(b.content_data->>'survey_title', 'Survey')\r\n            WHEN b.notification_type = 'event_published' THEN\r\n                COALESCE(b.content_data->>'event_title', 'Event')\r\n            ELSE 'Notification'\r\n        END as content_title,\r\n        b.content_data,\r\n        b.content_data->'recipients' as recipients\r\n    FROM email_notification_batches b\r\n    WHERE b.status = 'pending'\r\n    ORDER BY b.created_at ASC\r\n    LIMIT 1;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_pending_notifications",
    "arguments": "p_limit integer",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_pending_notifications(p_limit integer DEFAULT 20)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_notifications JSON;\r\nBEGIN\r\n  -- Mark notifications as processing and return them\r\n  WITH pending AS (\r\n    UPDATE public.email_notifications\r\n    SET\r\n      status = 'processing',\r\n      updated_at = NOW()\r\n    WHERE id IN (\r\n      SELECT id\r\n      FROM public.email_notifications\r\n      WHERE (\r\n        (status = 'pending' AND scheduled_for <= NOW())\r\n        OR (status = 'failed' AND retry_after <= NOW() AND error_count < max_retries)\r\n      )\r\n      ORDER BY priority DESC, scheduled_for ASC\r\n      LIMIT p_limit\r\n      FOR UPDATE SKIP LOCKED\r\n    )\r\n    RETURNING *\r\n  )\r\n  SELECT json_agg(row_to_json(pending)) INTO v_notifications\r\n  FROM pending;\r\n\r\n  -- Log processing start for each notification\r\n  INSERT INTO public.notification_logs (notification_id, event_type, details)\r\n  SELECT\r\n    (n->>'id')::UUID,\r\n    'processing',\r\n    jsonb_build_object('batch_size', p_limit)\r\n  FROM json_array_elements(COALESCE(v_notifications, '[]'::json)) AS n;\r\n\r\n  RETURN COALESCE(v_notifications, '[]'::json);\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_portal_email_recipients",
    "arguments": "p_target_audience text, p_notification_type text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_portal_email_recipients(p_target_audience text DEFAULT 'all'::text, p_notification_type text DEFAULT 'updates'::text)\n RETURNS TABLE(user_id uuid, email text, first_name text, last_name text)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  WITH portal_users AS (\r\n    -- 1. System admins (super_admin and admin) - they automatically have portal access\r\n    SELECT DISTINCT\r\n      sua.user_id,\r\n      p.email,\r\n      p.first_name,\r\n      p.last_name,\r\n      'portal_admin' as portal_role\r\n    FROM system_user_assignments sua\r\n    INNER JOIN profiles p ON p.id = sua.user_id\r\n    WHERE sua.system_role IN ('super_admin', 'admin')\r\n      AND sua.is_active = true\r\n      AND p.email IS NOT NULL\r\n\r\n    UNION\r\n\r\n    -- 2. Explicit portal memberships from portal_memberships table\r\n    SELECT DISTINCT\r\n      pm.user_id,\r\n      p.email,\r\n      p.first_name,\r\n      p.last_name,\r\n      pm.portal_role\r\n    FROM portal_memberships pm\r\n    INNER JOIN profiles p ON p.id = pm.user_id\r\n    WHERE pm.is_active = true\r\n      AND p.email IS NOT NULL\r\n\r\n    UNION\r\n\r\n    -- 3. Portal members from profiles table (users with portal_member role)\r\n    SELECT DISTINCT\r\n      p.id as user_id,\r\n      p.email,\r\n      p.first_name,\r\n      p.last_name,\r\n      'portal_member' as portal_role\r\n    FROM profiles p\r\n    WHERE p.role = 'portal_member'\r\n      AND p.email IS NOT NULL\r\n  )\r\n  SELECT DISTINCT\r\n    pu.user_id,\r\n    pu.email::TEXT,\r\n    pu.first_name::TEXT,\r\n    pu.last_name::TEXT\r\n  FROM portal_users pu\r\n  LEFT JOIN user_email_preferences ep ON ep.user_id = pu.user_id\r\n  WHERE\r\n    -- Check email preferences\r\n    (\r\n      ep.user_id IS NULL -- No preferences = enabled by default\r\n      OR (\r\n        -- Check specific notification type preferences\r\n        CASE\r\n          WHEN p_notification_type = 'updates' THEN COALESCE(ep.updates_enabled, true)\r\n          WHEN p_notification_type = 'surveys' THEN COALESCE(ep.surveys_enabled, true)\r\n          WHEN p_notification_type = 'events' THEN COALESCE(ep.events_enabled, true)\r\n          ELSE true\r\n        END\r\n        AND COALESCE(ep.frequency, 'immediate') != 'never'\r\n      )\r\n    )\r\n    -- Apply target audience filter if specified\r\n    AND (\r\n      p_target_audience = 'all'\r\n      OR (p_target_audience = 'investors' AND pu.portal_role = 'portal_investor')\r\n      OR (p_target_audience = 'members' AND pu.portal_role = 'portal_member')\r\n      OR (p_target_audience = 'admins' AND pu.portal_role = 'portal_admin')\r\n    )\r\n  ORDER BY pu.email;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "invoke_email_processing",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.invoke_email_processing()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_edge_function_url text;\r\n  v_service_role_key text;\r\nBEGIN\r\n  -- Get configuration from table\r\n  SELECT value INTO v_edge_function_url\r\n  FROM email_config\r\n  WHERE key = 'supabase_url';\r\n\r\n  SELECT value INTO v_service_role_key\r\n  FROM email_config\r\n  WHERE key = 'service_role_key';\r\n\r\n  IF v_edge_function_url IS NOT NULL AND v_service_role_key IS NOT NULL THEN\r\n    -- Append function path\r\n    v_edge_function_url := v_edge_function_url || '/functions/v1/process-email-queue';\r\n\r\n    -- Make async HTTP request to Edge Function using pg_net\r\n    PERFORM net.http_post(\r\n      url := v_edge_function_url,\r\n      headers := jsonb_build_object(\r\n        'Authorization', 'Bearer ' || v_service_role_key,\r\n        'Content-Type', 'application/json'\r\n      ),\r\n      body := jsonb_build_object('batchSize', 10),\r\n      timeout_milliseconds := 30000\r\n    );\r\n  END IF;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "mark_email_failed",
    "arguments": "p_queue_id uuid, p_error text, p_error_details jsonb",
    "function_definition": "CREATE OR REPLACE FUNCTION public.mark_email_failed(p_queue_id uuid, p_error text, p_error_details jsonb DEFAULT '{}'::jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_attempts integer;\r\n    v_max_attempts integer;\r\n    v_retry_delay interval;\r\nBEGIN\r\n    SELECT attempts, max_attempts\r\n    INTO v_attempts, v_max_attempts\r\n    FROM email_queue\r\n    WHERE id = p_queue_id;\r\n\r\n    -- Calculate retry delay (exponential backoff)\r\n    v_retry_delay := (power(2, LEAST(v_attempts, 6))::text || ' minutes')::interval;\r\n\r\n    UPDATE email_queue\r\n    SET\r\n        status = CASE\r\n            WHEN v_attempts >= v_max_attempts THEN 'failed'\r\n            ELSE 'pending'\r\n        END,\r\n        last_error = p_error,\r\n        error_details = p_error_details,\r\n        next_retry_at = CASE\r\n            WHEN v_attempts < v_max_attempts THEN now() + v_retry_delay\r\n            ELSE NULL\r\n        END,\r\n        scheduled_for = CASE\r\n            WHEN v_attempts < v_max_attempts THEN now() + v_retry_delay\r\n            ELSE scheduled_for\r\n        END,\r\n        updated_at = now()\r\n    WHERE id = p_queue_id;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "mark_email_sent",
    "arguments": "p_queue_id uuid, p_resend_id text, p_metadata jsonb",
    "function_definition": "CREATE OR REPLACE FUNCTION public.mark_email_sent(p_queue_id uuid, p_resend_id text DEFAULT NULL::text, p_metadata jsonb DEFAULT '{}'::jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    UPDATE email_queue\r\n    SET\r\n        status = 'sent',\r\n        processed_at = now(),\r\n        metadata = metadata || p_metadata,\r\n        updated_at = now()\r\n    WHERE id = p_queue_id;\r\n\r\n    -- Also log to email_logs if desired\r\n    INSERT INTO email_logs (\r\n        id,\r\n        to_email,\r\n        subject,\r\n        template,\r\n        status,\r\n        resend_id,\r\n        sent_at,\r\n        metadata\r\n    )\r\n    SELECT\r\n        gen_random_uuid(),\r\n        eq.to_email,\r\n        COALESCE(et.subject, 'Email Notification'),\r\n        et.name,\r\n        'sent',\r\n        p_resend_id,\r\n        now(),\r\n        eq.metadata || p_metadata\r\n    FROM email_queue eq\r\n    LEFT JOIN email_templates et ON eq.template_id = et.id::text\r\n    WHERE eq.id = p_queue_id;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "process_email_queue",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.process_email_queue()\n RETURNS integer\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  processed_count INTEGER := 0;\r\n  queue_record RECORD;\r\nBEGIN\r\n  -- Get emails ready to be sent\r\n  FOR queue_record IN\r\n    SELECT * FROM public.email_queue\r\n    WHERE status = 'queued'\r\n      AND scheduled_for <= NOW()\r\n      AND attempts < max_attempts\r\n    ORDER BY priority DESC, scheduled_for\r\n    LIMIT 10\r\n  LOOP\r\n    -- Mark as processing\r\n    UPDATE public.email_queue\r\n    SET status = 'processing',\r\n        attempts = attempts + 1,\r\n        processor_id = gen_random_uuid()::text\r\n    WHERE id = queue_record.id;\r\n    \r\n    -- Here you would trigger the actual email send\r\n    -- For now, we'll just mark it as ready for the Edge Function\r\n    \r\n    processed_count := processed_count + 1;\r\n  END LOOP;\r\n  \r\n  RETURN processed_count;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "process_email_queue_manual",
    "arguments": "p_batch_size integer",
    "function_definition": "CREATE OR REPLACE FUNCTION public.process_email_queue_manual(p_batch_size integer DEFAULT 10)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n    v_processed int := 0;\r\n    v_email RECORD;\r\n    v_result jsonb := jsonb_build_object('processed', 0, 'errors', ARRAY[]::text[]);\r\nBEGIN\r\n    -- Get batch of pending emails\r\n    FOR v_email IN\r\n        SELECT *\r\n        FROM email_queue\r\n        WHERE status = 'pending'\r\n            AND scheduled_for <= now()\r\n            AND (expires_at IS NULL OR expires_at > now())\r\n        ORDER BY priority DESC, created_at ASC\r\n        LIMIT p_batch_size\r\n        FOR UPDATE SKIP LOCKED\r\n    LOOP\r\n        -- Mark as processing\r\n        UPDATE email_queue\r\n        SET status = 'processing',\r\n            attempts = attempts + 1,\r\n            last_attempt_at = now()\r\n        WHERE id = v_email.id;\r\n\r\n        v_processed := v_processed + 1;\r\n\r\n        -- Note: Actual email sending would happen via edge function\r\n        -- This is just for manual queue inspection\r\n        RAISE NOTICE 'Would process email % to %', v_email.id, v_email.to_email;\r\n    END LOOP;\r\n\r\n    v_result := jsonb_set(v_result, '{processed}', to_jsonb(v_processed));\r\n    RETURN v_result;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "process_email_queue_trigger",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.process_email_queue_trigger()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n    v_batch RECORD;\r\n    v_result jsonb;\r\nBEGIN\r\n    -- Process emails by calling the edge function via HTTP\r\n    -- Note: This requires pg_net extension\r\n\r\n    -- For now, we'll just mark emails for processing\r\n    -- The actual sending needs to be done by the edge function\r\n\r\n    -- Get batch of emails to process\r\n    FOR v_batch IN\r\n        SELECT * FROM get_next_email_batch(10)\r\n    LOOP\r\n        RAISE NOTICE 'Would process email: % to %', v_batch.queue_id, v_batch.to_email;\r\n\r\n        -- In production, this would call the edge function\r\n        -- For now, we need to manually process or use the UI\r\n    END LOOP;\r\n\r\n    -- Alternative: Use Supabase's HTTP client if available\r\n    -- This is what actually needs to happen:\r\n    -- PERFORM net.http_post(\r\n    --     url := 'https://your-project.supabase.co/functions/v1/process-email-queue',\r\n    --     headers := '{\"Authorization\": \"Bearer YOUR_SERVICE_KEY\"}'::jsonb,\r\n    --     body := '{\"batchSize\": 10}'::jsonb\r\n    -- );\r\n\r\n    RETURN;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "process_referral_emails_now",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.process_referral_emails_now()\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_result jsonb;\r\n  v_edge_function_url text;\r\n  v_service_role_key text;\r\nBEGIN\r\n  v_edge_function_url := current_setting('app.supabase_url', true) || '/functions/v1/process-email-queue';\r\n  v_service_role_key := current_setting('app.service_role_key', true);\r\n\r\n  -- Check configuration\r\n  IF v_edge_function_url IS NULL OR v_service_role_key IS NULL THEN\r\n    RETURN jsonb_build_object(\r\n      'success', false,\r\n      'error', 'Missing configuration: app.supabase_url or app.service_role_key not set'\r\n    );\r\n  END IF;\r\n\r\n  -- Call Edge Function synchronously and return result\r\n  SELECT content::jsonb INTO v_result\r\n  FROM net.http_post(\r\n    url := v_edge_function_url,\r\n    headers := jsonb_build_object(\r\n      'Authorization', 'Bearer ' || v_service_role_key,\r\n      'Content-Type', 'application/json'\r\n    ),\r\n    body := jsonb_build_object('batchSize', 50),\r\n    timeout_milliseconds := 60000\r\n  );\r\n\r\n  RETURN v_result;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "queue_email",
    "arguments": "p_event_type text, p_event_id text, p_event_payload jsonb, p_template_id text, p_recipient_list_id text, p_to_email text, p_to_user_id uuid, p_priority integer, p_scheduled_for timestamp with time zone, p_metadata jsonb",
    "function_definition": "CREATE OR REPLACE FUNCTION public.queue_email(p_event_type text, p_event_id text DEFAULT NULL::text, p_event_payload jsonb DEFAULT '{}'::jsonb, p_template_id text DEFAULT NULL::text, p_recipient_list_id text DEFAULT NULL::text, p_to_email text DEFAULT NULL::text, p_to_user_id uuid DEFAULT NULL::uuid, p_priority integer DEFAULT 5, p_scheduled_for timestamp with time zone DEFAULT now(), p_metadata jsonb DEFAULT '{}'::jsonb)\n RETURNS uuid\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_queue_id uuid;\r\nBEGIN\r\n    -- Validate that we have either a recipient list or individual recipient\r\n    IF p_recipient_list_id IS NULL AND p_to_email IS NULL THEN\r\n        RAISE EXCEPTION 'Must provide either recipient_list_id or to_email';\r\n    END IF;\r\n\r\n    IF p_to_email IS NOT NULL THEN\r\n        -- Single recipient\r\n        INSERT INTO email_queue (\r\n            event_type, event_id, event_payload, template_id,\r\n            to_email, to_user_id, priority, scheduled_for, metadata\r\n        )\r\n        VALUES (\r\n            p_event_type, p_event_id, p_event_payload, p_template_id,\r\n            p_to_email, p_to_user_id, p_priority, p_scheduled_for, p_metadata\r\n        )\r\n        RETURNING id INTO v_queue_id;\r\n    END IF;\r\n\r\n    RETURN v_queue_id;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "queue_event_email_notifications",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.queue_event_email_notifications()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_batch_id UUID;\r\n    v_recipients JSONB;\r\n    v_recipient_count INT;\r\nBEGIN\r\n    -- Only process on status change to 'published'\r\n    IF NEW.status = 'published' AND (OLD.status IS NULL OR OLD.status != 'published') THEN\r\n\r\n        -- Don't create duplicate batches\r\n        IF EXISTS (\r\n            SELECT 1 FROM email_notification_batches\r\n            WHERE content_id = NEW.id::TEXT\r\n            AND notification_type = 'event_published'\r\n        ) THEN\r\n            RAISE NOTICE 'Email batch already exists for event %', NEW.id;\r\n            RETURN NEW;\r\n        END IF;\r\n\r\n        v_batch_id := gen_random_uuid();\r\n\r\n        -- Get recipients (all portal users)\r\n        SELECT\r\n            COUNT(*),\r\n            jsonb_agg(jsonb_build_object(\r\n                'user_id', p.id,\r\n                'email', p.email,\r\n                'first_name', p.first_name,\r\n                'last_name', p.last_name\r\n            ))\r\n        INTO v_recipient_count, v_recipients\r\n        FROM profiles p\r\n        WHERE p.email IS NOT NULL\r\n        AND p.email != ''\r\n        AND p.role IN ('portal_member', 'admin', 'super_admin', 'investor');\r\n\r\n        IF v_recipient_count > 0 THEN\r\n            -- Insert batch\r\n            INSERT INTO email_notification_batches (\r\n                id,\r\n                notification_type,\r\n                content_id,\r\n                content_data,\r\n                status,\r\n                created_at\r\n            ) VALUES (\r\n                v_batch_id,\r\n                'event_published',\r\n                NEW.id::TEXT,\r\n                jsonb_build_object(\r\n                    'event_id', NEW.id,\r\n                    'event_title', NEW.title,\r\n                    'event_description', NEW.description,\r\n                    'event_date', NEW.event_date,\r\n                    'location', NEW.location,\r\n                    'recipients', v_recipients\r\n                ),\r\n                'pending',\r\n                NOW()\r\n            );\r\n\r\n            -- Update event record\r\n            NEW.email_batch_id := v_batch_id;\r\n            NEW.email_sent_at := NOW();\r\n\r\n            RAISE NOTICE 'Created email batch % for event % with % recipients',\r\n                v_batch_id, NEW.id, v_recipient_count;\r\n        ELSE\r\n            RAISE NOTICE 'No recipients found for event %', NEW.id;\r\n        END IF;\r\n    END IF;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "queue_notification",
    "arguments": "p_event_id text, p_event_data jsonb, p_triggered_by uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.queue_notification(p_event_id text, p_event_data jsonb, p_triggered_by uuid DEFAULT NULL::uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\n  DECLARE\r\n    v_rule RECORD;\r\n    v_template RECORD;\r\n    v_recipients UUID[];\r\n    v_recipient UUID;\r\n    v_email TEXT;\r\n    v_user_name TEXT;\r\n    v_queued_count INTEGER := 0;\r\n    v_result JSON;\r\n    v_dynamic_emails TEXT[];\r\n    v_dynamic_email TEXT;\r\n    v_static_email TEXT;\r\n    v_notification_id UUID;\r\n  BEGIN\r\n    RAISE NOTICE 'queue_notification called with event_id: %, data: %', p_event_id, p_event_data;\r\n\r\n    -- Get active rules for this event\r\n    FOR v_rule IN\r\n      SELECT * FROM public.notification_rules\r\n      WHERE event_id = p_event_id AND enabled = true\r\n      ORDER BY priority\r\n    LOOP\r\n      RAISE NOTICE 'Processing rule: % (type: %)', v_rule.name, v_rule.recipient_type;\r\n\r\n      -- Get the template\r\n      SELECT * INTO v_template\r\n      FROM public.email_templates\r\n      WHERE id = v_rule.template_id AND is_active = true;\r\n\r\n      IF v_template IS NULL THEN\r\n        RAISE NOTICE 'No active template found for rule';\r\n        CONTINUE;\r\n      END IF;\r\n\r\n      -- Determine recipients based on recipient_type\r\n      v_recipients := ARRAY[]::UUID[];\r\n      v_dynamic_emails := ARRAY[]::TEXT[];\r\n\r\n      -- HANDLE STATIC RECIPIENT TYPE\r\n      IF v_rule.recipient_type = 'static' THEN\r\n        -- Get the static email from recipient_config\r\n        v_static_email := v_rule.recipient_config->>'email';\r\n\r\n        IF v_static_email IS NOT NULL THEN\r\n          -- Insert notification for static email\r\n          INSERT INTO public.email_notifications (\r\n            id,\r\n            event_id,\r\n            rule_id,\r\n            to_email,\r\n            subject,\r\n            template_id,\r\n            template_data,\r\n            status,\r\n            priority,\r\n            created_by,\r\n            created_at\r\n          ) VALUES (\r\n            gen_random_uuid(),\r\n            p_event_id,\r\n            v_rule.id,\r\n            v_static_email,\r\n            v_template.subject,\r\n            v_template.id,\r\n            p_event_data,\r\n            'pending',\r\n            v_rule.priority,\r\n            p_triggered_by,\r\n            NOW()\r\n          );\r\n\r\n          v_queued_count := v_queued_count + 1;\r\n          RAISE NOTICE 'Queued static email for %', v_static_email;\r\n        END IF;\r\n\r\n      ELSIF v_rule.recipient_type = 'role' THEN\r\n        -- Get all users with specified roles\r\n        IF v_rule.recipient_config ? 'roles' THEN\r\n          SELECT array_agg(id) INTO v_recipients\r\n          FROM public.profiles\r\n          WHERE role = ANY((v_rule.recipient_config->>'roles')::text[])\r\n            AND email IS NOT NULL;\r\n        ELSE\r\n          -- Fallback to default roles\r\n          SELECT array_agg(id) INTO v_recipients\r\n          FROM public.profiles\r\n          WHERE role IN ('portal_member', 'admin', 'super_admin', 'investor')\r\n            AND email IS NOT NULL;\r\n        END IF;\r\n\r\n        RAISE NOTICE 'Found % recipients with roles', COALESCE(array_length(v_recipients, 1), 0);\r\n\r\n      ELSIF v_rule.recipient_type = 'dynamic' THEN\r\n        -- Handle dynamic recipient type\r\n        -- Check if it's a simple field reference (like the welcome email)\r\n        IF v_rule.recipient_config ? 'field' AND v_rule.recipient_config ? 'source' THEN\r\n          -- Extract email from event data\r\n          v_dynamic_email := p_event_data->>(v_rule.recipient_config->>'field');\r\n\r\n          IF v_dynamic_email IS NOT NULL THEN\r\n            -- Insert notification for dynamic email\r\n            INSERT INTO public.email_notifications (\r\n              id,\r\n              event_id,\r\n              rule_id,\r\n              to_email,\r\n              subject,\r\n              template_id,\r\n              template_data,\r\n              status,\r\n              priority,\r\n              created_by,\r\n              created_at\r\n            ) VALUES (\r\n              gen_random_uuid(),\r\n              p_event_id,\r\n              v_rule.id,\r\n              v_dynamic_email,\r\n              v_template.subject,\r\n              v_template.id,\r\n              p_event_data,\r\n              'pending',\r\n              v_rule.priority,\r\n              p_triggered_by,\r\n              NOW()\r\n            );\r\n\r\n            v_queued_count := v_queued_count + 1;\r\n            RAISE NOTICE 'Queued dynamic email for %', v_dynamic_email;\r\n          END IF;\r\n\r\n        ELSIF v_rule.recipient_config ? 'query' THEN\r\n          -- Handle SQL query based dynamic recipients (existing code)\r\n          BEGIN\r\n            EXECUTE v_rule.recipient_config->>'query' INTO v_dynamic_emails;\r\n            RAISE NOTICE 'Dynamic query returned % emails', COALESCE(array_length(v_dynamic_emails,\r\n   1), 0);\r\n          EXCEPTION\r\n            WHEN OTHERS THEN\r\n              -- If query fails, try simpler approach\r\n              SELECT array_agg(email) INTO v_dynamic_emails\r\n              FROM public.profiles\r\n              WHERE role IN ('portal_member', 'admin', 'super_admin', 'investor')\r\n                AND email IS NOT NULL;\r\n              RAISE NOTICE 'Fallback query returned % emails',\r\n  COALESCE(array_length(v_dynamic_emails, 1), 0);\r\n          END;\r\n\r\n          -- Queue emails for dynamic query results\r\n          IF v_dynamic_emails IS NOT NULL AND array_length(v_dynamic_emails, 1) > 0 THEN\r\n            FOREACH v_dynamic_email IN ARRAY v_dynamic_emails\r\n            LOOP\r\n              IF v_dynamic_email IS NOT NULL THEN\r\n                INSERT INTO public.email_notifications (\r\n                  id,\r\n                  event_id,\r\n                  rule_id,\r\n                  to_email,\r\n                  subject,\r\n                  template_id,\r\n                  template_data,\r\n                  status,\r\n                  priority,\r\n                  created_by,\r\n                  created_at\r\n                ) VALUES (\r\n                  gen_random_uuid(),\r\n                  p_event_id,\r\n                  v_rule.id,\r\n                  v_dynamic_email,\r\n                  v_template.subject,\r\n                  v_template.id,\r\n                  p_event_data || jsonb_build_object('user_name', 'Portal Member'),\r\n                  'pending',\r\n                  v_rule.priority,\r\n                  p_triggered_by,\r\n                  NOW()\r\n                );\r\n\r\n                v_queued_count := v_queued_count + 1;\r\n                RAISE NOTICE 'Queued email for %', v_dynamic_email;\r\n              END IF;\r\n            END LOOP;\r\n          END IF;\r\n        END IF;\r\n      END IF;\r\n\r\n      -- Queue email for role-based recipients\r\n      IF v_recipients IS NOT NULL AND array_length(v_recipients, 1) > 0 THEN\r\n        FOREACH v_recipient IN ARRAY v_recipients\r\n        LOOP\r\n          -- Get recipient details\r\n          SELECT email, COALESCE(first_name, 'Portal Member')\r\n          INTO v_email, v_user_name\r\n          FROM public.profiles\r\n          WHERE id = v_recipient;\r\n\r\n          IF v_email IS NOT NULL THEN\r\n            -- Add user_name to event data\r\n            p_event_data := p_event_data || jsonb_build_object('user_name', v_user_name);\r\n\r\n            -- Insert into email_notifications table\r\n            INSERT INTO public.email_notifications (\r\n              id,\r\n              event_id,\r\n              rule_id,\r\n              to_email,\r\n              subject,\r\n              template_id,\r\n              template_data,\r\n              status,\r\n              priority,\r\n              created_by,\r\n              created_at\r\n            ) VALUES (\r\n              gen_random_uuid(),\r\n              p_event_id,\r\n              v_rule.id,\r\n              v_email,\r\n              v_template.subject,\r\n              v_template.id,\r\n              p_event_data,\r\n              'pending',\r\n              v_rule.priority,\r\n              v_recipient,  -- Use the user's ID as created_by\r\n              NOW()\r\n            );\r\n\r\n            v_queued_count := v_queued_count + 1;\r\n            RAISE NOTICE 'Queued email for %', v_email;\r\n          END IF;\r\n        END LOOP;\r\n      END IF;\r\n    END LOOP;\r\n\r\n    -- Return result\r\n    v_result := json_build_object(\r\n      'success', true,\r\n      'queued_count', v_queued_count,\r\n      'event_id', p_event_id\r\n    );\r\n\r\n    RAISE NOTICE 'queue_notification result: %', v_result;\r\n    RETURN v_result;\r\n  EXCEPTION\r\n    WHEN OTHERS THEN\r\n      RAISE NOTICE 'Error in queue_notification: %', SQLERRM;\r\n      RETURN json_build_object(\r\n        'success', false,\r\n        'error', SQLERRM\r\n      );\r\n  END;\r\n  $function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "queue_notification_emails",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.queue_notification_emails()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_event_type TEXT;\r\n    v_event_payload JSONB;\r\n    v_rule RECORD;\r\n    v_recipient_list RECORD;\r\n    v_recipient RECORD;\r\n    v_roles TEXT[];\r\n    v_source_field TEXT;\r\n    v_recipient_email TEXT;\r\n    v_recipient_id UUID;\r\n    v_base_url TEXT := 'https://portal.fleetdrms.com';\r\n    v_portal_url TEXT;\r\n    v_referrer RECORD;\r\nBEGIN\r\n    -- Determine event type based on table and operation\r\n    IF TG_TABLE_NAME = 'portal_updates' THEN\r\n        IF TG_OP = 'INSERT' THEN\r\n            v_event_type := 'update_published';\r\n        ELSE\r\n            RETURN NEW;\r\n        END IF;\r\n        -- Build portal URL for updates\r\n        v_portal_url := v_base_url || '/updates/' || NEW.id;\r\n    ELSIF TG_TABLE_NAME = 'portal_events' THEN\r\n        IF TG_OP = 'INSERT' THEN\r\n            v_event_type := 'event_created';\r\n        ELSIF TG_OP = 'UPDATE' AND OLD.event_date IS DISTINCT FROM NEW.event_date THEN\r\n            v_event_type := 'event_updated';\r\n        ELSE\r\n            RETURN NEW;\r\n        END IF;\r\n        -- Build portal URL for events\r\n        v_portal_url := v_base_url || '/events/' || NEW.id;\r\n    ELSIF TG_TABLE_NAME = 'portal_referrals' THEN\r\n        IF TG_OP = 'INSERT' THEN\r\n            v_event_type := 'referral_created';\r\n            -- Build portal URL for referral registration\r\n            v_portal_url := v_base_url || '/register?ref=' || NEW.referral_code;\r\n        ELSE\r\n            RETURN NEW;\r\n        END IF;\r\n    ELSIF TG_TABLE_NAME = 'contact_submissions' THEN\r\n        IF TG_OP = 'INSERT' THEN\r\n            v_event_type := 'contact_form_submitted';\r\n        ELSE\r\n            RETURN NEW;\r\n        END IF;\r\n    ELSE\r\n        RETURN NEW;\r\n    END IF;\r\n\r\n    -- Build event payload\r\n    v_event_payload := to_jsonb(NEW);\r\n    IF v_portal_url IS NOT NULL THEN\r\n        v_event_payload := v_event_payload || jsonb_build_object('portal_url', v_portal_url);\r\n    END IF;\r\n\r\n    -- For referral events, look up the referrer's information from profiles table\r\n    IF TG_TABLE_NAME = 'portal_referrals' AND NEW.referrer_id IS NOT NULL THEN\r\n        RAISE NOTICE 'Looking up referrer with ID: %', NEW.referrer_id;\r\n\r\n        SELECT first_name, last_name, email\r\n        INTO v_referrer\r\n        FROM profiles\r\n        WHERE id = NEW.referrer_id;\r\n\r\n        IF FOUND THEN\r\n            RAISE NOTICE 'Found referrer: % %', v_referrer.first_name, v_referrer.last_name;\r\n            -- Add referrer information to payload\r\n            v_event_payload := v_event_payload || jsonb_build_object(\r\n                'referrer_first_name', COALESCE(v_referrer.first_name, ''),\r\n                'referrer_last_name', COALESCE(v_referrer.last_name, ''),\r\n                'referrer_email', COALESCE(v_referrer.email, '')\r\n            );\r\n            RAISE NOTICE 'Added referrer to payload';\r\n        ELSE\r\n            RAISE NOTICE 'Referrer NOT found in profiles table';\r\n        END IF;\r\n    END IF;\r\n\r\n    -- Find all enabled notification rules for this event type\r\n    FOR v_rule IN\r\n        SELECT * FROM notification_rules\r\n        WHERE event_id = v_event_type\r\n        AND enabled = true\r\n    LOOP\r\n        -- Get the recipient list\r\n        SELECT * INTO v_recipient_list\r\n        FROM recipient_lists\r\n        WHERE id = v_rule.recipient_list_id;\r\n\r\n        IF NOT FOUND THEN\r\n            CONTINUE;\r\n        END IF;\r\n\r\n        -- Handle different recipient list types\r\n        IF v_recipient_list.type = 'role_based' THEN\r\n            -- Role-based recipient list\r\n            SELECT ARRAY(SELECT jsonb_array_elements_text(v_recipient_list.config->'roles'))\r\n            INTO v_roles;\r\n\r\n            FOR v_recipient IN\r\n                SELECT DISTINCT p.email, p.id as user_id, p.first_name, p.last_name\r\n                FROM profiles p\r\n                WHERE p.role = ANY(v_roles)\r\n                AND p.email IS NOT NULL\r\n            LOOP\r\n                INSERT INTO email_queue (\r\n                    to_email,\r\n                    to_user_id,\r\n                    template_id,\r\n                    event_type,\r\n                    event_id,\r\n                    event_payload,\r\n                    recipient_list_id,\r\n                    status,\r\n                    priority,\r\n                    created_at\r\n                )\r\n                VALUES (\r\n                    v_recipient.email,\r\n                    v_recipient.user_id,\r\n                    v_rule.template_id,\r\n                    v_event_type,\r\n                    NEW.id::text,\r\n                    v_event_payload || jsonb_build_object(\r\n                        'recipient_first_name', v_recipient.first_name,\r\n                        'recipient_last_name', v_recipient.last_name\r\n                    ),\r\n                    v_rule.recipient_list_id,\r\n                    'pending',\r\n                    v_rule.priority,\r\n                    NOW()\r\n                );\r\n            END LOOP;\r\n        ELSIF v_recipient_list.type = 'static' THEN\r\n            -- Static recipient list\r\n            FOR v_recipient IN\r\n                SELECT DISTINCT\r\n                    u.email,\r\n                    u.id as user_id,\r\n                    u.first_name,\r\n                    u.last_name\r\n                FROM jsonb_array_elements(v_recipient_list.config->'user_ids') AS user_id_elem\r\n                JOIN profiles u ON u.id = (user_id_elem#>>'{}')::uuid\r\n                WHERE u.email IS NOT NULL\r\n            LOOP\r\n                INSERT INTO email_queue (\r\n                    to_email,\r\n                    to_user_id,\r\n                    template_id,\r\n                    event_type,\r\n                    event_id,\r\n                    event_payload,\r\n                    recipient_list_id,\r\n                    status,\r\n                    priority,\r\n                    created_at\r\n                )\r\n                VALUES (\r\n                    v_recipient.email,\r\n                    v_recipient.user_id,\r\n                    v_rule.template_id,\r\n                    v_event_type,\r\n                    NEW.id::text,\r\n                    v_event_payload || jsonb_build_object(\r\n                        'recipient_first_name', v_recipient.first_name,\r\n                        'recipient_last_name', v_recipient.last_name\r\n                    ),\r\n                    v_rule.recipient_list_id,\r\n                    'pending',\r\n                    v_rule.priority,\r\n                    NOW()\r\n                );\r\n            END LOOP;\r\n        ELSIF v_recipient_list.type = 'dynamic' THEN\r\n            -- Dynamic recipient list - extract email from event payload using configured path\r\n            v_source_field := v_recipient_list.config->>'source';\r\n\r\n            IF v_source_field IS NOT NULL THEN\r\n                -- Remove \"event.\" prefix if present\r\n                v_source_field := regexp_replace(v_source_field, '^event\\.', '');\r\n\r\n                -- Extract email from event payload\r\n                v_recipient_email := v_event_payload->>v_source_field;\r\n\r\n                IF v_recipient_email IS NOT NULL AND v_recipient_email ~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$' THEN\r\n                    -- Look up user by email to get their ID and name\r\n                    SELECT id, first_name, last_name\r\n                    INTO v_recipient_id, v_recipient.first_name, v_recipient.last_name\r\n                    FROM profiles\r\n                    WHERE email = v_recipient_email;\r\n\r\n                    -- Determine which name to use for personalization\r\n                    -- For referee emails, use referee's name from the payload\r\n                    IF v_source_field = 'referee_email' THEN\r\n                        INSERT INTO email_queue (\r\n                            to_email,\r\n                            to_user_id,\r\n                            template_id,\r\n                            event_type,\r\n                            event_id,\r\n                            event_payload,\r\n                            recipient_list_id,\r\n                            status,\r\n                            priority,\r\n                            created_at\r\n                        )\r\n                        VALUES (\r\n                            v_recipient_email,\r\n                            v_recipient_id,\r\n                            v_rule.template_id,\r\n                            v_event_type,\r\n                            NEW.id::text,\r\n                            v_event_payload || jsonb_build_object(\r\n                                'recipient_first_name', COALESCE(v_event_payload->>'referee_first_name', ''),\r\n                                'recipient_last_name', COALESCE(v_event_payload->>'referee_last_name', '')\r\n                            ),\r\n                            v_rule.recipient_list_id,\r\n                            'pending',\r\n                            v_rule.priority,\r\n                            NOW()\r\n                        );\r\n                    ELSE\r\n                        -- For other recipients, use their profiles name if found\r\n                        IF v_recipient_id IS NOT NULL THEN\r\n                            INSERT INTO email_queue (\r\n                                to_email,\r\n                                to_user_id,\r\n                                template_id,\r\n                                event_type,\r\n                                event_id,\r\n                                event_payload,\r\n                                recipient_list_id,\r\n                                status,\r\n                                priority,\r\n                                created_at\r\n                            )\r\n                            VALUES (\r\n                                v_recipient_email,\r\n                                v_recipient_id,\r\n                                v_rule.template_id,\r\n                                v_event_type,\r\n                                NEW.id::text,\r\n                                v_event_payload || jsonb_build_object(\r\n                                    'recipient_first_name', v_recipient.first_name,\r\n                                    'recipient_last_name', v_recipient.last_name\r\n                                ),\r\n                                v_rule.recipient_list_id,\r\n                                'pending',\r\n                                v_rule.priority,\r\n                                NOW()\r\n                            );\r\n                        END IF;\r\n                    END IF;\r\n                END IF;\r\n            END IF;\r\n\r\n        ELSIF v_recipient_list.type = 'custom' THEN\r\n            -- Custom recipient list logic can be added here in the future\r\n            CONTINUE;\r\n        END IF;\r\n    END LOOP;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "queue_survey_email_notifications",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.queue_survey_email_notifications()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_batch_id UUID;\r\n    v_recipients JSONB;\r\n    v_recipient_count INT;\r\nBEGIN\r\n    -- Only process on status change to 'published'\r\n    IF NEW.status = 'published' AND (OLD.status IS NULL OR OLD.status != 'published') THEN\r\n\r\n        -- Don't create duplicate batches\r\n        IF EXISTS (\r\n            SELECT 1 FROM email_notification_batches\r\n            WHERE content_id = NEW.id::TEXT\r\n            AND notification_type = 'survey_published'\r\n        ) THEN\r\n            RAISE NOTICE 'Email batch already exists for survey %', NEW.id;\r\n            RETURN NEW;\r\n        END IF;\r\n\r\n        v_batch_id := gen_random_uuid();\r\n\r\n        -- Get recipients (all portal users)\r\n        SELECT\r\n            COUNT(*),\r\n            jsonb_agg(jsonb_build_object(\r\n                'user_id', p.id,\r\n                'email', p.email,\r\n                'first_name', p.first_name,\r\n                'last_name', p.last_name\r\n            ))\r\n        INTO v_recipient_count, v_recipients\r\n        FROM profiles p\r\n        WHERE p.email IS NOT NULL\r\n        AND p.email != ''\r\n        AND p.role IN ('portal_member', 'admin', 'super_admin', 'investor');\r\n\r\n        IF v_recipient_count > 0 THEN\r\n            -- Insert batch\r\n            INSERT INTO email_notification_batches (\r\n                id,\r\n                notification_type,\r\n                content_id,\r\n                content_data,\r\n                status,\r\n                created_at\r\n            ) VALUES (\r\n                v_batch_id,\r\n                'survey_published',\r\n                NEW.id::TEXT,\r\n                jsonb_build_object(\r\n                    'survey_id', NEW.id,\r\n                    'survey_title', NEW.title,\r\n                    'survey_description', NEW.description,\r\n                    'recipients', v_recipients\r\n                ),\r\n                'pending',\r\n                NOW()\r\n            );\r\n\r\n            -- Update survey record\r\n            NEW.email_batch_id := v_batch_id;\r\n            NEW.email_sent_at := NOW();\r\n\r\n            RAISE NOTICE 'Created email batch % for survey % with % recipients',\r\n                v_batch_id, NEW.id, v_recipient_count;\r\n        END IF;\r\n    END IF;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "retry_failed_emails",
    "arguments": "p_hours integer",
    "function_definition": "CREATE OR REPLACE FUNCTION public.retry_failed_emails(p_hours integer DEFAULT 24)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_count int;\r\nBEGIN\r\n    UPDATE email_queue\r\n    SET status = 'pending',\r\n        attempts = 0,\r\n        last_error = null,\r\n        last_attempt_at = null\r\n    WHERE status = 'failed'\r\n        AND created_at > now() - interval '1 hour' * p_hours\r\n        AND attempts < max_attempts;\r\n\r\n    GET DIAGNOSTICS v_count = ROW_COUNT;\r\n\r\n    RAISE NOTICE 'Reset % failed emails to pending status', v_count;\r\n    RETURN v_count;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "send_calculator_notification",
    "arguments": "p_submission_data jsonb",
    "function_definition": "CREATE OR REPLACE FUNCTION public.send_calculator_notification(p_submission_data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_result JSONB;\r\nBEGIN\r\n  -- Queue the notification\r\n  v_result := public.queue_notification(\r\n    'calculator_submission',\r\n    jsonb_build_object(\r\n      'user_name', p_submission_data->>'user_name',\r\n      'user_email', p_submission_data->>'user_email',\r\n      'company_name', p_submission_data->>'company_name',\r\n      'fleet_size', p_submission_data->>'fleet_size',\r\n      'submission_date', COALESCE(p_submission_data->>'submission_date', NOW()::text),\r\n      'total_monthly_savings', p_submission_data->>'total_monthly_savings',\r\n      'total_annual_savings', p_submission_data->>'total_annual_savings',\r\n      'labor_savings_total', p_submission_data->>'labor_savings_total',\r\n      'system_savings_total', p_submission_data->>'system_savings_total',\r\n      'fixed_savings_total', p_submission_data->>'fixed_savings_total',\r\n      'labor_savings_items', p_submission_data->'labor_savings_items',\r\n      'labor_savings_items_count', jsonb_array_length(COALESCE(p_submission_data->'labor_savings_items', '[]'::jsonb)),\r\n      'system_replacement_items', p_submission_data->'system_replacement_items',\r\n      'system_replacement_items_count', jsonb_array_length(COALESCE(p_submission_data->'system_replacement_items', '[]'::jsonb)),\r\n      'fixed_savings_items', p_submission_data->'fixed_savings_items',\r\n      'fixed_savings_items_count', jsonb_array_length(COALESCE(p_submission_data->'fixed_savings_items', '[]'::jsonb)),\r\n      'notes', p_submission_data->>'notes',\r\n      'admin_calculator_url', 'https://fleetdrms.com/portal/admin/calculator',\r\n      'admin_dashboard_url', 'https://fleetdrms.com/portal/admin'\r\n    ),\r\n    p_submission_data->>'user_id'\r\n  );\r\n\r\n  RETURN v_result;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "set_default_email_preferences",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.set_default_email_preferences()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  UPDATE public.profiles\r\n  SET \r\n    email_updates = COALESCE(email_updates, true),\r\n    email_surveys = COALESCE(email_surveys, true),\r\n    email_events = COALESCE(email_events, true)\r\n  WHERE email_updates IS NULL \r\n     OR email_surveys IS NULL \r\n     OR email_events IS NULL;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "trigger_email_notification",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.trigger_email_notification()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_rule notification_rules;\r\n    v_recipient_list recipient_lists;\r\n    v_recipient RECORD;\r\n    v_template email_templates;\r\n    v_roles text[];\r\n    v_event_type text;\r\n    v_event_payload jsonb;\r\n    v_base_url text := 'https://portal.fleetdrms.com';\r\n    v_portal_url text;\r\n    v_dynamic_email text;\r\n    v_static_email text;\r\n    v_referrer RECORD;\r\n    v_email_pref_column text; -- Which email preference column to check\r\nBEGIN\r\n    -- Determine event type and email preference column based on table and operation\r\n    IF TG_TABLE_NAME = 'portal_updates' THEN\r\n        IF TG_OP = 'INSERT' AND NEW.status = 'published' THEN\r\n            v_event_type := 'update_published';\r\n            v_email_pref_column := 'email_updates';\r\n        ELSIF TG_OP = 'UPDATE' AND OLD.status != 'published' AND NEW.status = 'published' THEN\r\n            v_event_type := 'update_published';\r\n            v_email_pref_column := 'email_updates';\r\n        ELSE\r\n            RETURN NEW;\r\n        END IF;\r\n        v_portal_url := v_base_url || '/updates/' || NEW.id;\r\n\r\n    ELSIF TG_TABLE_NAME = 'portal_surveys' THEN\r\n        IF TG_OP = 'INSERT' AND NEW.status = 'published' THEN\r\n            v_event_type := 'survey_published';\r\n            v_email_pref_column := 'email_surveys';\r\n        ELSIF TG_OP = 'UPDATE' AND OLD.status != 'published' AND NEW.status = 'published' THEN\r\n            v_event_type := 'survey_published';\r\n            v_email_pref_column := 'email_surveys';\r\n        ELSE\r\n            RETURN NEW;\r\n        END IF;\r\n        v_portal_url := v_base_url || '/surveys/' || NEW.id;\r\n\r\n    ELSIF TG_TABLE_NAME = 'portal_events' THEN\r\n        IF TG_OP = 'INSERT' AND NEW.status = 'published' THEN\r\n            v_event_type := 'event_published';\r\n            v_email_pref_column := 'email_events';\r\n        ELSIF TG_OP = 'UPDATE' AND OLD.status != 'published' AND NEW.status = 'published' THEN\r\n            v_event_type := 'event_published';\r\n            v_email_pref_column := 'email_events';\r\n        ELSE\r\n            RETURN NEW;\r\n        END IF;\r\n        v_portal_url := v_base_url || '/events/' || NEW.id;\r\n\r\n    ELSIF TG_TABLE_NAME = 'portal_referrals' THEN\r\n        IF TG_OP = 'INSERT' THEN\r\n            v_event_type := 'referral_created';\r\n            v_email_pref_column := 'email_updates'; -- Default to email_updates for referrals\r\n            v_portal_url := v_base_url || '/register?ref=' || NEW.referral_code;\r\n\r\n            -- For referral events, look up the referrer's information\r\n            IF NEW.referrer_id IS NOT NULL THEN\r\n                SELECT first_name, last_name, email\r\n                INTO v_referrer\r\n                FROM profiles\r\n                WHERE id = NEW.referrer_id;\r\n            END IF;\r\n        ELSE\r\n            RETURN NEW;\r\n        END IF;\r\n\r\n    ELSIF TG_TABLE_NAME = 'contact_submissions' THEN\r\n        IF TG_OP = 'INSERT' THEN\r\n            v_event_type := 'contact_form_submitted';\r\n            v_email_pref_column := 'email_updates'; -- Default to email_updates for contact submissions\r\n        ELSE\r\n            RETURN NEW;\r\n        END IF;\r\n    ELSE\r\n        RETURN NEW;\r\n    END IF;\r\n\r\n    -- Build event payload\r\n    v_event_payload := to_jsonb(NEW);\r\n    IF v_portal_url IS NOT NULL THEN\r\n        v_event_payload := v_event_payload || jsonb_build_object('portal_url', v_portal_url);\r\n    END IF;\r\n\r\n    -- Add referrer info to payload if this was a referral event\r\n    IF TG_TABLE_NAME = 'portal_referrals' AND v_referrer IS NOT NULL THEN\r\n        v_event_payload := v_event_payload || jsonb_build_object(\r\n            'referrer_first_name', COALESCE(v_referrer.first_name, ''),\r\n            'referrer_last_name', COALESCE(v_referrer.last_name, ''),\r\n            'referrer_email', COALESCE(v_referrer.email, '')\r\n        );\r\n    END IF;\r\n\r\n    -- Find all enabled notification rules for this event type\r\n    FOR v_rule IN\r\n        SELECT * FROM notification_rules\r\n        WHERE event_id = v_event_type\r\n        AND enabled = true\r\n    LOOP\r\n        -- Get the recipient list\r\n        SELECT * INTO v_recipient_list\r\n        FROM recipient_lists\r\n        WHERE id = v_rule.recipient_list_id;\r\n\r\n        IF NOT FOUND THEN\r\n            CONTINUE;\r\n        END IF;\r\n\r\n        -- Handle different recipient list types\r\n        IF v_recipient_list.type = 'role_based' THEN\r\n            -- Role-based recipient list\r\n            SELECT ARRAY(SELECT jsonb_array_elements_text(v_recipient_list.config->'roles'))\r\n            INTO v_roles;\r\n\r\n            -- Build dynamic query based on event type's email preference column\r\n            FOR v_recipient IN EXECUTE format(\r\n                'SELECT DISTINCT p.email, p.id as user_id, p.first_name, p.last_name\r\n                 FROM profiles p\r\n                 WHERE p.role = ANY($1)\r\n                 AND p.email IS NOT NULL\r\n                 AND (p.%I = true OR p.%I IS NULL)',\r\n                v_email_pref_column, v_email_pref_column\r\n            ) USING v_roles\r\n            LOOP\r\n                INSERT INTO email_queue (\r\n                    to_email,\r\n                    to_user_id,\r\n                    template_id,\r\n                    event_type,\r\n                    event_id,\r\n                    event_payload,\r\n                    recipient_list_id,\r\n                    status,\r\n                    priority,\r\n                    created_at\r\n                )\r\n                VALUES (\r\n                    v_recipient.email,\r\n                    v_recipient.user_id,\r\n                    v_rule.template_id,\r\n                    v_event_type,\r\n                    NEW.id::text,\r\n                    v_event_payload || jsonb_build_object(\r\n                        'recipient_first_name', v_recipient.first_name,\r\n                        'recipient_last_name', v_recipient.last_name\r\n                    ),\r\n                    v_rule.recipient_list_id::text,\r\n                    'queued',\r\n                    v_rule.priority,\r\n                    NOW()\r\n                );\r\n            END LOOP;\r\n\r\n        ELSIF v_recipient_list.type = 'static' THEN\r\n            -- Static recipient list - emails stored in config.emails array\r\n            -- For static lists, we send regardless of email preferences (admin override)\r\n            IF v_recipient_list.config ? 'emails' THEN\r\n                FOR v_static_email IN\r\n                    SELECT jsonb_array_elements_text(v_recipient_list.config->'emails')\r\n                LOOP\r\n                    -- Try to get user info if they exist\r\n                    SELECT p.id, p.first_name, p.last_name, p.email\r\n                    INTO v_recipient\r\n                    FROM profiles p\r\n                    WHERE p.email = v_static_email;\r\n\r\n                    IF FOUND THEN\r\n                        INSERT INTO email_queue (\r\n                            to_email,\r\n                            to_user_id,\r\n                            template_id,\r\n                            event_type,\r\n                            event_id,\r\n                            event_payload,\r\n                            recipient_list_id,\r\n                            status,\r\n                            priority,\r\n                            created_at\r\n                        )\r\n                        VALUES (\r\n                            v_recipient.email,\r\n                            v_recipient.id,\r\n                            v_rule.template_id,\r\n                            v_event_type,\r\n                            NEW.id::text,\r\n                            v_event_payload || jsonb_build_object(\r\n                                'recipient_first_name', v_recipient.first_name,\r\n                                'recipient_last_name', v_recipient.last_name\r\n                            ),\r\n                            v_rule.recipient_list_id::text,\r\n                            'queued',\r\n                            v_rule.priority,\r\n                            NOW()\r\n                        );\r\n                    ELSE\r\n                        INSERT INTO email_queue (\r\n                            to_email,\r\n                            to_user_id,\r\n                            template_id,\r\n                            event_type,\r\n                            event_id,\r\n                            event_payload,\r\n                            recipient_list_id,\r\n                            status,\r\n                            priority,\r\n                            created_at\r\n                        )\r\n                        VALUES (\r\n                            v_static_email,\r\n                            NULL,\r\n                            v_rule.template_id,\r\n                            v_event_type,\r\n                            NEW.id::text,\r\n                            v_event_payload,\r\n                            v_rule.recipient_list_id::text,\r\n                            'queued',\r\n                            v_rule.priority,\r\n                            NOW()\r\n                        );\r\n                    END IF;\r\n                END LOOP;\r\n            END IF;\r\n\r\n        ELSIF v_recipient_list.type = 'dynamic' THEN\r\n            -- Dynamic recipient list - extract email from event payload\r\n            IF v_recipient_list.config ? 'source' THEN\r\n                DECLARE\r\n                    v_source_path text;\r\n                BEGIN\r\n                    v_source_path := v_recipient_list.config->>'source';\r\n\r\n                    IF v_source_path LIKE 'event.%' THEN\r\n                        v_source_path := substring(v_source_path from 7);\r\n                        v_dynamic_email := v_event_payload->>v_source_path;\r\n\r\n                        IF v_dynamic_email IS NOT NULL AND v_dynamic_email != '' THEN\r\n                            SELECT p.id, p.first_name, p.last_name, p.email\r\n                            INTO v_recipient\r\n                            FROM profiles p\r\n                            WHERE p.email = v_dynamic_email;\r\n\r\n                            IF FOUND THEN\r\n                                INSERT INTO email_queue (\r\n                                    to_email,\r\n                                    to_user_id,\r\n                                    template_id,\r\n                                    event_type,\r\n                                    event_id,\r\n                                    event_payload,\r\n                                    recipient_list_id,\r\n                                    status,\r\n                                    priority,\r\n                                    created_at\r\n                                )\r\n                                VALUES (\r\n                                    v_recipient.email,\r\n                                    v_recipient.id,\r\n                                    v_rule.template_id,\r\n                                    v_event_type,\r\n                                    NEW.id::text,\r\n                                    v_event_payload || jsonb_build_object(\r\n                                        'recipient_first_name', v_recipient.first_name,\r\n                                        'recipient_last_name', v_recipient.last_name\r\n                                    ),\r\n                                    v_rule.recipient_list_id::text,\r\n                                    'queued',\r\n                                    v_rule.priority,\r\n                                    NOW()\r\n                                );\r\n                            ELSE\r\n                                INSERT INTO email_queue (\r\n                                    to_email,\r\n                                    to_user_id,\r\n                                    template_id,\r\n                                    event_type,\r\n                                    event_id,\r\n                                    event_payload,\r\n                                    recipient_list_id,\r\n                                    status,\r\n                                    priority,\r\n                                    created_at\r\n                                )\r\n                                VALUES (\r\n                                    v_dynamic_email,\r\n                                    NULL,\r\n                                    v_rule.template_id,\r\n                                    v_event_type,\r\n                                    NEW.id::text,\r\n                                    v_event_payload || jsonb_build_object(\r\n                                        'recipient_first_name', COALESCE(v_event_payload->>'referee_first_name', ''),\r\n                                        'recipient_last_name', COALESCE(v_event_payload->>'referee_last_name', '')\r\n                                    ),\r\n                                    v_rule.recipient_list_id::text,\r\n                                    'queued',\r\n                                    v_rule.priority,\r\n                                    NOW()\r\n                                );\r\n                            END IF;\r\n                        END IF;\r\n                    END IF;\r\n                END;\r\n            END IF;\r\n\r\n        ELSIF v_recipient_list.type = 'custom' THEN\r\n            CONTINUE;\r\n        END IF;\r\n    END LOOP;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_email_notification_status",
    "arguments": "p_batch_id uuid, p_user_id text, p_email text, p_status text, p_resend_id text, p_error_message text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_email_notification_status(p_batch_id uuid, p_user_id text, p_email text, p_status text, p_resend_id text DEFAULT NULL::text, p_error_message text DEFAULT NULL::text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- For now, just log that we processed this recipient\r\n    -- In production, you'd want to track individual recipient status\r\n    IF p_status = 'failed' THEN\r\n        UPDATE email_notification_batches\r\n        SET error_message = COALESCE(error_message || '; ', '') || p_email || ': ' || COALESCE(p_error_message, 'Failed')\r\n        WHERE id = p_batch_id;\r\n    END IF;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_email_notification_status",
    "arguments": "p_batch_id uuid, p_status text, p_emails_sent integer, p_emails_failed integer",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_email_notification_status(p_batch_id uuid, p_status text, p_emails_sent integer DEFAULT 0, p_emails_failed integer DEFAULT 0)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    UPDATE email_notification_batches\r\n    SET\r\n        status = p_status,\r\n        processed_at = CASE WHEN p_status IN ('sent', 'completed', 'failed') THEN NOW() ELSE processed_at END,\r\n        error_message = CASE WHEN p_status = 'failed' THEN 'Processing failed' ELSE NULL END\r\n    WHERE id = p_batch_id;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_email_notification_status",
    "arguments": "p_batch_id uuid, p_user_id uuid, p_email text, p_status text, p_resend_id text, p_error_message text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_email_notification_status(p_batch_id uuid, p_user_id uuid, p_email text, p_status text, p_resend_id text DEFAULT NULL::text, p_error_message text DEFAULT NULL::text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  -- Log the email status (you could create a separate table for this)\r\n  -- For now, just update the batch counts\r\n  IF p_status = 'sent' THEN\r\n    UPDATE portal.email_notification_batches\r\n    SET emails_sent = emails_sent + 1\r\n    WHERE id = p_batch_id;\r\n  ELSIF p_status = 'failed' THEN\r\n    UPDATE portal.email_notification_batches\r\n    SET\r\n      emails_failed = emails_failed + 1,\r\n      error_message = COALESCE(error_message || '; ', '') || p_error_message\r\n    WHERE id = p_batch_id;\r\n  END IF;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_notification_status",
    "arguments": "p_notification_id uuid, p_status text, p_error_message text, p_email_provider_id text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_notification_status(p_notification_id uuid, p_status text, p_error_message text DEFAULT NULL::text, p_email_provider_id text DEFAULT NULL::text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_current_error_count INTEGER;\r\n  v_max_retries INTEGER;\r\nBEGIN\r\n  -- Get current error count and max retries\r\n  SELECT error_count, max_retries\r\n  INTO v_current_error_count, v_max_retries\r\n  FROM public.email_notifications\r\n  WHERE id = p_notification_id;\r\n\r\n  -- Update notification based on status\r\n  IF p_status = 'sent' THEN\r\n    UPDATE public.email_notifications\r\n    SET\r\n      status = 'sent',\r\n      sent_at = NOW(),\r\n      email_provider_id = p_email_provider_id,\r\n      updated_at = NOW()\r\n    WHERE id = p_notification_id;\r\n\r\n    -- Log success\r\n    INSERT INTO public.notification_logs (notification_id, event_type, details)\r\n    VALUES (p_notification_id, 'sent', jsonb_build_object('provider_id', p_email_provider_id));\r\n\r\n  ELSIF p_status = 'failed' THEN\r\n    UPDATE public.email_notifications\r\n    SET\r\n      status = CASE\r\n        WHEN v_current_error_count + 1 >= v_max_retries THEN 'failed'\r\n        ELSE 'failed'\r\n      END,\r\n      failed_at = CASE\r\n        WHEN v_current_error_count + 1 >= v_max_retries THEN NOW()\r\n        ELSE failed_at\r\n      END,\r\n      error_message = p_error_message,\r\n      error_count = error_count + 1,\r\n      retry_after = CASE\r\n        WHEN v_current_error_count + 1 < v_max_retries\r\n        THEN NOW() + (interval '1 minute' * power(2, v_current_error_count + 1))  -- Exponential backoff\r\n        ELSE NULL\r\n      END,\r\n      updated_at = NOW()\r\n    WHERE id = p_notification_id;\r\n\r\n    -- Log failure\r\n    INSERT INTO public.notification_logs (notification_id, event_type, details)\r\n    VALUES (\r\n      p_notification_id,\r\n      CASE\r\n        WHEN v_current_error_count + 1 >= v_max_retries THEN 'failed'\r\n        ELSE 'retried'\r\n      END,\r\n      jsonb_build_object(\r\n        'error', p_error_message,\r\n        'attempt', v_current_error_count + 1,\r\n        'max_retries', v_max_retries\r\n      )\r\n    );\r\n  END IF;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "check_referral_deletion_eligibility",
    "arguments": "p_referral_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.check_referral_deletion_eligibility(p_referral_id uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_referral RECORD;\r\n  v_issues TEXT[] := ARRAY[]::TEXT[];\r\n  v_related_data JSONB := '{}'::jsonb;\r\n  v_portal_user_exists BOOLEAN := false;\r\n  v_app_user_exists BOOLEAN := false;\r\nBEGIN\r\n  -- Get referral details\r\n  SELECT * INTO v_referral\r\n  FROM public.portal_referrals\r\n  WHERE id = p_referral_id;\r\n\r\n  IF NOT FOUND THEN\r\n    RETURN json_build_object(\r\n      'eligible', false,\r\n      'reason', 'Referral not found',\r\n      'referral_id', p_referral_id\r\n    );\r\n  END IF;\r\n\r\n  -- Check referral status\r\n  IF v_referral.status IN ('registered', 'completed') THEN\r\n    v_issues := array_append(v_issues, 'User has already registered (status: ' || v_referral.status || ')');\r\n  END IF;\r\n\r\n  -- Check for conversion record\r\n  IF EXISTS (\r\n    SELECT 1 FROM public.portal_referral_conversions\r\n    WHERE referral_id = p_referral_id\r\n  ) THEN\r\n    v_issues := array_append(v_issues, 'Conversion record exists');\r\n  END IF;\r\n\r\n  -- Check if user exists as a PORTAL user (this should block deletion)\r\n  SELECT EXISTS (\r\n    SELECT 1 FROM public.profiles\r\n    WHERE LOWER(email) = LOWER(v_referral.referee_email)\r\n    AND role IN ('super_admin', 'admin', 'portal_member', 'investor')  -- Only portal roles\r\n  ) INTO v_portal_user_exists;\r\n\r\n  -- Check if user exists as an APP user (this should NOT block deletion)\r\n  SELECT EXISTS (\r\n    SELECT 1 FROM public.profiles\r\n    WHERE LOWER(email) = LOWER(v_referral.referee_email)\r\n    AND role = 'user'  -- App user role\r\n  ) INTO v_app_user_exists;\r\n\r\n  IF v_portal_user_exists THEN\r\n    v_issues := array_append(v_issues, 'User is already a member of the PORTAL with email: ' || v_referral.referee_email);\r\n  END IF;\r\n\r\n  -- Gather related data that would be deleted\r\n  v_related_data := jsonb_build_object(\r\n    'contacts', (\r\n      SELECT COUNT(*) FROM public.contacts\r\n      WHERE referral_id = p_referral_id\r\n    ),\r\n    'pending_emails', (\r\n      SELECT COUNT(*) FROM public.email_notifications\r\n      WHERE metadata->>'referral_id' = p_referral_id::text\r\n      AND status IN ('pending', 'failed')\r\n    ),\r\n    'rate_limits', (\r\n      SELECT COUNT(*) FROM public.portal_referral_rate_limits\r\n      WHERE referral_id = p_referral_id\r\n    ),\r\n    'is_app_user', v_app_user_exists,\r\n    'is_portal_user', v_portal_user_exists,\r\n    'note', CASE\r\n      WHEN v_app_user_exists AND NOT v_portal_user_exists\r\n      THEN 'User exists in main app but not portal - OK to refer to portal'\r\n      WHEN v_portal_user_exists\r\n      THEN 'User already has portal access - cannot refer'\r\n      ELSE 'User does not exist in either system - OK to refer'\r\n    END\r\n  );\r\n\r\n  -- Return eligibility status\r\n  IF array_length(v_issues, 1) > 0 THEN\r\n    RETURN json_build_object(\r\n      'eligible', false,\r\n      'reasons', v_issues,\r\n      'referral', row_to_json(v_referral),\r\n      'related_data', v_related_data\r\n    );\r\n  ELSE\r\n    RETURN json_build_object(\r\n      'eligible', true,\r\n      'referral', row_to_json(v_referral),\r\n      'related_data', v_related_data,\r\n      'message', 'Referral is eligible for deletion'\r\n    );\r\n  END IF;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "check_referral_rate_limit",
    "arguments": "p_user_id uuid, p_action_type text, p_referral_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.check_referral_rate_limit(p_user_id uuid, p_action_type text, p_referral_id uuid DEFAULT NULL::uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n    action_count INTEGER;\r\n    max_allowed INTEGER;\r\n    time_window INTERVAL;\r\n    user_role TEXT;\r\nBEGIN\r\n    -- Check if user is super_admin - they are exempt from rate limits\r\n    SELECT role INTO user_role\r\n    FROM profiles\r\n    WHERE id = p_user_id;\r\n\r\n    IF user_role = 'super_admin' THEN\r\n        RETURN TRUE; -- Super admins bypass all rate limits\r\n    END IF;\r\n\r\n    -- Set limits based on action type\r\n    IF p_action_type = 'create_referral' THEN\r\n        max_allowed := 10;\r\n        time_window := INTERVAL '1 day';\r\n    ELSIF p_action_type = 'resend_invitation' THEN\r\n        max_allowed := 3;\r\n        time_window := INTERVAL '1 day';\r\n\r\n        -- For resend, check per referral\r\n        IF p_referral_id IS NOT NULL THEN\r\n            SELECT COUNT(*) INTO action_count\r\n            FROM public.portal_referral_rate_limits\r\n            WHERE referral_id = p_referral_id\r\n                AND action_type = p_action_type\r\n                AND action_timestamp > NOW() - time_window;\r\n\r\n            RETURN action_count < max_allowed;\r\n        END IF;\r\n    ELSE\r\n        RETURN FALSE;\r\n    END IF;\r\n\r\n    -- Check user's action count\r\n    SELECT COUNT(*) INTO action_count\r\n    FROM public.portal_referral_rate_limits\r\n    WHERE user_id = p_user_id\r\n        AND action_type = p_action_type\r\n        AND action_timestamp > NOW() - time_window;\r\n\r\n    RETURN action_count < max_allowed;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "complete_referral_onboarding",
    "arguments": "p_user_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.complete_referral_onboarding(p_user_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n    v_conversion_id UUID;\r\n    v_referral_id UUID;\r\nBEGIN\r\n    -- Find conversion record\r\n    SELECT id, referral_id\r\n    INTO v_conversion_id, v_referral_id\r\n    FROM public.portal_referral_conversions\r\n    WHERE referee_profile_id = p_user_id\r\n    AND onboarding_completed_at IS NULL;\r\n\r\n    IF v_conversion_id IS NULL THEN\r\n        RETURN false;\r\n    END IF;\r\n\r\n    -- Update conversion record\r\n    UPDATE public.portal_referral_conversions\r\n    SET\r\n        onboarding_completed_at = NOW(),\r\n        updated_at = NOW()\r\n    WHERE id = v_conversion_id;\r\n\r\n    -- Update referral status\r\n    UPDATE public.portal_referrals\r\n    SET\r\n        status = 'completed',\r\n        updated_at = NOW()\r\n    WHERE id = v_referral_id;\r\n\r\n    -- Update contact status\r\n    UPDATE public.contacts\r\n    SET\r\n        status = 'Active Member',\r\n        updated_at = NOW()\r\n    WHERE referral_id = v_referral_id;\r\n\r\n    RETURN true;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "create_referral",
    "arguments": "p_referrer_id uuid, p_referee_first_name text, p_referee_last_name text, p_referee_email text, p_referee_phone text, p_dsp_name text, p_dsp_code text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_referral(p_referrer_id uuid, p_referee_first_name text, p_referee_last_name text, p_referee_email text, p_referee_phone text DEFAULT NULL::text, p_dsp_name text DEFAULT NULL::text, p_dsp_code text DEFAULT NULL::text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n    v_referral_id UUID;\r\n    v_referral_code TEXT;\r\n    v_contact_id UUID;\r\n    v_can_proceed BOOLEAN;\r\nBEGIN\r\n    -- Validate user is authenticated\r\n    IF auth.uid() IS NULL OR auth.uid() != p_referrer_id THEN\r\n        RAISE EXCEPTION 'Unauthorized';\r\n    END IF;\r\n\r\n    -- Check rate limiting\r\n    SELECT check_referral_rate_limit(p_referrer_id, 'create_referral') INTO v_can_proceed;\r\n\r\n    IF NOT v_can_proceed THEN\r\n        RAISE EXCEPTION 'Rate limit exceeded. Maximum 10 referrals per day.';\r\n    END IF;\r\n\r\n    -- Check if referral already exists\r\n    IF EXISTS (\r\n        SELECT 1 FROM public.portal_referrals\r\n        WHERE referrer_id = p_referrer_id\r\n        AND LOWER(referee_email) = LOWER(p_referee_email)\r\n    ) THEN\r\n        RAISE EXCEPTION 'You have already sent a referral to this email address';\r\n    END IF;\r\n\r\n    -- Generate unique referral code\r\n    SELECT generate_referral_code() INTO v_referral_code;\r\n\r\n    -- Create the referral\r\n    INSERT INTO public.portal_referrals (\r\n        referrer_id,\r\n        referee_first_name,\r\n        referee_last_name,\r\n        referee_email,\r\n        referee_phone,\r\n        dsp_name,\r\n        dsp_code,\r\n        referral_code,\r\n        status\r\n    ) VALUES (\r\n        p_referrer_id,\r\n        p_referee_first_name,\r\n        p_referee_last_name,\r\n        LOWER(p_referee_email),\r\n        p_referee_phone,\r\n        p_dsp_name,\r\n        p_dsp_code,\r\n        v_referral_code,\r\n        'pending'\r\n    )\r\n    RETURNING id INTO v_referral_id;\r\n\r\n    -- Record rate limit action\r\n    PERFORM record_rate_limit_action(p_referrer_id, 'create_referral');\r\n\r\n    -- Create contact record (using correct column structure)\r\n    -- Note: contacts table doesn't have source, status, or referral_id columns\r\n    -- and uses dsp_id (foreign key) not dsp_name (text)\r\n    -- We'll store basic contact info and track referral via referred_by_text\r\n    INSERT INTO public.contacts (\r\n        first_name,\r\n        last_name,\r\n        email,\r\n        phone,\r\n        referred_by_text,\r\n        contact_status,\r\n        notes\r\n    ) VALUES (\r\n        p_referee_first_name,\r\n        p_referee_last_name,\r\n        LOWER(p_referee_email),\r\n        p_referee_phone,\r\n        'Portal Referral Code: ' || v_referral_code,\r\n        'new',\r\n        'Created via portal referral from user ' || p_referrer_id::TEXT ||\r\n        CASE WHEN p_dsp_name IS NOT NULL THEN ' - DSP: ' || p_dsp_name ELSE '' END\r\n    )\r\n    RETURNING id INTO v_contact_id;\r\n\r\n    -- Return the created referral details\r\n    RETURN json_build_object(\r\n        'referral_id', v_referral_id,\r\n        'referral_code', v_referral_code,\r\n        'contact_id', v_contact_id,\r\n        'success', true\r\n    );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "delete_referral_admin",
    "arguments": "p_referral_id uuid, p_deletion_reason text, p_admin_note text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.delete_referral_admin(p_referral_id uuid, p_deletion_reason text DEFAULT NULL::text, p_admin_note text DEFAULT NULL::text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_referral RECORD;\r\n  v_user_role TEXT;\r\n  v_admin_id UUID;\r\n  v_user_email TEXT;\r\nBEGIN\r\n  -- Get the calling user's ID and details\r\n  v_admin_id := auth.uid();\r\n\r\n  -- Get user details for debugging\r\n  SELECT role, email INTO v_user_role, v_user_email\r\n  FROM public.profiles\r\n  WHERE id = v_admin_id;\r\n\r\n  -- Better error message with actual values\r\n  IF v_user_role IS NULL THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'User profile not found. Your ID: ' || COALESCE(v_admin_id::text, 'NULL')\r\n    );\r\n  END IF;\r\n\r\n  -- Check admin permissions with detailed error\r\n  IF v_user_role NOT IN ('admin', 'super_admin') THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'Insufficient permissions. Your role: ' || v_user_role || ' (email: ' || v_user_email || '). Required: admin or super_admin.'\r\n    );\r\n  END IF;\r\n\r\n  -- Get referral details\r\n  SELECT * INTO v_referral\r\n  FROM public.portal_referrals\r\n  WHERE id = p_referral_id;\r\n\r\n  IF NOT FOUND THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'Referral not found with ID: ' || p_referral_id\r\n    );\r\n  END IF;\r\n\r\n  -- Critical check: Prevent deletion of registered users\r\n  IF v_referral.status IN ('registered', 'completed') THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'Cannot delete referral: User has already registered (status: ' || v_referral.status || ')'\r\n    );\r\n  END IF;\r\n\r\n  -- Check if there's a conversion record\r\n  IF EXISTS (\r\n    SELECT 1 FROM public.portal_referral_conversions\r\n    WHERE referral_id = p_referral_id\r\n  ) THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'Cannot delete referral: Conversion record exists'\r\n    );\r\n  END IF;\r\n\r\n  -- Check if user exists with this email (regardless of portal status for now)\r\n  IF EXISTS (\r\n    SELECT 1 FROM public.profiles\r\n    WHERE LOWER(email) = LOWER(v_referral.referee_email)\r\n  ) THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'Cannot delete referral: User account exists with this email: ' || v_referral.referee_email\r\n    );\r\n  END IF;\r\n\r\n  -- For now, just return success without actually deleting (for testing)\r\n  RETURN json_build_object(\r\n    'success', true,\r\n    'message', 'TEST MODE: Would delete referral for ' || v_referral.referee_email,\r\n    'debug_info', jsonb_build_object(\r\n      'admin_id', v_admin_id,\r\n      'admin_email', v_user_email,\r\n      'admin_role', v_user_role,\r\n      'referral_id', p_referral_id,\r\n      'referee_email', v_referral.referee_email,\r\n      'referral_status', v_referral.status\r\n    )\r\n  );\r\n\r\nEXCEPTION\r\n  WHEN OTHERS THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'Unexpected error: ' || SQLERRM || ' (Admin: ' || COALESCE(v_user_email, 'unknown') || ', Role: ' || COALESCE(v_user_role, 'unknown') || ')'\r\n    );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "delete_referral_admin_fixed",
    "arguments": "p_referral_id uuid, p_admin_user_id uuid, p_deletion_reason text, p_admin_note text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.delete_referral_admin_fixed(p_referral_id uuid, p_admin_user_id uuid, p_deletion_reason text DEFAULT NULL::text, p_admin_note text DEFAULT NULL::text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_referral RECORD;\r\n  v_user_role TEXT;\r\n  v_user_email TEXT;\r\nBEGIN\r\n  -- Get admin user details using the passed ID\r\n  SELECT role, email INTO v_user_role, v_user_email\r\n  FROM public.profiles\r\n  WHERE id = p_admin_user_id;\r\n\r\n  -- Check if admin user exists\r\n  IF v_user_role IS NULL THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'Admin user not found with ID: ' || p_admin_user_id\r\n    );\r\n  END IF;\r\n\r\n  -- Check admin permissions (only portal admin roles)\r\n  IF v_user_role NOT IN ('admin', 'super_admin') THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'Insufficient permissions. Your role: ' || v_user_role || ' (email: ' || v_user_email || '). Required: admin or super_admin.'\r\n    );\r\n  END IF;\r\n\r\n  -- Get referral details\r\n  SELECT * INTO v_referral\r\n  FROM public.portal_referrals\r\n  WHERE id = p_referral_id;\r\n\r\n  IF NOT FOUND THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'Referral not found with ID: ' || p_referral_id\r\n    );\r\n  END IF;\r\n\r\n  -- Check if user has registered for the portal\r\n  IF v_referral.status IN ('registered', 'completed') THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'Cannot delete referral: User has already registered for the portal (status: ' || v_referral.status || ')'\r\n    );\r\n  END IF;\r\n\r\n  -- Check for conversion record\r\n  IF EXISTS (\r\n    SELECT 1 FROM public.portal_referral_conversions\r\n    WHERE referral_id = p_referral_id\r\n  ) THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'Cannot delete referral: Portal conversion record exists'\r\n    );\r\n  END IF;\r\n\r\n  -- IMPORTANT: Only check if user exists as a PORTAL user, not app user\r\n  IF EXISTS (\r\n    SELECT 1 FROM public.profiles\r\n    WHERE LOWER(email) = LOWER(v_referral.referee_email)\r\n    AND role IN ('super_admin', 'admin', 'portal_member', 'investor')  -- Only portal roles\r\n  ) THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'Cannot delete referral: User already has portal access with this email: ' || v_referral.referee_email\r\n    );\r\n  END IF;\r\n\r\n  -- Actually delete the referral and related data\r\n\r\n  -- Delete contact records\r\n  DELETE FROM public.contacts\r\n  WHERE referral_id = p_referral_id;\r\n\r\n  -- Cancel pending email notifications\r\n  UPDATE public.email_notifications\r\n  SET status = 'cancelled',\r\n      metadata = metadata || jsonb_build_object(\r\n        'cancelled_reason', 'Referral deleted by admin',\r\n        'cancelled_at', NOW(),\r\n        'cancelled_by', p_admin_user_id\r\n      )\r\n  WHERE metadata->>'referral_id' = p_referral_id::text\r\n  AND status IN ('pending', 'failed');\r\n\r\n  -- Delete rate limit records\r\n  DELETE FROM public.portal_referral_rate_limits\r\n  WHERE referral_id = p_referral_id;\r\n\r\n  -- Delete the referral itself\r\n  DELETE FROM public.portal_referrals\r\n  WHERE id = p_referral_id;\r\n\r\n  -- REMOVED LOGGING FOR NOW - will fix in separate migration once we know the table structure\r\n\r\n  RETURN json_build_object(\r\n    'success', true,\r\n    'message', 'Referral successfully deleted',\r\n    'deleted', jsonb_build_object(\r\n      'referral_id', p_referral_id,\r\n      'referee_email', v_referral.referee_email,\r\n      'deleted_by', v_user_email\r\n    )\r\n  );\r\n\r\nEXCEPTION\r\n  WHEN OTHERS THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'Unexpected error: ' || SQLERRM\r\n    );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "generate_referral_code",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.generate_referral_code()\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    new_code TEXT;\r\n    code_exists BOOLEAN;\r\nBEGIN\r\n    LOOP\r\n        -- Generate a code with format: ref_<random_string>\r\n        new_code := 'ref_' || substr(md5(random()::text || clock_timestamp()::text), 1, 12);\r\n\r\n        -- Check if code already exists\r\n        SELECT EXISTS(SELECT 1 FROM public.portal_referrals WHERE referral_code = new_code) INTO code_exists;\r\n\r\n        -- Exit loop if code is unique\r\n        EXIT WHEN NOT code_exists;\r\n    END LOOP;\r\n\r\n    RETURN new_code;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_referral_by_code",
    "arguments": "p_code text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_referral_by_code(p_code text)\n RETURNS TABLE(referee_first_name text, referee_last_name text, referee_email text, referrer_name text, dsp_name text, status text)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT\r\n    pr.referee_first_name,\r\n    pr.referee_last_name,\r\n    pr.referee_email,\r\n    COALESCE(p.first_name || ' ' || p.last_name, 'A FleetDRMS Member') as referrer_name,\r\n    pr.dsp_name,\r\n    pr.status\r\n  FROM portal_referrals pr\r\n  LEFT JOIN profiles p ON pr.referrer_id = p.id\r\n  WHERE pr.referral_code = p_code\r\n    AND pr.status IN ('pending', 'sent')\r\n  LIMIT 1;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_user_referral_stats",
    "arguments": "p_user_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_user_referral_stats(p_user_id uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n    v_stats JSON;\r\nBEGIN\r\n    -- Validate user is authenticated\r\n    IF auth.uid() IS NULL OR auth.uid() != p_user_id THEN\r\n        RAISE EXCEPTION 'Unauthorized';\r\n    END IF;\r\n\r\n    SELECT json_build_object(\r\n        'total_referrals', COUNT(*),\r\n        'invitations_sent', COUNT(CASE WHEN status IN ('sent', 'registered', 'completed') THEN 1 END),\r\n        'registrations', COUNT(CASE WHEN status IN ('registered', 'completed') THEN 1 END),\r\n        'completed', COUNT(CASE WHEN status = 'completed' THEN 1 END),\r\n        'pending', COUNT(CASE WHEN status = 'pending' THEN 1 END),\r\n        'conversion_rate',\r\n            CASE\r\n                WHEN COUNT(CASE WHEN status IN ('sent', 'registered', 'completed') THEN 1 END) > 0\r\n                THEN ROUND(\r\n                    (COUNT(CASE WHEN status IN ('registered', 'completed') THEN 1 END)::NUMERIC /\r\n                     COUNT(CASE WHEN status IN ('sent', 'registered', 'completed') THEN 1 END)::NUMERIC) * 100,\r\n                    2\r\n                )\r\n                ELSE 0\r\n            END,\r\n        'this_month', COUNT(CASE WHEN created_at >= date_trunc('month', CURRENT_DATE) THEN 1 END),\r\n        'last_referral_date', MAX(created_at)\r\n    ) INTO v_stats\r\n    FROM public.portal_referrals\r\n    WHERE referrer_id = p_user_id;\r\n\r\n    RETURN v_stats;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_user_referrals",
    "arguments": "p_user_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_user_referrals(p_user_id uuid)\n RETURNS TABLE(id uuid, referee_first_name text, referee_last_name text, referee_email text, referee_phone text, dsp_name text, dsp_code text, referral_code text, status text, invitation_sent_at timestamp with time zone, last_resent_at timestamp with time zone, resend_count integer, registered_at timestamp with time zone, created_at timestamp with time zone, conversion_date timestamp with time zone, onboarding_completed boolean)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n    -- Validate user is authenticated\r\n    IF auth.uid() IS NULL OR auth.uid() != p_user_id THEN\r\n        RAISE EXCEPTION 'Unauthorized';\r\n    END IF;\r\n\r\n    RETURN QUERY\r\n    SELECT\r\n        r.id,\r\n        r.referee_first_name,\r\n        r.referee_last_name,\r\n        r.referee_email,\r\n        r.referee_phone,\r\n        r.dsp_name,\r\n        r.dsp_code,\r\n        r.referral_code,\r\n        r.status,\r\n        r.invitation_sent_at,\r\n        r.last_resent_at,\r\n        r.resend_count,\r\n        r.registered_at,\r\n        r.created_at,\r\n        rc.converted_at as conversion_date,\r\n        (rc.onboarding_completed_at IS NOT NULL) as onboarding_completed\r\n    FROM public.portal_referrals r\r\n    LEFT JOIN public.portal_referral_conversions rc ON rc.referral_id = r.id\r\n    WHERE r.referrer_id = p_user_id\r\n    ORDER BY r.created_at DESC;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "process_referral_registration",
    "arguments": "p_referral_code text, p_user_id uuid, p_user_email text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.process_referral_registration(p_referral_code text, p_user_id uuid, p_user_email text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n    v_referral_id UUID;\r\n    v_referrer_id UUID;\r\n    v_conversion_id UUID;\r\n    v_contact_id UUID;\r\nBEGIN\r\n    -- Find the referral by code and email\r\n    SELECT id, referrer_id\r\n    INTO v_referral_id, v_referrer_id\r\n    FROM public.portal_referrals\r\n    WHERE referral_code = p_referral_code\r\n    AND LOWER(referee_email) = LOWER(p_user_email)\r\n    AND status IN ('pending', 'sent');\r\n\r\n    IF v_referral_id IS NULL THEN\r\n        -- Not a valid referral, but don't error - just return\r\n        RETURN json_build_object(\r\n            'success', false,\r\n            'message', 'No matching referral found'\r\n        );\r\n    END IF;\r\n\r\n    -- Check if conversion already exists\r\n    IF EXISTS (\r\n        SELECT 1 FROM public.portal_referral_conversions\r\n        WHERE referral_id = v_referral_id\r\n    ) THEN\r\n        RETURN json_build_object(\r\n            'success', false,\r\n            'message', 'Referral already converted'\r\n        );\r\n    END IF;\r\n\r\n    -- Create conversion record\r\n    INSERT INTO public.portal_referral_conversions (\r\n        referral_id,\r\n        referee_profile_id,\r\n        converted_at\r\n    ) VALUES (\r\n        v_referral_id,\r\n        p_user_id,\r\n        NOW()\r\n    )\r\n    RETURNING id INTO v_conversion_id;\r\n\r\n    -- Update referral status\r\n    UPDATE public.portal_referrals\r\n    SET\r\n        status = 'registered',\r\n        registered_at = NOW(),\r\n        updated_at = NOW()\r\n    WHERE id = v_referral_id;\r\n\r\n    -- Update contact record if exists\r\n    UPDATE public.contacts\r\n    SET\r\n        is_portal_member = true,\r\n        portal_profile_id = p_user_id,\r\n        status = 'Registered',\r\n        updated_at = NOW()\r\n    WHERE referral_id = v_referral_id\r\n    RETURNING id INTO v_contact_id;\r\n\r\n    RETURN json_build_object(\r\n        'success', true,\r\n        'conversion_id', v_conversion_id,\r\n        'referrer_id', v_referrer_id,\r\n        'contact_updated', v_contact_id IS NOT NULL\r\n    );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "record_referral_conversion",
    "arguments": "p_referral_code text, p_user_id uuid, p_metadata jsonb",
    "function_definition": "CREATE OR REPLACE FUNCTION public.record_referral_conversion(p_referral_code text, p_user_id uuid, p_metadata jsonb DEFAULT NULL::jsonb)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_referral_id UUID;\r\n  v_is_reusable BOOLEAN;\r\n  v_max_uses INTEGER;\r\n  v_current_uses INTEGER;\r\nBEGIN\r\n  -- Get referral info\r\n  SELECT id, is_reusable, max_uses, usage_count\r\n  INTO v_referral_id, v_is_reusable, v_max_uses, v_current_uses\r\n  FROM portal_referrals\r\n  WHERE referral_code = p_referral_code;\r\n\r\n  IF v_referral_id IS NULL THEN\r\n    RAISE EXCEPTION 'Referral code not found: %', p_referral_code;\r\n  END IF;\r\n\r\n  -- Check if code is reusable and hasn't exceeded max uses\r\n  IF v_is_reusable THEN\r\n    IF v_max_uses IS NOT NULL AND v_current_uses >= v_max_uses THEN\r\n      RAISE EXCEPTION 'Referral code has exceeded maximum uses';\r\n    END IF;\r\n  END IF;\r\n\r\n  -- Record the conversion\r\n  INSERT INTO referral_conversions (\r\n    referral_id,\r\n    user_id,\r\n    converted_at,\r\n    conversion_metadata\r\n  ) VALUES (\r\n    v_referral_id,\r\n    p_user_id,\r\n    NOW(),\r\n    p_metadata\r\n  )\r\n  ON CONFLICT (referral_id, user_id) DO NOTHING; -- Prevent duplicate conversions\r\n\r\n  -- Increment usage count\r\n  UPDATE portal_referrals\r\n  SET usage_count = usage_count + 1\r\n  WHERE id = v_referral_id;\r\n\r\n  RETURN true;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "resend_referral_invitation",
    "arguments": "p_referral_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.resend_referral_invitation(p_referral_id uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n    v_referrer_id UUID;\r\n    v_can_proceed BOOLEAN;\r\n    v_current_resend_count INTEGER;\r\nBEGIN\r\n    -- Get referrer_id and validate ownership\r\n    SELECT referrer_id, resend_count\r\n    INTO v_referrer_id, v_current_resend_count\r\n    FROM public.portal_referrals\r\n    WHERE id = p_referral_id;\r\n\r\n    IF v_referrer_id IS NULL THEN\r\n        RAISE EXCEPTION 'Referral not found';\r\n    END IF;\r\n\r\n    IF auth.uid() IS NULL OR auth.uid() != v_referrer_id THEN\r\n        RAISE EXCEPTION 'Unauthorized';\r\n    END IF;\r\n\r\n    -- Check rate limiting for resend\r\n    SELECT check_referral_rate_limit(v_referrer_id, 'resend_invitation', p_referral_id) INTO v_can_proceed;\r\n\r\n    IF NOT v_can_proceed THEN\r\n        RAISE EXCEPTION 'Rate limit exceeded. Maximum 3 resends per referral per day.';\r\n    END IF;\r\n\r\n    -- Update referral with resend information\r\n    UPDATE public.portal_referrals\r\n    SET\r\n        last_resent_at = NOW(),\r\n        resend_count = v_current_resend_count + 1,\r\n        updated_at = NOW()\r\n    WHERE id = p_referral_id;\r\n\r\n    -- Record rate limit action\r\n    PERFORM record_rate_limit_action(v_referrer_id, 'resend_invitation', p_referral_id);\r\n\r\n    RETURN json_build_object(\r\n        'success', true,\r\n        'resend_count', v_current_resend_count + 1,\r\n        'resent_at', NOW()\r\n    );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_referral_on_registration",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_referral_on_registration()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  -- Check if this new profile was created via a referral\r\n  -- Look for matching email in portal_referrals (case-insensitive)\r\n  UPDATE portal_referrals\r\n  SET\r\n    status = 'registered',\r\n    registered_at = NEW.created_at\r\n  WHERE LOWER(referee_email) = LOWER(NEW.email)\r\n    AND status IN ('pending', 'sent')\r\n    AND registered_at IS NULL;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "validate_referral_eligibility",
    "arguments": "p_email text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.validate_referral_eligibility(p_email text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_profile RECORD;\r\nBEGIN\r\n  -- Check if email exists in profiles\r\n  SELECT\r\n    id,\r\n    email,\r\n    is_portal_user,\r\n    role\r\n  INTO v_profile\r\n  FROM public.profiles\r\n  WHERE LOWER(email) = LOWER(p_email);\r\n\r\n  IF v_profile.id IS NULL THEN\r\n    -- Email doesn't exist at all - OK to refer\r\n    RETURN json_build_object(\r\n      'eligible', true,\r\n      'message', 'Email is eligible for referral'\r\n    );\r\n  END IF;\r\n\r\n  -- Check if they're already a portal user\r\n  IF v_profile.is_portal_user = true THEN\r\n    RETURN json_build_object(\r\n      'eligible', false,\r\n      'reason', 'already_portal_user',\r\n      'message', 'This person already has access to the DSP Portal'\r\n    );\r\n  END IF;\r\n\r\n  -- They're an app user but not portal user - OK to refer\r\n  RETURN json_build_object(\r\n    'eligible', true,\r\n    'is_app_user', true,\r\n    'message', 'This person uses the Fleet DRMS app but not the portal - they can be referred'\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "delete_portal_user",
    "arguments": "p_user_id uuid, p_admin_id uuid, p_reason text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.delete_portal_user(p_user_id uuid, p_admin_id uuid, p_reason text DEFAULT NULL::text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_result JSON;\r\n  v_deleted_counts JSON;\r\nBEGIN\r\n  -- Verify admin permissions\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM profiles\r\n    WHERE id = p_admin_id\r\n    AND role IN ('super_admin', 'portal_admin')\r\n  ) THEN\r\n    RAISE EXCEPTION 'User % does not have admin permissions', p_admin_id;\r\n  END IF;\r\n\r\n  -- Verify user exists\r\n  IF NOT EXISTS (SELECT 1 FROM profiles WHERE id = p_user_id) THEN\r\n    RAISE EXCEPTION 'User % not found', p_user_id;\r\n  END IF;\r\n\r\n  -- Prevent self-deletion\r\n  IF p_user_id = p_admin_id THEN\r\n    RAISE EXCEPTION 'Cannot delete your own account';\r\n  END IF;\r\n\r\n  -- Count what will be deleted\r\n  SELECT json_build_object(\r\n    'businesses', (SELECT COUNT(*) FROM businesses WHERE user_id = p_user_id),\r\n    'survey_responses', (SELECT COUNT(*) FROM portal_survey_responses WHERE user_id = p_user_id),\r\n    'event_registrations', (SELECT COUNT(*) FROM portal_event_registrations WHERE user_id = p_user_id),\r\n    'referrals_made', (SELECT COUNT(*) FROM portal_referrals WHERE referrer_id = p_user_id),\r\n    'updates_created', (SELECT COUNT(*) FROM portal_updates WHERE created_by = p_user_id),\r\n    'surveys_created', (SELECT COUNT(*) FROM portal_surveys WHERE created_by = p_user_id),\r\n    'events_created', (SELECT COUNT(*) FROM portal_events WHERE created_by = p_user_id),\r\n    'marketing_conversions', (SELECT COUNT(*) FROM marketing_conversions WHERE user_id = p_user_id),\r\n    'portal_memberships', (SELECT COUNT(*) FROM portal_memberships WHERE user_id = p_user_id)\r\n  )\r\n  INTO v_deleted_counts;\r\n\r\n  -- Delete the user (CASCADE will handle related data)\r\n  DELETE FROM profiles WHERE id = p_user_id;\r\n\r\n  -- Return success result\r\n  RETURN json_build_object(\r\n    'success', true,\r\n    'deleted_user_id', p_user_id,\r\n    'deleted_by', p_admin_id,\r\n    'reason', p_reason,\r\n    'deleted_at', NOW(),\r\n    'deleted_data', v_deleted_counts\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_portal_admin_stats",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_portal_admin_stats()\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  result JSON;\r\nBEGIN\r\n  result := json_build_object(\r\n    'updates', (\r\n      SELECT json_build_object(\r\n        'total', COALESCE(COUNT(*), 0)::INTEGER,\r\n        'published', COALESCE(COUNT(*) FILTER (WHERE status = 'published'), 0)::INTEGER,\r\n        'draft', COALESCE(COUNT(*) FILTER (WHERE status = 'draft'), 0)::INTEGER,\r\n        'recent', COALESCE(\r\n          (SELECT json_agg(row_to_json(r))\r\n           FROM (\r\n             SELECT id, title, status, created_at\r\n             FROM portal_updates\r\n             ORDER BY created_at DESC\r\n             LIMIT 5\r\n           ) r\r\n          ), '[]'::json\r\n        )\r\n      )\r\n      FROM portal_updates\r\n    ),\r\n    'surveys', (\r\n      SELECT json_build_object(\r\n        'total', COALESCE(COUNT(*), 0)::INTEGER,\r\n        'active', COALESCE(COUNT(*) FILTER (WHERE status = 'published'), 0)::INTEGER,\r\n        'total_responses', COALESCE((\r\n          SELECT COUNT(*)::INTEGER FROM portal_survey_responses\r\n        ), 0),\r\n        'completed_responses', COALESCE((\r\n          SELECT COUNT(*)::INTEGER FROM portal_survey_responses WHERE is_complete = true\r\n        ), 0),\r\n        'recent', COALESCE(\r\n          (SELECT json_agg(row_to_json(r))\r\n           FROM (\r\n             SELECT \r\n               id, \r\n               title, \r\n               CASE WHEN status = 'published' THEN true ELSE false END as is_active,\r\n               created_at\r\n             FROM portal_surveys\r\n             ORDER BY created_at DESC\r\n             LIMIT 5\r\n           ) r\r\n          ), '[]'::json\r\n        )\r\n      )\r\n      FROM portal_surveys\r\n    ),\r\n    'events', COALESCE((\r\n      SELECT json_build_object(\r\n        'total', COUNT(*)::INTEGER,\r\n        'upcoming', COUNT(*) FILTER (WHERE start_datetime > NOW())::INTEGER,\r\n        'total_registrations', COALESCE((\r\n          SELECT COUNT(*)::INTEGER FROM portal_event_registrations\r\n        ), 0),\r\n        'recent', COALESCE(\r\n          (SELECT json_agg(row_to_json(r))\r\n           FROM (\r\n             SELECT \r\n               id, \r\n               title, \r\n               event_type,\r\n               start_datetime,\r\n               CASE \r\n                 WHEN start_datetime > NOW() THEN 'upcoming'\r\n                 WHEN end_datetime > NOW() THEN 'ongoing'\r\n                 ELSE 'past'\r\n               END as status\r\n             FROM portal_events\r\n             ORDER BY created_at DESC\r\n             LIMIT 5\r\n           ) r\r\n          ), '[]'::json\r\n        )\r\n      )\r\n      FROM portal_events\r\n    ), json_build_object(\r\n      'total', 0,\r\n      'upcoming', 0,\r\n      'total_registrations', 0,\r\n      'recent', '[]'::json\r\n    )),\r\n    'users', json_build_object(\r\n      'total_portal_users', COALESCE((\r\n        SELECT COUNT(DISTINCT id)::INTEGER \r\n        FROM profiles \r\n        WHERE role IN ('portal_member', 'pilotowner', 'investor', 'user', 'super_admin', 'admin')\r\n      ), 0),\r\n      'active_today', COALESCE((\r\n        SELECT COUNT(DISTINCT user_id)::INTEGER\r\n        FROM portal_survey_responses \r\n        WHERE started_at > NOW() - INTERVAL '24 hours'\r\n      ), 0)\r\n    )\r\n  );\r\n  \r\n  RETURN result;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_portal_user_stats",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_portal_user_stats()\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  RETURN json_build_object(\r\n    'total', (\r\n      SELECT COUNT(DISTINCT p.id) \r\n      FROM public.profiles p\r\n      LEFT JOIN public.user_roles ur ON ur.user_id = p.id\r\n      WHERE \r\n        p.role::text IN ('super_admin', 'admin', 'portal_member', 'investor')\r\n        OR (ur.role IS NOT NULL AND ur.role::text IN ('super_admin', 'admin', 'portal_member', 'investor'))\r\n    ),\r\n    'breakdown', json_build_object(\r\n      'super_admin', (\r\n        SELECT COUNT(DISTINCT p.id) \r\n        FROM public.profiles p\r\n        LEFT JOIN public.user_roles ur ON ur.user_id = p.id\r\n        WHERE p.role::text = 'super_admin' \r\n           OR (ur.role IS NOT NULL AND ur.role::text = 'super_admin')\r\n      ),\r\n      'admin', (\r\n        SELECT COUNT(DISTINCT p.id) \r\n        FROM public.profiles p\r\n        LEFT JOIN public.user_roles ur ON ur.user_id = p.id\r\n        WHERE p.role::text = 'admin' OR (ur.role IS NOT NULL AND ur.role::text = 'admin')\r\n      ),\r\n      'portal_member', (\r\n        SELECT COUNT(DISTINCT p.id) \r\n        FROM public.profiles p\r\n        LEFT JOIN public.user_roles ur ON ur.user_id = p.id\r\n        WHERE p.role::text = 'portal_member' OR (ur.role IS NOT NULL AND ur.role::text = 'portal_member')\r\n      ),\r\n      'investor', (\r\n        SELECT COUNT(DISTINCT p.id) \r\n        FROM public.profiles p\r\n        LEFT JOIN public.user_roles ur ON ur.user_id = p.id\r\n        WHERE p.role::text = 'investor' OR (ur.role IS NOT NULL AND ur.role::text = 'investor')\r\n      )\r\n    ),\r\n    'other_users', (\r\n      SELECT COUNT(*) \r\n      FROM public.profiles p\r\n      LEFT JOIN public.user_roles ur ON ur.user_id = p.id\r\n      WHERE \r\n        (p.role IS NULL OR p.role::text NOT IN ('super_admin', 'admin', 'portal_member', 'investor'))\r\n        AND (ur.role IS NULL OR ur.role::text NOT IN ('super_admin', 'admin', 'portal_member', 'investor'))\r\n    )\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "has_portal_role",
    "arguments": "p_user_id uuid, p_roles text[]",
    "function_definition": "CREATE OR REPLACE FUNCTION public.has_portal_role(p_user_id uuid, p_roles text[] DEFAULT NULL::text[])\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  IF p_roles IS NULL OR array_length(p_roles, 1) IS NULL THEN\r\n    RETURN EXISTS (\r\n      SELECT 1 FROM public.portal_memberships\r\n      WHERE user_id = p_user_id AND is_active = true\r\n    );\r\n  ELSE\r\n    RETURN EXISTS (\r\n      SELECT 1 FROM public.portal_memberships\r\n      WHERE user_id = p_user_id \r\n      AND portal_role = ANY(p_roles)\r\n      AND is_active = true\r\n    );\r\n  END IF;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "is_portal_admin",
    "arguments": "user_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_portal_admin(user_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_role TEXT;\r\n  v_is_admin BOOLEAN := false;\r\nBEGIN\r\n  -- Check profiles table\r\n  SELECT role INTO v_role FROM public.profiles WHERE id = user_id;\r\n  v_is_admin := v_role IN ('super_admin', 'superadmin', 'admin');\r\n  \r\n  -- Check system_user_assignments if not admin yet\r\n  IF NOT v_is_admin AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'system_user_assignments') THEN\r\n    v_is_admin := EXISTS (\r\n      SELECT 1 FROM public.system_user_assignments \r\n      WHERE system_user_assignments.user_id = is_portal_admin.user_id \r\n      AND system_role IN ('super_admin', 'admin')\r\n      AND is_active = true\r\n    );\r\n  END IF;\r\n  \r\n  -- Check user_roles if not admin yet\r\n  IF NOT v_is_admin AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'user_roles') THEN\r\n    v_is_admin := EXISTS (\r\n      SELECT 1 FROM public.user_roles \r\n      WHERE user_roles.user_id = is_portal_admin.user_id \r\n      AND role IN ('super_admin', 'admin')\r\n    );\r\n  END IF;\r\n  \r\n  RETURN v_is_admin;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "log_portal_membership_change",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.log_portal_membership_change()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_user_email TEXT;\r\nBEGIN\r\n  -- Check if portal_admin_activity table exists\r\n  IF EXISTS (\r\n    SELECT 1 FROM information_schema.tables \r\n    WHERE table_schema = 'public' \r\n    AND table_name = 'portal_admin_activity'\r\n  ) THEN\r\n    -- Get user email for entity_title\r\n    SELECT email INTO v_user_email FROM public.profiles WHERE id = NEW.user_id;\r\n    \r\n    IF TG_OP = 'INSERT' THEN\r\n      INSERT INTO public.portal_admin_activity (\r\n        admin_id,\r\n        action,\r\n        entity_type,\r\n        entity_id,\r\n        entity_title,\r\n        changes,\r\n        created_at\r\n      ) VALUES (\r\n        auth.uid(),\r\n        'portal_role_assignment',\r\n        'portal_member',\r\n        NEW.id,\r\n        COALESCE(v_user_email, 'Unknown User') || ' - Portal: ' || NEW.portal_role,\r\n        jsonb_build_object(\r\n          'user_id', NEW.user_id,\r\n          'role', NEW.portal_role,\r\n          'subscription_tier', NEW.subscription_tier,\r\n          'operation', 'create',\r\n          'context', 'portal'\r\n        ),\r\n        NOW()\r\n      );\r\n    ELSIF TG_OP = 'UPDATE' THEN\r\n      IF OLD.is_active != NEW.is_active THEN\r\n        INSERT INTO public.portal_admin_activity (\r\n          admin_id,\r\n          action,\r\n          entity_type,\r\n          entity_id,\r\n          entity_title,\r\n          changes,\r\n          created_at\r\n        ) VALUES (\r\n          auth.uid(),\r\n          CASE WHEN NEW.is_active THEN 'portal_role_activation' ELSE 'portal_role_deactivation' END,\r\n          'portal_member',\r\n          NEW.id,\r\n          COALESCE(v_user_email, 'Unknown User') || ' - Portal: ' || NEW.portal_role,\r\n          jsonb_build_object(\r\n            'user_id', NEW.user_id,\r\n            'role', NEW.portal_role,\r\n            'subscription_tier', NEW.subscription_tier,\r\n            'is_active', NEW.is_active,\r\n            'operation', 'update',\r\n            'context', 'portal'\r\n          ),\r\n          NOW()\r\n        );\r\n      END IF;\r\n    END IF;\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "promote_portal_user",
    "arguments": "p_user_id uuid, p_new_role text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.promote_portal_user(p_user_id uuid, p_new_role text)\n RETURNS TABLE(success boolean, message text, old_role text, new_role text)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_caller_role TEXT;\r\n  v_current_role TEXT;\r\n  v_user_email TEXT;\r\nBEGIN\r\n  -- Get caller's role\r\n  SELECT role INTO v_caller_role\r\n  FROM profiles\r\n  WHERE id = auth.uid();\r\n\r\n  -- Only super_admins can promote users\r\n  IF v_caller_role != 'super_admin' THEN\r\n    RETURN QUERY SELECT FALSE, 'Only super administrators can promote users', NULL::TEXT, NULL::TEXT;\r\n    RETURN;\r\n  END IF;\r\n\r\n  -- Validate new role is a valid portal role\r\n  IF p_new_role NOT IN ('portal_member', 'investor', 'admin', 'super_admin') THEN\r\n    RETURN QUERY SELECT FALSE, 'Invalid portal role. Must be: portal_member, investor, admin, or super_admin', NULL::TEXT, NULL::TEXT;\r\n    RETURN;\r\n  END IF;\r\n\r\n  -- Get current user info\r\n  SELECT role, email INTO v_current_role, v_user_email\r\n  FROM profiles\r\n  WHERE id = p_user_id;\r\n\r\n  IF v_current_role IS NULL THEN\r\n    RETURN QUERY SELECT FALSE, 'User not found or not a portal user', NULL::TEXT, NULL::TEXT;\r\n    RETURN;\r\n  END IF;\r\n\r\n  -- Prevent promoting system users (role='user')\r\n  IF v_current_role = 'user' THEN\r\n    RETURN QUERY SELECT FALSE, 'Cannot promote system users. User must be a portal member first.', v_current_role, NULL::TEXT;\r\n    RETURN;\r\n  END IF;\r\n\r\n  -- Update the user's role\r\n  UPDATE profiles\r\n  SET\r\n    role = p_new_role,\r\n    updated_at = NOW()\r\n  WHERE id = p_user_id;\r\n\r\n  -- Return success\r\n  RETURN QUERY SELECT TRUE,\r\n    format('User %s promoted from %s to %s', v_user_email, v_current_role, p_new_role),\r\n    v_current_role,\r\n    p_new_role;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "archive_system_user",
    "arguments": "p_user_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.archive_system_user(p_user_id uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n    v_updated_count INTEGER;\r\nBEGIN\r\n    -- Perform the archive\r\n    UPDATE profiles\r\n    SET \r\n        status = 'archived',\r\n        updated_at = NOW()\r\n    WHERE id = p_user_id\r\n    AND status != 'archived';  -- Don't update if already archived\r\n    \r\n    GET DIAGNOSTICS v_updated_count = ROW_COUNT;\r\n    \r\n    IF v_updated_count = 0 THEN\r\n        -- Check if user exists\r\n        IF EXISTS (SELECT 1 FROM profiles WHERE id = p_user_id) THEN\r\n            RETURN jsonb_build_object(\r\n                'success', false,\r\n                'error', 'User is already archived or update failed'\r\n            );\r\n        ELSE\r\n            RETURN jsonb_build_object(\r\n                'success', false,\r\n                'error', 'User not found'\r\n            );\r\n        END IF;\r\n    END IF;\r\n    \r\n    RETURN jsonb_build_object(\r\n        'success', true,\r\n        'message', 'User archived successfully',\r\n        'user_id', p_user_id\r\n    );\r\nEXCEPTION WHEN OTHERS THEN\r\n    RETURN jsonb_build_object(\r\n        'success', false,\r\n        'error', SQLERRM\r\n    );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "archive_system_user_simple",
    "arguments": "target_user_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.archive_system_user_simple(target_user_id uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n    v_result JSONB;\r\n    v_user_email TEXT;\r\nBEGIN\r\n    -- Get user email for response\r\n    SELECT email INTO v_user_email FROM public.profiles WHERE id = target_user_id;\r\n    \r\n    -- Direct update bypassing RLS since SECURITY DEFINER\r\n    UPDATE public.profiles\r\n    SET \r\n        status = 'archived',\r\n        updated_at = CURRENT_TIMESTAMP\r\n    WHERE id = target_user_id\r\n    AND status != 'archived';\r\n    \r\n    IF FOUND THEN\r\n        v_result := jsonb_build_object(\r\n            'success', true,\r\n            'message', 'User archived successfully',\r\n            'email', v_user_email\r\n        );\r\n    ELSE\r\n        -- Check if user exists\r\n        IF EXISTS (SELECT 1 FROM public.profiles WHERE id = target_user_id) THEN\r\n            v_result := jsonb_build_object(\r\n                'success', false,\r\n                'error', 'User already archived'\r\n            );\r\n        ELSE\r\n            v_result := jsonb_build_object(\r\n                'success', false,\r\n                'error', 'User not found'\r\n            );\r\n        END IF;\r\n    END IF;\r\n    \r\n    RETURN v_result;\r\nEXCEPTION\r\n    WHEN OTHERS THEN\r\n        RETURN jsonb_build_object(\r\n            'success', false,\r\n            'error', SQLERRM\r\n        );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "can_access_profiles",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.can_access_profiles()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  -- Direct query without using RLS to prevent recursion\n  RETURN EXISTS (\n    SELECT 1 \n    FROM user_roles \n    WHERE user_id = auth.uid() \n    AND (role = 'admin' OR role = 'owner')\n  );\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "can_rate_users",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.can_rate_users()\n RETURNS boolean\n LANGUAGE sql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_catalog'\nAS $function$\r\n  SELECT EXISTS (\r\n    SELECT 1\r\n    FROM public.user_roles\r\n    WHERE user_roles.user_id = auth.uid()\r\n    AND user_roles.role IN ('admin', 'owner', 'manager')\r\n  );\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "check_profiles_columns",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.check_profiles_columns()\n RETURNS TABLE(column_name text, data_type text)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT \r\n    c.column_name::text,\r\n    c.data_type::text\r\n  FROM information_schema.columns c\r\n  WHERE c.table_schema = 'public'\r\n    AND c.table_name = 'profiles'\r\n  ORDER BY c.ordinal_position;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "check_user_exists",
    "arguments": "user_email text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.check_user_exists(user_email text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  -- First check if the user exists in auth.users (case insensitive)\n  RETURN EXISTS (\n    SELECT 1 FROM auth.users\n    WHERE lower(email) = lower(user_email)\n  );\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "check_user_membership_agreement",
    "arguments": "p_user_id uuid, p_version text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.check_user_membership_agreement(p_user_id uuid, p_version text DEFAULT '1.0'::text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  RETURN EXISTS (\r\n    SELECT 1\r\n    FROM public.membership_agreements\r\n    WHERE user_id = p_user_id\r\n    AND agreement_version = p_version\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "check_user_nda_agreement",
    "arguments": "p_user_id uuid, p_version text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.check_user_nda_agreement(p_user_id uuid, p_version text DEFAULT '1.0'::text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  RETURN EXISTS (\r\n    SELECT 1\r\n    FROM public.nda_agreements\r\n    WHERE user_id = p_user_id\r\n    AND nda_version = p_version\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "check_user_permission",
    "arguments": "p_permission_name text, p_user_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.check_user_permission(p_permission_name text, p_user_id uuid DEFAULT auth.uid())\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_catalog'\nAS $function$\r\nBEGIN\r\n  RETURN EXISTS (\r\n    SELECT 1 FROM get_user_permissions(p_user_id) \r\n    WHERE permission = p_permission_name\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "check_user_roles",
    "arguments": "user_email text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.check_user_roles(user_email text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n    v_result json;\r\nBEGIN\r\n    WITH user_data AS (\r\n        SELECT \r\n            p.id,\r\n            p.email,\r\n            p.first_name,\r\n            p.last_name,\r\n            array_agg(DISTINCT ur.role::text ORDER BY ur.role::text) FILTER (WHERE ur.role IS NOT NULL) as roles,\r\n            da.password_hash IS NOT NULL as has_dev_password\r\n        FROM profiles p\r\n        LEFT JOIN user_roles ur ON ur.user_id = p.id\r\n        LEFT JOIN dev_auth da ON da.user_id = p.id\r\n        WHERE lower(p.email) = lower(user_email)\r\n        GROUP BY p.id, p.email, p.first_name, p.last_name, da.password_hash\r\n    )\r\n    SELECT json_build_object(\r\n        'found', COUNT(*) > 0,\r\n        'user', CASE \r\n            WHEN COUNT(*) > 0 THEN \r\n                json_build_object(\r\n                    'id', id,\r\n                    'email', email,\r\n                    'name', TRIM(CONCAT(first_name, ' ', last_name)),\r\n                    'roles', CASE \r\n                        WHEN roles IS NULL THEN ARRAY[]::text[]\r\n                        ELSE roles\r\n                    END,\r\n                    'has_dev_password', has_dev_password,\r\n                    'role_count', CASE \r\n                        WHEN roles IS NULL THEN 0\r\n                        ELSE array_length(roles, 1)\r\n                    END\r\n                )\r\n            ELSE NULL \r\n        END\r\n    ) INTO v_result\r\n    FROM user_data\r\n    GROUP BY id, email, first_name, last_name, roles, has_dev_password;\r\n    \r\n    RETURN v_result;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "create_new_user",
    "arguments": "email text, first_name text, last_name text, middle_name text, suffix text, preferred_name text, phone_number text, organization_id uuid, user_role app_role",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_new_user(email text, first_name text, last_name text, middle_name text DEFAULT NULL::text, suffix text DEFAULT NULL::text, preferred_name text DEFAULT NULL::text, phone_number text DEFAULT NULL::text, organization_id uuid DEFAULT NULL::uuid, user_role app_role DEFAULT NULL::app_role)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n    new_user_id uuid;\r\n    user_password text;\r\n    calling_user_role text;\r\n    is_system_user boolean;\r\nBEGIN\r\n    -- Check if the calling user has admin privileges\r\n    SELECT role INTO calling_user_role\r\n    FROM user_roles \r\n    WHERE user_id = auth.uid() \r\n    AND role IN ('admin', 'super_admin', 'developer')\r\n    LIMIT 1;\r\n\r\n    IF calling_user_role IS NULL THEN\r\n        RAISE EXCEPTION 'Only administrators can create users';\r\n    END IF;\r\n\r\n    -- Check if email already exists\r\n    IF EXISTS (\r\n        SELECT 1 FROM auth.users u WHERE lower(u.email) = lower(create_new_user.email)\r\n    ) THEN\r\n        RAISE EXCEPTION 'Email already exists';\r\n    END IF;\r\n\r\n    -- Determine if this is a system user\r\n    is_system_user := (user_role IN ('super_admin', 'admin', 'developer', 'finance'));\r\n\r\n    -- Set password\r\n    IF is_system_user THEN\r\n        user_password := 'FleetDRMS!';\r\n    ELSE\r\n        user_password := encode(gen_random_bytes(12), 'base64');\r\n    END IF;\r\n\r\n    -- Generate user ID\r\n    new_user_id := gen_random_uuid();\r\n\r\n    -- Insert into auth.users with proper password hashing\r\n    INSERT INTO auth.users (\r\n        id,\r\n        email,\r\n        encrypted_password,\r\n        email_confirmed_at,\r\n        raw_user_meta_data,\r\n        created_at,\r\n        updated_at,\r\n        confirmation_token,\r\n        recovery_token,\r\n        email_change_token_new,\r\n        email_change\r\n    ) VALUES (\r\n        new_user_id,\r\n        lower(create_new_user.email),\r\n        extensions.crypt(user_password, extensions.gen_salt('bf', 10)),\r\n        NOW(),\r\n        jsonb_build_object(\r\n            'first_name', create_new_user.first_name,\r\n            'last_name', create_new_user.last_name,\r\n            'middle_name', create_new_user.middle_name,\r\n            'suffix', create_new_user.suffix,\r\n            'preferred_name', create_new_user.preferred_name,\r\n            'phone_number', create_new_user.phone_number,\r\n            'organization_id', create_new_user.organization_id\r\n        ),\r\n        NOW(),\r\n        NOW(),\r\n        '',\r\n        '',\r\n        '',\r\n        ''\r\n    );\r\n\r\n    -- Wait briefly for trigger execution\r\n    PERFORM pg_sleep(0.1);\r\n\r\n    -- Update profile with additional fields\r\n    UPDATE public.profiles\r\n    SET \r\n        middle_name = create_new_user.middle_name,\r\n        suffix = create_new_user.suffix,\r\n        preferred_name = create_new_user.preferred_name,\r\n        phone_number = create_new_user.phone_number,\r\n        organization_id = create_new_user.organization_id,\r\n        updated_at = NOW()\r\n    WHERE id = new_user_id;\r\n\r\n    -- Add role if specified\r\n    IF user_role IS NOT NULL THEN\r\n        INSERT INTO user_roles (user_id, role)\r\n        VALUES (new_user_id, user_role);\r\n    END IF;\r\n\r\n    -- For system users also set dev_auth password with email\r\n    IF is_system_user THEN\r\n        INSERT INTO dev_auth (user_id, email, password_hash, created_at, updated_at)\r\n        VALUES (\r\n            new_user_id, \r\n            lower(create_new_user.email), \r\n            extensions.crypt(user_password, extensions.gen_salt('bf', 10)),\r\n            NOW(),\r\n            NOW()\r\n        )\r\n        ON CONFLICT (user_id) DO UPDATE SET\r\n            email = lower(create_new_user.email),\r\n            password_hash = extensions.crypt(user_password, extensions.gen_salt('bf', 10)),\r\n            updated_at = NOW();\r\n    END IF;\r\n\r\n    RETURN new_user_id;\r\n\r\nEXCEPTION\r\n    WHEN OTHERS THEN\r\n        -- Clean up on error\r\n        DELETE FROM auth.users WHERE id = new_user_id;\r\n        DELETE FROM public.profiles WHERE id = new_user_id;\r\n        DELETE FROM user_roles WHERE user_id = new_user_id;\r\n        DELETE FROM dev_auth WHERE user_id = new_user_id;\r\n        \r\n        RAISE EXCEPTION 'Unexpected error while creating user: %', SQLERRM;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "create_new_user_v2",
    "arguments": "email text, first_name text, last_name text, middle_name text, suffix text, preferred_name text, phone_number text, organization_id uuid, user_role app_role",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_new_user_v2(email text, first_name text, last_name text, middle_name text DEFAULT NULL::text, suffix text DEFAULT NULL::text, preferred_name text DEFAULT NULL::text, phone_number text DEFAULT NULL::text, organization_id uuid DEFAULT NULL::uuid, user_role app_role DEFAULT NULL::app_role)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_result json;\r\n  v_user_id uuid;\r\n  v_password text;\r\n  v_is_system_user boolean;\r\nBEGIN\r\n  -- Determine if this is a system user\r\n  v_is_system_user := (user_role IN ('super_admin', 'admin', 'developer', 'finance'));\r\n  \r\n  -- Set password\r\n  IF v_is_system_user THEN\r\n    v_password := 'FleetDRMS!';\r\n  ELSE\r\n    v_password := encode(gen_random_bytes(12), 'base64');\r\n  END IF;\r\n\r\n  -- Call the new function\r\n  v_result := create_user_with_supabase_auth(\r\n    email, v_password, first_name, last_name,\r\n    middle_name, suffix, preferred_name, phone_number,\r\n    organization_id, user_role\r\n  );\r\n\r\n  -- Check if successful\r\n  IF (v_result->>'success')::boolean THEN\r\n    v_user_id := (v_result->>'user_id')::uuid;\r\n    \r\n    -- Log the password for system users\r\n    IF v_is_system_user THEN\r\n      RAISE NOTICE 'System user % created with password: FleetDRMS!', email;\r\n    END IF;\r\n    \r\n    RETURN v_user_id;\r\n  ELSE\r\n    RAISE EXCEPTION '%', v_result->>'error';\r\n  END IF;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "create_profile_after_signup",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_profile_after_signup()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n    -- Try to insert profile, ignore if it fails\r\n    BEGIN\r\n        INSERT INTO public.profiles (id, email, role)\r\n        VALUES (NEW.id, NEW.email, 'portal_member')\r\n        ON CONFLICT (id) DO NOTHING;\r\n    EXCEPTION\r\n        WHEN OTHERS THEN\r\n            -- Silently ignore all errors\r\n            NULL;\r\n    END;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "create_user_with_supabase_auth",
    "arguments": "p_email text, p_password text, p_first_name text, p_last_name text, p_middle_name text, p_suffix text, p_preferred_name text, p_phone_number text, p_organization_id uuid, p_role app_role",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_user_with_supabase_auth(p_email text, p_password text, p_first_name text, p_last_name text, p_middle_name text DEFAULT NULL::text, p_suffix text DEFAULT NULL::text, p_preferred_name text DEFAULT NULL::text, p_phone_number text DEFAULT NULL::text, p_organization_id uuid DEFAULT NULL::uuid, p_role app_role DEFAULT NULL::app_role)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_user_id uuid;\r\n  v_calling_user_role text;\r\n  v_is_system_user boolean;\r\n  v_result json;\r\nBEGIN\r\n  -- Check if the calling user has admin privileges\r\n  SELECT role INTO v_calling_user_role\r\n  FROM user_roles \r\n  WHERE user_id = auth.uid() \r\n  AND role IN ('admin', 'super_admin', 'developer')\r\n  LIMIT 1;\r\n\r\n  IF v_calling_user_role IS NULL THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'Only administrators can create users'\r\n    );\r\n  END IF;\r\n\r\n  -- Check if email already exists\r\n  IF EXISTS (\r\n    SELECT 1 FROM auth.users WHERE lower(email) = lower(p_email)\r\n  ) THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'Email already exists'\r\n    );\r\n  END IF;\r\n\r\n  -- Determine if this is a system user\r\n  v_is_system_user := (p_role IN ('super_admin', 'admin', 'developer', 'finance'));\r\n\r\n  -- Generate user ID\r\n  v_user_id := gen_random_uuid();\r\n\r\n  BEGIN\r\n    -- Insert into auth.users with proper password hashing\r\n    -- Using the same bcrypt format that Supabase uses\r\n    INSERT INTO auth.users (\r\n      id,\r\n      email,\r\n      encrypted_password,\r\n      email_confirmed_at,\r\n      raw_user_meta_data,\r\n      created_at,\r\n      updated_at,\r\n      confirmation_token,\r\n      recovery_token,\r\n      email_change_token_new,\r\n      email_change\r\n    ) VALUES (\r\n      v_user_id,\r\n      lower(p_email),\r\n      crypt(p_password, gen_salt('bf', 10)), -- Using cost factor 10 like Supabase\r\n      NOW(), -- Auto-confirm email\r\n      jsonb_build_object(\r\n        'first_name', p_first_name,\r\n        'last_name', p_last_name,\r\n        'middle_name', p_middle_name,\r\n        'suffix', p_suffix,\r\n        'preferred_name', p_preferred_name,\r\n        'phone_number', p_phone_number,\r\n        'organization_id', p_organization_id\r\n      ),\r\n      NOW(),\r\n      NOW(),\r\n      '',  -- Empty tokens\r\n      '',\r\n      '',\r\n      ''\r\n    );\r\n\r\n    -- The trigger will create the profile, but let's ensure it has all fields\r\n    PERFORM pg_sleep(0.1);\r\n    \r\n    -- Update profile with additional fields\r\n    UPDATE profiles\r\n    SET \r\n      middle_name = p_middle_name,\r\n      suffix = p_suffix,\r\n      preferred_name = p_preferred_name,\r\n      phone_number = p_phone_number,\r\n      organization_id = p_organization_id\r\n    WHERE id = v_user_id;\r\n\r\n    -- Add role if specified\r\n    IF p_role IS NOT NULL THEN\r\n      INSERT INTO user_roles (user_id, role)\r\n      VALUES (v_user_id, p_role);\r\n    END IF;\r\n\r\n    -- Return success with user details\r\n    RETURN json_build_object(\r\n      'success', true,\r\n      'user_id', v_user_id,\r\n      'email', p_email,\r\n      'is_system_user', v_is_system_user,\r\n      'message', CASE \r\n        WHEN v_is_system_user THEN 'System user created with password: ' || p_password\r\n        ELSE 'User created successfully'\r\n      END\r\n    );\r\n\r\n  EXCEPTION\r\n    WHEN OTHERS THEN\r\n      -- Clean up if something went wrong\r\n      DELETE FROM auth.users WHERE id = v_user_id;\r\n      \r\n      RETURN json_build_object(\r\n        'success', false,\r\n        'error', SQLERRM,\r\n        'detail', SQLSTATE\r\n      );\r\n  END;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "diagnose_user_auth",
    "arguments": "user_email text, test_password text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.diagnose_user_auth(user_email text, test_password text DEFAULT NULL::text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_user_record record;\r\n  v_profile_record record;\r\n  v_roles text[];\r\n  v_password_valid boolean := false;\r\n  v_auth_method text;\r\nBEGIN\r\n  -- Only admins can run diagnostics\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM user_roles \r\n    WHERE user_id = auth.uid() \r\n    AND role IN ('admin', 'super_admin', 'developer')\r\n  ) THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'Only administrators can run auth diagnostics'\r\n    );\r\n  END IF;\r\n\r\n  -- Get user from auth.users\r\n  SELECT \r\n    id,\r\n    email,\r\n    encrypted_password,\r\n    email_confirmed_at,\r\n    confirmation_sent_at,\r\n    confirmed_at,\r\n    created_at,\r\n    updated_at,\r\n    last_sign_in_at,\r\n    raw_user_meta_data\r\n  INTO v_user_record\r\n  FROM auth.users\r\n  WHERE lower(email) = lower(user_email);\r\n\r\n  IF v_user_record IS NULL THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'User not found in auth.users',\r\n      'checked_email', user_email\r\n    );\r\n  END IF;\r\n\r\n  -- Get profile data\r\n  SELECT *\r\n  INTO v_profile_record\r\n  FROM profiles\r\n  WHERE id = v_user_record.id;\r\n\r\n  -- Get user roles\r\n  SELECT array_agg(role ORDER BY role)\r\n  INTO v_roles\r\n  FROM user_roles\r\n  WHERE user_id = v_user_record.id;\r\n\r\n  -- Test password if provided\r\n  IF test_password IS NOT NULL AND v_user_record.encrypted_password IS NOT NULL THEN\r\n    -- Check if password matches using crypt\r\n    v_password_valid := v_user_record.encrypted_password = crypt(test_password, v_user_record.encrypted_password);\r\n    \r\n    -- Detect auth method\r\n    IF v_user_record.encrypted_password LIKE '$2a$%' OR v_user_record.encrypted_password LIKE '$2b$%' THEN\r\n      v_auth_method := 'bcrypt';\r\n    ELSIF v_user_record.encrypted_password LIKE '$argon2%' THEN\r\n      v_auth_method := 'argon2';\r\n    ELSE\r\n      v_auth_method := 'unknown';\r\n    END IF;\r\n  END IF;\r\n\r\n  -- Return diagnostic information\r\n  RETURN json_build_object(\r\n    'success', true,\r\n    'user', json_build_object(\r\n      'id', v_user_record.id,\r\n      'email', v_user_record.email,\r\n      'created_at', v_user_record.created_at,\r\n      'updated_at', v_user_record.updated_at,\r\n      'last_sign_in_at', v_user_record.last_sign_in_at,\r\n      'email_confirmed_at', v_user_record.email_confirmed_at,\r\n      'has_password', v_user_record.encrypted_password IS NOT NULL,\r\n      'password_prefix', CASE \r\n        WHEN v_user_record.encrypted_password IS NOT NULL \r\n        THEN substring(v_user_record.encrypted_password, 1, 7)\r\n        ELSE NULL\r\n      END,\r\n      'auth_method', v_auth_method,\r\n      'metadata', v_user_record.raw_user_meta_data\r\n    ),\r\n    'profile', CASE \r\n      WHEN v_profile_record IS NOT NULL \r\n      THEN json_build_object(\r\n        'first_name', v_profile_record.first_name,\r\n        'last_name', v_profile_record.last_name,\r\n        'organization_id', v_profile_record.organization_id,\r\n        'status', v_profile_record.status\r\n      )\r\n      ELSE NULL\r\n    END,\r\n    'roles', v_roles,\r\n    'password_test', CASE \r\n      WHEN test_password IS NOT NULL \r\n      THEN json_build_object(\r\n        'tested', true,\r\n        'valid', v_password_valid,\r\n        'test_password_length', length(test_password)\r\n      )\r\n      ELSE json_build_object('tested', false)\r\n    END\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "end_user_impersonation",
    "arguments": "session_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.end_user_impersonation(session_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    -- Verify the caller is the admin who started this session\n    IF NOT EXISTS (\n        SELECT 1 \n        FROM impersonation_sessions \n        WHERE id = session_id \n        AND admin_id = auth.uid() \n        AND ended_at IS NULL\n    ) THEN\n        RAISE EXCEPTION 'Invalid impersonation session';\n    END IF;\n\n    -- End the session\n    UPDATE impersonation_sessions\n    SET ended_at = now()\n    WHERE id = session_id;\n\n    RETURN TRUE;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_my_user_info",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_my_user_info()\n RETURNS json\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_user_id UUID;\r\n  v_profile RECORD;\r\nBEGIN\r\n  v_user_id := auth.uid();\r\n\r\n  SELECT * INTO v_profile\r\n  FROM public.profiles\r\n  WHERE id = v_user_id;\r\n\r\n  RETURN json_build_object(\r\n    'user_id', v_user_id,\r\n    'email', v_profile.email,\r\n    'role', v_profile.role,\r\n    'can_delete', v_profile.role IN ('admin', 'super_admin')\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_new_users_today_count",
    "arguments": "today_date timestamp with time zone",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_new_users_today_count(today_date timestamp with time zone)\n RETURNS integer\n LANGUAGE sql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\n  SELECT COUNT(*)::integer \n  FROM profiles \n  WHERE created_at >= today_date;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_total_users_count",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_total_users_count()\n RETURNS integer\n LANGUAGE sql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\n  SELECT COUNT(*)::integer \n  FROM profiles;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_unread_updates_for_user",
    "arguments": "p_user_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_unread_updates_for_user(p_user_id uuid)\n RETURNS TABLE(update_id uuid, title character varying, content text, update_type character varying, target_audience character varying, priority integer, published_at timestamp with time zone, is_read boolean, is_acknowledged boolean, is_dismissed boolean)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT \r\n        pu.id as update_id,\r\n        pu.title,\r\n        pu.content,\r\n        pu.update_type,\r\n        pu.target_audience,\r\n        pu.priority,\r\n        pu.published_at,\r\n        COALESCE(pur.id IS NOT NULL, false) as is_read,\r\n        COALESCE(pur.acknowledged_at IS NOT NULL, false) as is_acknowledged,\r\n        COALESCE(pur.dismissed_at IS NOT NULL, false) as is_dismissed\r\n    FROM public.portal_updates pu\r\n    LEFT JOIN public.portal_update_reads pur \r\n        ON pur.update_id = pu.id \r\n        AND pur.user_id = p_user_id\r\n    WHERE pu.status = 'published'\r\n        AND (pur.dismissed_at IS NULL OR pu.update_type = 'compulsory')\r\n        AND (pur.acknowledged_at IS NULL OR pu.update_type = 'advisory')\r\n    ORDER BY \r\n        CASE WHEN pu.update_type = 'compulsory' THEN 0 ELSE 1 END,\r\n        pu.priority DESC,\r\n        pu.published_at DESC NULLS LAST;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_user_context",
    "arguments": "p_email text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_user_context(p_email text)\n RETURNS TABLE(user_id uuid, organization_id uuid, roles text[])\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT \r\n    p.id,\r\n    p.organization_id,\r\n    array_agg(DISTINCT ur.role::text) FILTER (WHERE ur.role IS NOT NULL) as roles\r\n  FROM profiles p\r\n  LEFT JOIN user_roles ur ON ur.user_id = p.id\r\n  WHERE lower(p.email) = lower(p_email)\r\n  GROUP BY p.id, p.organization_id;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_user_contexts",
    "arguments": "p_user_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_user_contexts(p_user_id uuid)\n RETURNS TABLE(context_type text, role text, organization_id uuid, organization_name text)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT \r\n    'system'::TEXT as context_type,\r\n    sua.system_role as role,\r\n    NULL::UUID as organization_id,\r\n    NULL::TEXT as organization_name\r\n  FROM public.system_user_assignments sua\r\n  WHERE sua.user_id = p_user_id AND sua.is_active = true\r\n  \r\n  UNION ALL\r\n  \r\n  SELECT \r\n    'organization'::TEXT as context_type,\r\n    om.org_role as role,\r\n    om.organization_id,\r\n    o.name as organization_name\r\n  FROM public.organization_memberships om\r\n  LEFT JOIN public.organizations o ON o.id = om.organization_id\r\n  WHERE om.user_id = p_user_id AND om.is_active = true\r\n  \r\n  UNION ALL\r\n  \r\n  SELECT \r\n    'portal'::TEXT as context_type,\r\n    pm.portal_role as role,\r\n    NULL::UUID as organization_id,\r\n    NULL::TEXT as organization_name\r\n  FROM public.portal_memberships pm\r\n  WHERE pm.user_id = p_user_id AND pm.is_active = true;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_user_deletion_preview",
    "arguments": "p_user_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_user_deletion_preview(p_user_id uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_user_data JSON;\r\n  v_deletion_counts JSON;\r\nBEGIN\r\n  -- Get user data\r\n  SELECT json_build_object(\r\n    'id', id,\r\n    'email', email,\r\n    'name', COALESCE(first_name || ' ' || last_name, first_name, last_name, email),\r\n    'role', role,\r\n    'created_at', created_at\r\n  )\r\n  INTO v_user_data\r\n  FROM profiles\r\n  WHERE id = p_user_id;\r\n\r\n  IF v_user_data IS NULL THEN\r\n    RAISE EXCEPTION 'User not found: %', p_user_id;\r\n  END IF;\r\n\r\n  -- Count related data that will be deleted\r\n  SELECT json_build_object(\r\n    'businesses', (SELECT COUNT(*) FROM businesses WHERE user_id = p_user_id),\r\n    'survey_responses', (SELECT COUNT(*) FROM portal_survey_responses WHERE user_id = p_user_id),\r\n    'event_registrations', (SELECT COUNT(*) FROM portal_event_registrations WHERE user_id = p_user_id),\r\n    'referrals_made', (SELECT COUNT(*) FROM portal_referrals WHERE referrer_id = p_user_id),\r\n    'updates_created', (SELECT COUNT(*) FROM portal_updates WHERE created_by = p_user_id),\r\n    'surveys_created', (SELECT COUNT(*) FROM portal_surveys WHERE created_by = p_user_id),\r\n    'events_created', (SELECT COUNT(*) FROM portal_events WHERE created_by = p_user_id),\r\n    'marketing_conversions', (SELECT COUNT(*) FROM marketing_conversions WHERE user_id = p_user_id),\r\n    'portal_memberships', (SELECT COUNT(*) FROM portal_memberships WHERE user_id = p_user_id)\r\n  )\r\n  INTO v_deletion_counts;\r\n\r\n  RETURN json_build_object(\r\n    'user', v_user_data,\r\n    'data_to_delete', v_deletion_counts\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_user_organization",
    "arguments": "user_uuid uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_user_organization(user_uuid uuid)\n RETURNS uuid\n LANGUAGE sql\n STABLE SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\n    SELECT organization_id \n    FROM profiles \n    WHERE id = user_uuid\n    LIMIT 1;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_user_permissions",
    "arguments": "p_user_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_user_permissions(p_user_id uuid DEFAULT auth.uid())\n RETURNS TABLE(permission text, context jsonb, expires_at timestamp with time zone, inherited_from text)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_catalog'\nAS $function$\r\nDECLARE\r\n  v_user_roles app_role[];\r\nBEGIN\r\n  -- Get user's roles\r\n  v_user_roles := get_user_roles(p_user_id);\r\n  \r\n  -- Return direct permissions\r\n  RETURN QUERY\r\n  SELECT \r\n    p.name as permission,\r\n    jsonb_build_object(\r\n      'scope', p.scope,\r\n      'resource', p.resource,\r\n      'action', p.action,\r\n      'role', rp.role::text\r\n    ) as context,\r\n    rp.expires_at,\r\n    'direct'::text as inherited_from\r\n  FROM role_permissions rp\r\n  JOIN permissions p ON p.id = rp.permission_id\r\n  WHERE rp.role = ANY(v_user_roles)\r\n  AND (rp.expires_at IS NULL OR rp.expires_at > now());\r\n\r\n  -- Return wildcard inherited permissions (admin:* grants admin:organizations)\r\n  RETURN QUERY\r\n  SELECT DISTINCT\r\n    p.name as permission,\r\n    jsonb_build_object(\r\n      'scope', p.scope,\r\n      'resource', p.resource,\r\n      'action', p.action,\r\n      'wildcard_source', wp.name,\r\n      'role', rp.role::text\r\n    ) as context,\r\n    rp.expires_at,\r\n    'wildcard'::text as inherited_from\r\n  FROM role_permissions rp\r\n  JOIN permissions wp ON wp.id = rp.permission_id\r\n  JOIN permissions p ON p.resource = wp.resource\r\n  WHERE rp.role = ANY(v_user_roles)\r\n  AND wp.action = '*'\r\n  AND p.name != wp.name\r\n  AND (rp.expires_at IS NULL OR rp.expires_at > now());\r\n\r\n  -- Legacy compatibility for existing code\r\n  IF 'super_admin' = ANY(v_user_roles) OR 'admin' = ANY(v_user_roles) THEN\r\n    RETURN QUERY\r\n    SELECT \r\n      legacy_perm.permission,\r\n      jsonb_build_object('scope', 'legacy') as context,\r\n      NULL::timestamptz as expires_at,\r\n      'legacy'::text as inherited_from\r\n    FROM (\r\n      VALUES \r\n        ('admin:*'),\r\n        ('organization:*'),\r\n        ('user:*'),\r\n        ('module:*'),\r\n        ('fleet:*'),\r\n        ('fleet_maintenance:*'),\r\n        ('profile:view'),\r\n        ('profile:edit')\r\n    ) AS legacy_perm(permission);\r\n  END IF;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_user_permissions_old_backup",
    "arguments": "p_user_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_user_permissions_old_backup(p_user_id uuid DEFAULT auth.uid())\n RETURNS TABLE(permission text)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  -- Check admin status using materialized view\n  IF EXISTS (SELECT 1 FROM admin_users_view WHERE user_id = p_user_id) THEN\n    RETURN QUERY \n      SELECT 'admin:*'\n      UNION SELECT 'organization:*'\n      UNION SELECT 'user:*'\n      UNION SELECT 'module:*'\n      UNION SELECT 'fleet:*'\n      UNION SELECT 'fleet_maintenance:*'\n      UNION SELECT 'profile:view'\n      UNION SELECT 'profile:edit';\n    RETURN;\n  END IF;\n  \n  -- Direct table access for role checks\n  IF EXISTS (SELECT 1 FROM user_roles WHERE user_id = p_user_id AND role = 'owner') THEN\n    RETURN QUERY SELECT * FROM public.get_owner_permissions();\n    RETURN;\n  END IF;\n  \n  -- Basic permissions for all authenticated users\n  RETURN QUERY\n    SELECT 'profile:view'\n    UNION SELECT 'profile:edit';\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_user_roles",
    "arguments": "p_user_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_user_roles(p_user_id uuid DEFAULT auth.uid())\n RETURNS app_role[]\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_catalog'\nAS $function$\r\nDECLARE\r\n  user_roles app_role[];\r\nBEGIN\r\n  SELECT array_agg(DISTINCT role) \r\n  INTO user_roles\r\n  FROM user_roles\r\n  WHERE user_id = p_user_id;\r\n  \r\n  RETURN COALESCE(user_roles, ARRAY[]::app_role[]);\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_user_survey_status",
    "arguments": "p_user_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_user_survey_status(p_user_id uuid)\n RETURNS TABLE(survey_id uuid, survey_title text, survey_description text, survey_status text, created_at timestamp with time zone, updated_at timestamp with time zone, user_status text, progress_percentage integer, started_at timestamp with time zone, completed_at timestamp with time zone, response_id uuid, is_complete boolean, answered_questions integer, total_questions integer, due_date timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT\r\n    s.id as survey_id,\r\n    s.title::TEXT as survey_title,\r\n    s.description::TEXT as survey_description,\r\n    s.status::TEXT as survey_status,\r\n    s.created_at,\r\n    s.updated_at,\r\n    CASE\r\n      WHEN sr.is_complete THEN 'completed'\r\n      WHEN sr.id IS NOT NULL THEN 'in_progress'\r\n      ELSE 'not_started'\r\n    END as user_status,\r\n    CASE\r\n      WHEN COALESCE(s.question_count, 0) > 0 AND COALESCE(sr.answered_questions, 0) > 0 THEN\r\n        COALESCE(ROUND((sr.answered_questions::NUMERIC / s.question_count) * 100), 0)::INTEGER\r\n      WHEN sr.is_complete THEN 100\r\n      ELSE 0\r\n    END as progress_percentage,\r\n    sr.started_at,\r\n    sr.completed_at,\r\n    sr.id as response_id,\r\n    COALESCE(sr.is_complete, false) as is_complete,\r\n    COALESCE(sr.answered_questions, 0)::INTEGER as answered_questions,\r\n    COALESCE(s.question_count, 0)::INTEGER as total_questions,\r\n    s.due_date\r\n  FROM public.portal_surveys s\r\n  LEFT JOIN public.portal_survey_responses sr\r\n    ON s.id = sr.survey_id\r\n    AND sr.user_id = p_user_id\r\n  WHERE s.status = 'published'\r\n  ORDER BY s.created_at DESC;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "list_all_users",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.list_all_users()\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_users json;\r\nBEGIN\r\n  -- Check if the calling user is an admin\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM user_roles \r\n    WHERE user_id = auth.uid() \r\n    AND role IN ('admin', 'super_admin', 'developer')\r\n  ) THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'Only administrators can list users'\r\n    );\r\n  END IF;\r\n\r\n  SELECT json_agg(\r\n    json_build_object(\r\n      'email', u.email,\r\n      'id', u.id,\r\n      'created_at', u.created_at,\r\n      'last_sign_in', u.last_sign_in_at,\r\n      'profile', json_build_object(\r\n        'first_name', p.first_name,\r\n        'last_name', p.last_name,\r\n        'organization', o.name\r\n      ),\r\n      'roles', (\r\n        SELECT array_agg(role ORDER BY role) \r\n        FROM user_roles \r\n        WHERE user_id = u.id\r\n      )\r\n    ) ORDER BY u.email\r\n  )\r\n  INTO v_users\r\n  FROM auth.users u\r\n  LEFT JOIN profiles p ON p.id = u.id\r\n  LEFT JOIN organizations o ON o.id = p.organization_id;\r\n\r\n  RETURN json_build_object(\r\n    'success', true,\r\n    'users', COALESCE(v_users, '[]'::json),\r\n    'count', COALESCE(json_array_length(v_users), 0)\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "preview_user_deletion",
    "arguments": "p_user_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.preview_user_deletion(p_user_id uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_user_data JSON;\r\n  v_deletion_counts JSON;\r\nBEGIN\r\n  -- Get user basic info\r\n  SELECT json_build_object(\r\n    'id', id,\r\n    'email', email,\r\n    'name', COALESCE(first_name || ' ' || last_name, first_name, last_name, email),\r\n    'role', role,\r\n    'created_at', created_at\r\n  )\r\n  INTO v_user_data\r\n  FROM profiles\r\n  WHERE id = p_user_id;\r\n\r\n  -- If user not found, return error\r\n  IF v_user_data IS NULL THEN\r\n    RETURN json_build_object(\r\n      'error', 'User not found',\r\n      'user_id', p_user_id\r\n    );\r\n  END IF;\r\n\r\n  -- Count all data that will be deleted\r\n  SELECT json_build_object(\r\n    'businesses', (SELECT COUNT(*) FROM businesses WHERE user_id = p_user_id),\r\n    'survey_responses', (SELECT COUNT(*) FROM portal_survey_responses WHERE user_id = p_user_id),\r\n    'event_registrations', (SELECT COUNT(*) FROM portal_event_registrations WHERE user_id = p_user_id),\r\n    'referrals_made', (SELECT COUNT(*) FROM portal_referrals WHERE referrer_id = p_user_id AND referral_type = 'individual'),\r\n    'updates_created', (SELECT COUNT(*) FROM portal_updates WHERE created_by = p_user_id),\r\n    'surveys_created', (SELECT COUNT(*) FROM portal_surveys WHERE created_by = p_user_id),\r\n    'events_created', (SELECT COUNT(*) FROM portal_events WHERE created_by = p_user_id),\r\n    'marketing_conversions', (SELECT COUNT(*) FROM referral_conversions WHERE user_id = p_user_id),\r\n    'portal_memberships', (SELECT COUNT(*) FROM portal_memberships WHERE user_id = p_user_id)\r\n  )\r\n  INTO v_deletion_counts;\r\n\r\n  -- Return combined data\r\n  RETURN json_build_object(\r\n    'user', v_user_data,\r\n    'data_to_delete', v_deletion_counts\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "record_user_login",
    "arguments": "p_user_id uuid, p_auth_type character varying, p_ip_address inet, p_user_agent text, p_success boolean, p_error_message text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.record_user_login(p_user_id uuid, p_auth_type character varying DEFAULT 'supabase'::character varying, p_ip_address inet DEFAULT NULL::inet, p_user_agent text DEFAULT NULL::text, p_success boolean DEFAULT true, p_error_message text DEFAULT NULL::text)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n    v_login_id UUID;\r\nBEGIN\r\n    -- Insert login record\r\n    INSERT INTO public.login_history (\r\n        user_id,\r\n        auth_type,\r\n        ip_address,\r\n        user_agent,\r\n        success,\r\n        error_message\r\n    ) VALUES (\r\n        p_user_id,\r\n        p_auth_type,\r\n        p_ip_address,\r\n        p_user_agent,\r\n        p_success,\r\n        p_error_message\r\n    ) RETURNING id INTO v_login_id;\r\n    \r\n    -- Update profiles with last login time if successful\r\n    IF p_success THEN\r\n        UPDATE public.profiles\r\n        SET last_sign_in_at = NOW()\r\n        WHERE id = p_user_id;\r\n    END IF;\r\n    \r\n    RETURN v_login_id;\r\nEXCEPTION WHEN OTHERS THEN\r\n    -- Log the error but don't fail\r\n    RAISE WARNING 'Failed to record login for user %: %', p_user_id, SQLERRM;\r\n    RETURN NULL;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "reset_user_password",
    "arguments": "user_email text, new_password text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.reset_user_password(user_email text, new_password text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'extensions'\nAS $function$\r\nDECLARE\r\n    v_user_id UUID;\r\n    v_is_admin BOOLEAN;\r\n    v_admin_org_id UUID;\r\n    v_target_org_id UUID;\r\n    v_is_company_admin BOOLEAN;\r\nBEGIN\r\n    -- Check if requesting user is authenticated\r\n    IF auth.uid() IS NULL THEN\r\n        -- Allow for dev sessions\r\n        v_is_admin := true;\r\n        v_is_company_admin := true;\r\n    ELSE\r\n        -- Check if the requesting user is an admin or owner\r\n        SELECT EXISTS (\r\n            SELECT 1 FROM user_roles \r\n            WHERE user_id = auth.uid() \r\n            AND role IN ('admin', 'owner')\r\n        ) INTO v_is_admin;\r\n        \r\n        -- Check if company-level admin\r\n        SELECT EXISTS (\r\n            SELECT 1 FROM user_roles \r\n            WHERE user_id = auth.uid() \r\n            AND role IN ('super_admin', 'admin', 'developer', 'finance')\r\n        ) INTO v_is_company_admin;\r\n    END IF;\r\n    \r\n    IF NOT v_is_admin AND NOT v_is_company_admin THEN\r\n        RETURN jsonb_build_object(\r\n            'success', false,\r\n            'error', 'Only admins and owners can reset passwords'\r\n        );\r\n    END IF;\r\n    \r\n    -- Get the target user's ID and organization\r\n    SELECT p.id, p.organization_id \r\n    INTO v_user_id, v_target_org_id\r\n    FROM profiles p\r\n    WHERE LOWER(p.email) = LOWER(user_email);\r\n    \r\n    IF v_user_id IS NULL THEN\r\n        RETURN jsonb_build_object(\r\n            'success', false,\r\n            'error', 'User not found'\r\n        );\r\n    END IF;\r\n    \r\n    -- If not a company admin, check organization boundaries\r\n    IF NOT v_is_company_admin AND auth.uid() IS NOT NULL THEN\r\n        -- Get admin's organization\r\n        SELECT organization_id INTO v_admin_org_id\r\n        FROM profiles\r\n        WHERE id = auth.uid();\r\n        \r\n        -- Check if admin and target user are in the same organization\r\n        IF v_admin_org_id IS DISTINCT FROM v_target_org_id THEN\r\n            RETURN jsonb_build_object(\r\n                'success', false,\r\n                'error', 'You can only reset passwords for users in your organization'\r\n            );\r\n        END IF;\r\n    END IF;\r\n    \r\n    -- Update the user's password in auth.users using extensions schema\r\n    UPDATE auth.users\r\n    SET \r\n        encrypted_password = extensions.crypt(new_password, extensions.gen_salt('bf')),\r\n        updated_at = NOW()\r\n    WHERE id = v_user_id;\r\n    \r\n    -- Also update dev_auth if the user exists there\r\n    UPDATE dev_auth\r\n    SET \r\n        password_hash = extensions.crypt(new_password, extensions.gen_salt('bf', 10)),\r\n        updated_at = NOW()\r\n    WHERE user_id = v_user_id;\r\n    \r\n    -- Check if we actually updated anything\r\n    IF NOT FOUND THEN\r\n        -- Check if the user exists in auth.users\r\n        IF NOT EXISTS (SELECT 1 FROM auth.users WHERE id = v_user_id) THEN\r\n            RETURN jsonb_build_object(\r\n                'success', false,\r\n                'error', 'User not found in authentication system'\r\n            );\r\n        END IF;\r\n    END IF;\r\n    \r\n    RETURN jsonb_build_object(\r\n        'success', true,\r\n        'user_id', v_user_id,\r\n        'message', 'Password has been reset successfully'\r\n    );\r\n    \r\nEXCEPTION WHEN OTHERS THEN\r\n    RETURN jsonb_build_object(\r\n        'success', false,\r\n        'error', SQLERRM,\r\n        'detail', SQLSTATE\r\n    );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "reset_user_password_admin",
    "arguments": "admin_user_id uuid, target_email text, new_password text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.reset_user_password_admin(admin_user_id uuid, target_email text, new_password text)\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'auth'\nAS $function$\r\nDECLARE\r\n  v_target_user_id UUID;\r\n  v_admin_role TEXT;\r\n  v_encrypted_password TEXT;\r\nBEGIN\r\n  -- Check if the requesting user is an admin\r\n  SELECT role INTO v_admin_role\r\n  FROM public.profiles\r\n  WHERE id = admin_user_id;\r\n  \r\n  IF v_admin_role IS NULL OR v_admin_role NOT IN ('superadmin', 'super_admin', 'admin') THEN\r\n    RAISE EXCEPTION 'Unauthorized: Only admins can reset passwords';\r\n  END IF;\r\n  \r\n  -- Find the target user by email\r\n  SELECT id INTO v_target_user_id\r\n  FROM auth.users\r\n  WHERE email = LOWER(target_email);\r\n  \r\n  IF v_target_user_id IS NULL THEN\r\n    -- User doesn't exist in auth, try to find in profiles and create auth record\r\n    SELECT id INTO v_target_user_id\r\n    FROM public.profiles\r\n    WHERE email = LOWER(target_email);\r\n    \r\n    IF v_target_user_id IS NULL THEN\r\n      RAISE EXCEPTION 'User not found: %', target_email;\r\n    END IF;\r\n    \r\n    -- Create auth record for existing profile\r\n    INSERT INTO auth.users (\r\n      id,\r\n      email,\r\n      encrypted_password,\r\n      email_confirmed_at,\r\n      created_at,\r\n      updated_at,\r\n      instance_id,\r\n      aud,\r\n      role\r\n    ) VALUES (\r\n      v_target_user_id,\r\n      LOWER(target_email),\r\n      crypt(new_password, gen_salt('bf')),\r\n      NOW(),\r\n      NOW(),\r\n      NOW(),\r\n      '00000000-0000-0000-0000-000000000000',\r\n      'authenticated',\r\n      'authenticated'\r\n    );\r\n    \r\n    RETURN 'Password set successfully (new auth record created)';\r\n  END IF;\r\n  \r\n  -- Update the password\r\n  UPDATE auth.users\r\n  SET \r\n    encrypted_password = crypt(new_password, gen_salt('bf')),\r\n    updated_at = NOW()\r\n  WHERE id = v_target_user_id;\r\n  \r\n  RETURN 'Password reset successfully';\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "set_user_password",
    "arguments": "target_user_id uuid, new_password text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.set_user_password(target_user_id uuid, new_password text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  calling_user_role text;\r\n  target_user_email text;\r\n  is_system_user boolean;\r\nBEGIN\r\n  -- Check if the calling user has admin privileges\r\n  SELECT role INTO calling_user_role\r\n  FROM user_roles \r\n  WHERE user_id = auth.uid() \r\n  AND role IN ('admin', 'super_admin', 'developer')\r\n  LIMIT 1;\r\n\r\n  IF calling_user_role IS NULL THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'Only administrators can set user passwords'\r\n    );\r\n  END IF;\r\n\r\n  -- Get target user email\r\n  SELECT email INTO target_user_email\r\n  FROM auth.users\r\n  WHERE id = target_user_id;\r\n\r\n  IF target_user_email IS NULL THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'User not found'\r\n    );\r\n  END IF;\r\n\r\n  -- Check if this is a system user\r\n  SELECT EXISTS (\r\n    SELECT 1 FROM user_roles \r\n    WHERE user_id = target_user_id \r\n    AND role IN ('super_admin', 'admin', 'developer', 'finance')\r\n  ) INTO is_system_user;\r\n\r\n  -- For now, we'll use the reset_user_password function if it exists\r\n  -- Otherwise, we'll update the auth.users table directly\r\n  BEGIN\r\n    -- Try to use reset_user_password if it exists\r\n    PERFORM reset_user_password(target_user_email, new_password);\r\n    \r\n    RETURN json_build_object(\r\n      'success', true,\r\n      'message', 'Password updated successfully',\r\n      'user_email', target_user_email,\r\n      'is_system_user', is_system_user\r\n    );\r\n  EXCEPTION\r\n    WHEN undefined_function THEN\r\n      -- If reset_user_password doesn't exist, update directly\r\n      UPDATE auth.users\r\n      SET \r\n        encrypted_password = crypt(new_password, gen_salt('bf')),\r\n        updated_at = NOW()\r\n      WHERE id = target_user_id;\r\n\r\n      RETURN json_build_object(\r\n        'success', true,\r\n        'message', 'Password updated directly',\r\n        'user_email', target_user_email,\r\n        'is_system_user', is_system_user\r\n      );\r\n    WHEN OTHERS THEN\r\n      RETURN json_build_object(\r\n        'success', false,\r\n        'error', SQLERRM,\r\n        'detail', SQLSTATE\r\n      );\r\n  END;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "start_user_impersonation",
    "arguments": "target_user_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.start_user_impersonation(target_user_id uuid)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    new_session_id UUID;\nBEGIN\n    -- Verify the caller is an admin using our existing is_admin function\n    IF NOT (SELECT is_admin()) THEN\n        RAISE EXCEPTION 'Only administrators can impersonate users';\n    END IF;\n\n    -- Create new impersonation session\n    INSERT INTO impersonation_sessions (admin_id, impersonated_user_id)\n    VALUES (auth.uid(), target_user_id)\n    RETURNING id INTO new_session_id;\n\n    RETURN new_session_id;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "sync_primary_business_to_profile",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.sync_primary_business_to_profile()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  IF NEW.is_primary = TRUE THEN\r\n    UPDATE public.profiles\r\n    SET \r\n      company_name = NEW.company_name,\r\n      website = NEW.website,\r\n      year_dsp_began = NEW.year_dsp_began,\r\n      avg_fleet_vehicles = NEW.avg_fleet_vehicles,\r\n      avg_drivers = NEW.avg_drivers,\r\n      average_fleet_size = NEW.avg_fleet_vehicles,\r\n      average_drivers = NEW.avg_drivers,\r\n      email = COALESCE(profiles.email, NEW.email),\r\n      phone = NEW.phone,\r\n      mobile = NEW.mobile,\r\n      street1 = NEW.street1,\r\n      street2 = NEW.street2,\r\n      city = NEW.city,\r\n      state = NEW.state,\r\n      zip = NEW.zip,\r\n      updated_at = NOW()\r\n    WHERE id = NEW.user_id;\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "sync_system_user_assignments",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.sync_system_user_assignments()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  -- Handle INSERT and UPDATE\r\n  IF TG_OP IN ('INSERT', 'UPDATE') THEN\r\n    -- Check if the new role is a system role\r\n    IF NEW.role IN ('super_admin', 'admin', 'developer', 'finance') THEN\r\n      -- Insert or update in system_user_assignments\r\n      INSERT INTO system_user_assignments (user_id, system_role, assigned_at, is_active)\r\n      VALUES (NEW.user_id, NEW.role::text, NOW(), true)\r\n      ON CONFLICT (user_id, system_role) \r\n      DO UPDATE SET \r\n        is_active = true,\r\n        assigned_at = CASE \r\n          WHEN system_user_assignments.is_active = false \r\n          THEN NOW() \r\n          ELSE system_user_assignments.assigned_at \r\n        END;\r\n    END IF;\r\n    \r\n    -- If updating from a system role to a non-system role, deactivate\r\n    IF TG_OP = 'UPDATE' AND OLD.role IN ('super_admin', 'admin', 'developer', 'finance') \r\n       AND NEW.role NOT IN ('super_admin', 'admin', 'developer', 'finance') THEN\r\n      UPDATE system_user_assignments \r\n      SET is_active = false \r\n      WHERE user_id = OLD.user_id AND system_role = OLD.role::text;\r\n    END IF;\r\n  END IF;\r\n  \r\n  -- Handle DELETE\r\n  IF TG_OP = 'DELETE' THEN\r\n    -- If deleting a system role, deactivate in system_user_assignments\r\n    IF OLD.role IN ('super_admin', 'admin', 'developer', 'finance') THEN\r\n      UPDATE system_user_assignments \r\n      SET is_active = false \r\n      WHERE user_id = OLD.user_id AND system_role = OLD.role::text;\r\n    END IF;\r\n  END IF;\r\n  \r\n  -- Handle organization roles for organization_memberships\r\n  IF TG_OP IN ('INSERT', 'UPDATE') THEN\r\n    IF NEW.role IN ('owner', 'manager', 'dispatch', 'tech', 'driver') THEN\r\n      -- Get the user's organization_id from profiles\r\n      DECLARE\r\n        v_org_id UUID;\r\n      BEGIN\r\n        SELECT organization_id INTO v_org_id\r\n        FROM profiles\r\n        WHERE id = NEW.user_id;\r\n        \r\n        -- Only insert if user has an organization\r\n        IF v_org_id IS NOT NULL THEN\r\n          INSERT INTO organization_memberships (user_id, organization_id, org_role, joined_at, is_active)\r\n          VALUES (NEW.user_id, v_org_id, NEW.role::text, NOW(), true)\r\n          ON CONFLICT (user_id, organization_id, org_role) \r\n          DO UPDATE SET \r\n            is_active = true,\r\n            joined_at = CASE \r\n              WHEN organization_memberships.is_active = false \r\n              THEN NOW() \r\n              ELSE organization_memberships.joined_at \r\n            END;\r\n        END IF;\r\n      END;\r\n    END IF;\r\n  END IF;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "sync_user_roles_to_context",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.sync_user_roles_to_context()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN\r\n    -- System roles\r\n    IF NEW.role IN ('super_admin', 'admin', 'developer', 'finance') THEN\r\n      INSERT INTO public.system_user_assignments (user_id, system_role, notes)\r\n      VALUES (NEW.user_id, NEW.role::text, 'Synced from user_roles')\r\n      ON CONFLICT (user_id, system_role) \r\n      DO UPDATE SET is_active = true;\r\n    END IF;\r\n    \r\n    -- Organization roles (need to determine org)\r\n    IF NEW.role IN ('owner', 'manager', 'dispatch', 'tech', 'driver') THEN\r\n      -- Try to find organization\r\n      INSERT INTO public.organization_memberships (user_id, organization_id, org_role, notes)\r\n      SELECT \r\n        NEW.user_id,\r\n        COALESCE(\r\n          p.organization_id,\r\n          (SELECT id FROM public.organizations WHERE name = 'Default Organization (Migration)')\r\n        ),\r\n        NEW.role::text,\r\n        'Synced from user_roles - verify org assignment'\r\n      FROM public.profiles p\r\n      WHERE p.id = NEW.user_id\r\n      ON CONFLICT (user_id, organization_id, org_role) \r\n      DO UPDATE SET is_active = true;\r\n    END IF;\r\n  ELSIF TG_OP = 'DELETE' THEN\r\n    -- Deactivate in context tables\r\n    UPDATE public.system_user_assignments \r\n    SET is_active = false \r\n    WHERE user_id = OLD.user_id AND system_role = OLD.role::text;\r\n    \r\n    UPDATE public.organization_memberships \r\n    SET is_active = false \r\n    WHERE user_id = OLD.user_id AND org_role = OLD.role::text;\r\n  END IF;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_user_roles",
    "arguments": "p_user_id uuid, new_roles app_role[]",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_user_roles(p_user_id uuid, new_roles app_role[])\n RETURNS TABLE(role app_role)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  -- Check if the calling user is an admin\r\n  IF NOT (SELECT EXISTS(SELECT 1 FROM admin_users_view WHERE user_id = auth.uid())) THEN\r\n    RAISE EXCEPTION 'Only administrators can update user roles';\r\n  END IF;\r\n\r\n  -- Delete existing roles\r\n  DELETE FROM public.user_roles\r\n  WHERE user_roles.user_id = p_user_id;\r\n\r\n  -- Insert new roles if any are provided\r\n  IF array_length(new_roles, 1) > 0 THEN\r\n    INSERT INTO public.user_roles (user_id, role)\r\n    SELECT p_user_id, unnest(new_roles);\r\n  END IF;\r\n\r\n  -- NOTE: admin_users_view is a regular view, it updates automatically\r\n  -- No REFRESH needed\r\n\r\n  -- Return the new roles\r\n  RETURN QUERY\r\n  SELECT user_roles.role\r\n  FROM public.user_roles\r\n  WHERE user_roles.user_id = p_user_id;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "upgrade_user_to_admin",
    "arguments": "user_email text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.upgrade_user_to_admin(user_email text)\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\n  DECLARE\r\n    v_user_id UUID;\r\n  BEGIN\r\n    -- Find the user\r\n    SELECT id INTO v_user_id\r\n    FROM public.profiles\r\n    WHERE email = LOWER(user_email);\r\n\r\n    IF v_user_id IS NULL THEN\r\n      RAISE EXCEPTION 'User not found: %', user_email;\r\n    END IF;\r\n\r\n    -- Update their role to admin\r\n    UPDATE public.profiles\r\n    SET\r\n      role = 'admin',\r\n      updated_at = NOW()\r\n    WHERE id = v_user_id;\r\n\r\n    -- Add to system_user_assignments if that table exists\r\n    BEGIN\r\n      INSERT INTO system_user_assignments (user_id, system_role, is_active, assigned_at)\r\n      VALUES (v_user_id, 'admin', true, NOW())\r\n      ON CONFLICT (user_id, system_role)\r\n      DO UPDATE SET is_active = true, assigned_at = NOW();\r\n    EXCEPTION\r\n      WHEN undefined_table THEN\r\n        -- Table doesn't exist, skip\r\n        NULL;\r\n      WHEN undefined_column THEN\r\n        -- Column doesn't exist, skip\r\n        NULL;\r\n    END;\r\n\r\n    -- Add to user_roles if that table exists  \r\n    BEGIN\r\n      INSERT INTO user_roles (user_id, role, created_at)\r\n      VALUES (v_user_id, 'admin', NOW())\r\n      ON CONFLICT (user_id, role) DO NOTHING;\r\n    EXCEPTION\r\n      WHEN undefined_table THEN\r\n        -- Table doesn't exist, skip\r\n        NULL;\r\n    END;\r\n\r\n    RETURN 'User ' || user_email || ' upgraded to admin role';\r\n  END;\r\n  $function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "upsert_user_business",
    "arguments": "p_user_id uuid, p_company_name text, p_type text, p_website text, p_phone text, p_address text, p_city text, p_state text, p_zip text, p_services_offered text, p_primary_markets text, p_year_established integer, p_fleet_size integer, p_driver_count integer",
    "function_definition": "CREATE OR REPLACE FUNCTION public.upsert_user_business(p_user_id uuid, p_company_name text, p_type text, p_website text, p_phone text, p_address text, p_city text, p_state text, p_zip text, p_services_offered text, p_primary_markets text, p_year_established integer, p_fleet_size integer DEFAULT NULL::integer, p_driver_count integer DEFAULT NULL::integer)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_business_id UUID;\r\n  v_result JSON;\r\nBEGIN\r\n  -- Check if user is authenticated\r\n  IF auth.uid() IS NULL THEN\r\n    RAISE EXCEPTION 'Not authenticated';\r\n  END IF;\r\n\r\n  -- Check if user owns this profile or is admin\r\n  IF p_user_id != auth.uid() AND NOT EXISTS (\r\n    SELECT 1 FROM public.profiles\r\n    WHERE id = auth.uid()\r\n    AND role IN ('admin', 'super_admin', 'superadmin')\r\n  ) THEN\r\n    RAISE EXCEPTION 'Unauthorized';\r\n  END IF;\r\n\r\n  -- Check if business exists\r\n  SELECT id INTO v_business_id\r\n  FROM public.businesses\r\n  WHERE owner_id = p_user_id OR id = p_user_id\r\n  LIMIT 1;\r\n\r\n  IF v_business_id IS NOT NULL THEN\r\n    -- Update existing business\r\n    UPDATE public.businesses\r\n    SET\r\n      company_name = p_company_name,\r\n      type = p_type,\r\n      website = p_website,\r\n      phone = p_phone,\r\n      address = p_address,\r\n      city = p_city,\r\n      state = p_state,\r\n      zip = p_zip,\r\n      services_offered = p_services_offered,\r\n      primary_markets = p_primary_markets,\r\n      year_established = p_year_established,\r\n      fleet_size = p_fleet_size,\r\n      driver_count = p_driver_count,\r\n      updated_at = NOW()\r\n    WHERE id = v_business_id;\r\n    \r\n    v_result := json_build_object('action', 'updated', 'id', v_business_id);\r\n  ELSE\r\n    -- Insert new business\r\n    INSERT INTO public.businesses (\r\n      id,\r\n      owner_id,\r\n      company_name,\r\n      type,\r\n      website,\r\n      phone,\r\n      address,\r\n      city,\r\n      state,\r\n      zip,\r\n      services_offered,\r\n      primary_markets,\r\n      year_established,\r\n      fleet_size,\r\n      driver_count,\r\n      created_at,\r\n      updated_at\r\n    ) VALUES (\r\n      p_user_id, -- Use user ID as business ID\r\n      p_user_id,\r\n      p_company_name,\r\n      p_type,\r\n      p_website,\r\n      p_phone,\r\n      p_address,\r\n      p_city,\r\n      p_state,\r\n      p_zip,\r\n      p_services_offered,\r\n      p_primary_markets,\r\n      p_year_established,\r\n      p_fleet_size,\r\n      p_driver_count,\r\n      NOW(),\r\n      NOW()\r\n    )\r\n    RETURNING id INTO v_business_id;\r\n    \r\n    v_result := json_build_object('action', 'inserted', 'id', v_business_id);\r\n  END IF;\r\n\r\n  RETURN v_result;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "user_has_role",
    "arguments": "p_role app_role",
    "function_definition": "CREATE OR REPLACE FUNCTION public.user_has_role(p_role app_role)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  -- Special case for admin role - use materialized view to avoid recursion\n  IF p_role = 'admin' THEN\n    RETURN EXISTS (\n      SELECT 1 FROM admin_users_view\n      WHERE user_id = auth.uid()\n    );\n  END IF;\n\n  -- For other roles, directly query the table without using RLS\n  -- This avoids the recursion issue\n  RETURN EXISTS (\n    SELECT 1 FROM user_roles\n    WHERE user_id = auth.uid()\n    AND role = p_role\n  );\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "verify_user_setup",
    "arguments": "user_email text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.verify_user_setup(user_email text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_user record;\r\n  v_profile record;\r\nBEGIN\r\n  -- Get user info\r\n  SELECT \r\n    id,\r\n    email,\r\n    encrypted_password,\r\n    email_confirmed_at,\r\n    created_at,\r\n    updated_at,\r\n    substring(encrypted_password, 1, 7) as password_prefix\r\n  INTO v_user\r\n  FROM auth.users\r\n  WHERE lower(email) = lower(user_email);\r\n\r\n  -- Get profile info\r\n  SELECT \r\n    id,\r\n    email,\r\n    first_name,\r\n    last_name,\r\n    created_at\r\n  INTO v_profile\r\n  FROM profiles\r\n  WHERE lower(email) = lower(user_email);\r\n\r\n  RETURN json_build_object(\r\n    'user_exists', v_user.id IS NOT NULL,\r\n    'profile_exists', v_profile.id IS NOT NULL,\r\n    'user', CASE \r\n      WHEN v_user.id IS NOT NULL THEN\r\n        json_build_object(\r\n          'id', v_user.id,\r\n          'email', v_user.email,\r\n          'email_confirmed', v_user.email_confirmed_at IS NOT NULL,\r\n          'password_prefix', v_user.password_prefix,\r\n          'has_password', v_user.encrypted_password IS NOT NULL AND v_user.encrypted_password != '',\r\n          'created_at', v_user.created_at,\r\n          'updated_at', v_user.updated_at\r\n        )\r\n      ELSE NULL\r\n    END,\r\n    'profile', CASE\r\n      WHEN v_profile.id IS NOT NULL THEN\r\n        json_build_object(\r\n          'id', v_profile.id,\r\n          'email', v_profile.email,\r\n          'name', concat(v_profile.first_name, ' ', v_profile.last_name),\r\n          'created_at', v_profile.created_at\r\n        )\r\n      ELSE NULL\r\n    END,\r\n    'ids_match', v_user.id = v_profile.id\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "acknowledge_update",
    "arguments": "p_update_id uuid, p_user_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.acknowledge_update(p_update_id uuid, p_user_id uuid)\n RETURNS void\n LANGUAGE sql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\n    INSERT INTO public.portal_update_reads (\r\n        update_id, \r\n        user_id, \r\n        first_viewed_at,\r\n        last_viewed_at,\r\n        acknowledged_at,\r\n        time_to_acknowledge\r\n    )\r\n    VALUES (\r\n        p_update_id, \r\n        p_user_id, \r\n        NOW(),\r\n        NOW(),\r\n        NOW(),\r\n        INTERVAL '0 seconds'\r\n    )\r\n    ON CONFLICT (update_id, user_id) \r\n    DO UPDATE SET\r\n        acknowledged_at = NOW(),\r\n        last_viewed_at = NOW(),\r\n        time_to_acknowledge = NOW() - portal_update_reads.first_viewed_at;\r\n        \r\n    UPDATE public.portal_updates \r\n    SET acknowledgment_count = COALESCE(acknowledgment_count, 0) + 1\r\n    WHERE id = p_update_id;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "add_dsp_location",
    "arguments": "p_dsp_id uuid, p_station_id uuid, p_is_primary boolean",
    "function_definition": "CREATE OR REPLACE FUNCTION public.add_dsp_location(p_dsp_id uuid, p_station_id uuid, p_is_primary boolean DEFAULT false)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_location_id UUID;\r\nBEGIN\r\n  -- If setting as primary, unset other primaries\r\n  IF p_is_primary THEN\r\n    UPDATE dsp_locations \r\n    SET is_primary = false \r\n    WHERE dsp_id = p_dsp_id AND is_primary = true;\r\n    \r\n    UPDATE dsps \r\n    SET primary_station_id = p_station_id \r\n    WHERE id = p_dsp_id;\r\n  END IF;\r\n  \r\n  -- Insert or update the location\r\n  INSERT INTO dsp_locations (dsp_id, station_id, is_primary, is_active)\r\n  VALUES (p_dsp_id, p_station_id, p_is_primary, true)\r\n  ON CONFLICT (dsp_id, station_id) \r\n  DO UPDATE SET \r\n    is_primary = EXCLUDED.is_primary,\r\n    is_active = true,\r\n    updated_at = now()\r\n  RETURNING id INTO v_location_id;\r\n  \r\n  RETURN v_location_id;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "admin_reset_password",
    "arguments": "user_email text, new_password text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.admin_reset_password(user_email text, new_password text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n    -- Just redirect to set_dev_password for now\r\n    RETURN set_dev_password(user_email, new_password);\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "archive_update",
    "arguments": "p_update_id uuid, p_admin_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.archive_update(p_update_id uuid, p_admin_id uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  update_title TEXT;\r\n  current_status TEXT;\r\nBEGIN\r\n  -- Get update details\r\n  SELECT title, status INTO update_title, current_status\r\n  FROM portal_updates \r\n  WHERE id = p_update_id;\r\n  \r\n  -- Check if update exists\r\n  IF update_title IS NULL THEN\r\n    RAISE EXCEPTION 'Update not found';\r\n  END IF;\r\n  \r\n  -- Check if already archived\r\n  IF current_status = 'archived' THEN\r\n    RAISE EXCEPTION 'Update is already archived';\r\n  END IF;\r\n  \r\n  -- Archive the update\r\n  UPDATE portal_updates\r\n  SET \r\n    status = 'archived',\r\n    archived_at = NOW(),\r\n    archived_by = p_admin_id,\r\n    updated_at = NOW()\r\n  WHERE id = p_update_id;\r\n  \r\n  -- Log the action\r\n  INSERT INTO portal_audit_log (\r\n    action, \r\n    entity_type, \r\n    entity_id, \r\n    admin_id, \r\n    details\r\n  ) VALUES (\r\n    'archive_update',\r\n    'update',\r\n    p_update_id,\r\n    p_admin_id,\r\n    json_build_object(\r\n      'title', update_title,\r\n      'previous_status', current_status,\r\n      'archived_at', NOW()\r\n    )\r\n  );\r\n  \r\n  RETURN json_build_object(\r\n    'success', true,\r\n    'title', update_title,\r\n    'archived_at', NOW()\r\n  );\r\nEXCEPTION\r\n  WHEN OTHERS THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', SQLERRM\r\n    );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "assign_market_region",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.assign_market_region()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_region_id UUID;\r\n    v_all_states_same_region BOOLEAN := true;\r\n    v_temp_region_id UUID;\r\nBEGIN\r\n    -- If primary_state is set, use it to determine region\r\n    IF NEW.primary_state IS NOT NULL THEN\r\n        NEW.region_id := public.get_region_from_state(NEW.primary_state);\r\n    -- If states array is set, check all states are in same region\r\n    ELSIF array_length(NEW.states, 1) > 0 THEN\r\n        FOR i IN 1..array_length(NEW.states, 1) LOOP\r\n            v_temp_region_id := public.get_region_from_state(NEW.states[i]);\r\n            \r\n            IF v_region_id IS NULL THEN\r\n                v_region_id := v_temp_region_id;\r\n            ELSIF v_region_id != v_temp_region_id THEN\r\n                v_all_states_same_region := false;\r\n                EXIT;\r\n            END IF;\r\n        END LOOP;\r\n        \r\n        -- Only auto-assign if all states are in the same region\r\n        IF v_all_states_same_region THEN\r\n            NEW.region_id := v_region_id;\r\n        ELSE\r\n            RAISE WARNING 'Market % spans multiple regions. Please set primary_state to determine region.', NEW.name;\r\n        END IF;\r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "auto_accept_terms_for_admins",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.auto_accept_terms_for_admins()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\n  BEGIN\r\n    IF NEW.role IN ('super_admin', 'admin')\r\n       OR NEW.email IN ('admin@fleetdrms.com', 'superadmin@fleetdrms.com') THEN\r\n      NEW.terms_accepted := TRUE;\r\n      NEW.terms_accepted_at := COALESCE(NEW.terms_accepted_at, NOW());\r\n      NEW.terms_version := COALESCE(NEW.terms_version, '1.0');\r\n    END IF;\r\n    RETURN NEW;\r\n  END;\r\n  $function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "can_access_fleet_record",
    "arguments": "p_organization_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.can_access_fleet_record(p_organization_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_user_org_id uuid;\nBEGIN\n  -- Admin check using materialized view\n  IF EXISTS (SELECT 1 FROM admin_users_view WHERE user_id = auth.uid()) THEN\n    RETURN TRUE;\n  END IF;\n  \n  -- Get user's organization\n  SELECT organization_id INTO v_user_org_id\n  FROM profiles\n  WHERE id = auth.uid();\n  \n  -- Check if user belongs to the organization\n  RETURN v_user_org_id = p_organization_id;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "can_access_maintenance_note",
    "arguments": "p_note_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.can_access_maintenance_note(p_note_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_record_id UUID;\nBEGIN\n  -- Get the parent record ID - Direct query to avoid RLS\n  SELECT maintenance_record_id INTO v_record_id\n  FROM maintenance_notes\n  WHERE id = p_note_id;\n  \n  -- Use the record access function\n  RETURN can_access_maintenance_record(v_record_id);\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "can_access_maintenance_record",
    "arguments": "p_record_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.can_access_maintenance_record(p_record_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_org_id UUID;\n  v_user_org_id UUID;\nBEGIN\n  -- Admin users always have access\n  IF EXISTS (SELECT 1 FROM admin_users_view WHERE user_id = auth.uid()) THEN\n    RETURN TRUE;\n  END IF;\n  \n  -- Get organization ID for the maintenance record\n  SELECT organization_id INTO v_org_id\n  FROM maintenance_records\n  WHERE id = p_record_id;\n  \n  -- Get user's organization - Direct table access to avoid RLS recursion\n  SELECT organization_id INTO v_user_org_id\n  FROM profiles\n  WHERE id = auth.uid();\n  \n  -- Check if user belongs to the same organization\n  RETURN v_org_id = v_user_org_id;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "can_access_module",
    "arguments": "p_module_type module_type, p_organization_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.can_access_module(p_module_type module_type, p_organization_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_is_admin boolean;\n  v_is_owner boolean;\n  v_user_org_id uuid;\n  v_module_enabled boolean;\nBEGIN\n  -- Check if user is admin\n  SELECT EXISTS (\n    SELECT 1 FROM admin_users_view \n    WHERE user_id = auth.uid()\n  ) INTO v_is_admin;\n  \n  -- Admins have access to all modules\n  IF v_is_admin THEN\n    RETURN TRUE;\n  END IF;\n  \n  -- Check if user is owner\n  SELECT EXISTS (\n    SELECT 1 FROM user_roles\n    WHERE user_id = auth.uid()\n    AND role = 'owner'\n  ) INTO v_is_owner;\n  \n  -- Get user's organization\n  SELECT organization_id INTO v_user_org_id\n  FROM profiles\n  WHERE id = auth.uid();\n  \n  -- Owner can only access modules for their organization\n  IF v_is_owner THEN\n    -- Must be owner's organization\n    IF v_user_org_id != p_organization_id THEN\n      RETURN FALSE;\n    END IF;\n    \n    -- Check if the module is enabled for the organization\n    SELECT COALESCE(mc.is_enabled, FALSE) INTO v_module_enabled\n    FROM modules m\n    JOIN module_configurations mc ON m.id = mc.module_id\n    WHERE m.type = p_module_type\n    AND mc.organization_id = p_organization_id;\n    \n    RETURN v_module_enabled;\n  END IF;\n  \n  -- For regular users, check organization match and module enabled status\n  IF v_user_org_id = p_organization_id THEN\n    SELECT COALESCE(mc.is_enabled, FALSE) INTO v_module_enabled\n    FROM modules m\n    JOIN module_configurations mc ON m.id = mc.module_id\n    WHERE m.type = p_module_type\n    AND mc.organization_id = p_organization_id;\n    \n    RETURN v_module_enabled;\n  END IF;\n  \n  -- Default: no access\n  RETURN FALSE;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "can_access_organization",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.can_access_organization()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  -- Direct query without using RLS to prevent recursion\n  RETURN EXISTS (\n    SELECT 1 \n    FROM user_roles \n    WHERE user_id = auth.uid() \n    AND (role = 'admin' OR role = 'owner')\n  );\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "can_access_organization",
    "arguments": "p_organization_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.can_access_organization(p_organization_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_user_org_id uuid;\nBEGIN\n  -- Use materialized view to check admin status - prevents recursion\n  IF EXISTS (SELECT 1 FROM admin_users_view WHERE user_id = auth.uid()) THEN\n    RETURN TRUE;\n  END IF;\n  \n  -- Direct table access without RLS to prevent recursion\n  SELECT organization_id INTO v_user_org_id\n  FROM profiles\n  WHERE id = auth.uid();\n  \n  -- Owner check - direct table access without triggering RLS\n  IF EXISTS (\n    SELECT 1 FROM user_roles\n    WHERE user_id = auth.uid()\n    AND role = 'owner'\n  ) THEN\n    RETURN v_user_org_id = p_organization_id;\n  END IF;\n  \n  -- All other cases\n  RETURN FALSE;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "can_access_organization_data",
    "arguments": "p_organization_id uuid, p_dev_user_email text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.can_access_organization_data(p_organization_id uuid, p_dev_user_email text DEFAULT NULL::text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_user_id uuid;\r\n  v_user_org_id uuid;\r\n  v_user_roles text[];\r\n  v_is_company_user boolean;\r\nBEGIN\r\n  -- If dev email provided, use that for context\r\n  IF p_dev_user_email IS NOT NULL THEN\r\n    SELECT user_id, organization_id, roles \r\n    INTO v_user_id, v_user_org_id, v_user_roles\r\n    FROM get_user_context(p_dev_user_email);\r\n  ELSE\r\n    -- Otherwise use auth session\r\n    v_user_id := auth.uid();\r\n  END IF;\r\n  \r\n  IF v_user_id IS NULL THEN\r\n    RETURN false;\r\n  END IF;\r\n  \r\n  -- Get user's organization and roles if not already set\r\n  IF v_user_org_id IS NULL THEN\r\n    SELECT p.organization_id INTO v_user_org_id\r\n    FROM profiles p\r\n    WHERE p.id = v_user_id;\r\n    \r\n    SELECT array_agg(DISTINCT ur.role::text) INTO v_user_roles\r\n    FROM user_roles ur\r\n    WHERE ur.user_id = v_user_id;\r\n  END IF;\r\n  \r\n  -- Check if user has company-level roles\r\n  v_is_company_user := EXISTS (\r\n    SELECT 1 FROM unnest(v_user_roles) AS role\r\n    WHERE role IN ('super_admin', 'admin', 'developer', 'finance')\r\n  );\r\n  \r\n  -- Company users can access any organization\r\n  IF v_is_company_user THEN\r\n    RETURN true;\r\n  END IF;\r\n  \r\n  -- Organization users can only access their own organization\r\n  RETURN v_user_org_id = p_organization_id;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "can_delete_wiki_article",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.can_delete_wiki_article()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  -- Use the materialized view to check admin status\n  RETURN EXISTS (\n    SELECT 1 \n    FROM admin_users_view\n    WHERE user_id = auth.uid()\n  );\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "can_owner_access_organization",
    "arguments": "p_organization_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.can_owner_access_organization(p_organization_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_user_org_id uuid;\n  v_is_owner boolean;\nBEGIN\n  -- Get user's organization from profiles table\n  SELECT organization_id INTO v_user_org_id\n  FROM profiles\n  WHERE id = auth.uid();\n  \n  -- Check if user has owner role (direct query to avoid recursion)\n  SELECT EXISTS (\n    SELECT 1 FROM user_roles\n    WHERE user_id = auth.uid()\n    AND role = 'owner'\n  ) INTO v_is_owner;\n  \n  -- Owner can only access their own organization\n  RETURN v_is_owner AND v_user_org_id = p_organization_id;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "cancel_event_registration",
    "arguments": "event_uuid uuid, reason text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.cancel_event_registration(event_uuid uuid, reason text DEFAULT NULL::text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  UPDATE public.portal_event_registrations\r\n  SET \r\n    attendance_status = 'cancelled',\r\n    cancellation_date = NOW(),\r\n    cancellation_reason = reason\r\n  WHERE event_id = event_uuid\r\n  AND user_id = auth.uid();\r\n\r\n  -- Move someone from waitlist if available\r\n  UPDATE public.portal_event_registrations\r\n  SET attendance_status = 'registered'\r\n  WHERE id = (\r\n    SELECT id \r\n    FROM public.portal_event_registrations\r\n    WHERE event_id = event_uuid\r\n    AND attendance_status = 'waitlisted'\r\n    ORDER BY registration_date\r\n    LIMIT 1\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "check_is_admin",
    "arguments": "uid uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.check_is_admin(uid uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_catalog'\nAS $function$\r\nDECLARE\r\n  result boolean;\r\nBEGIN\r\n  -- Use the materialized view instead of directly querying user_roles\r\n  SELECT EXISTS(\r\n    SELECT 1 FROM admin_users_view\r\n    WHERE user_id = uid\r\n  ) INTO result;\r\n  \r\n  RETURN result;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "check_survey_completion",
    "arguments": "p_response_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.check_survey_completion(p_response_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_required_count INTEGER;\r\n  v_answered_count INTEGER;\r\n  v_survey_id UUID;\r\nBEGIN\r\n  -- Get survey_id from response\r\n  SELECT survey_id INTO v_survey_id\r\n  FROM portal_survey_responses\r\n  WHERE id = p_response_id;\r\n  \r\n  -- Count required questions\r\n  SELECT COUNT(*) INTO v_required_count\r\n  FROM portal_survey_questions\r\n  WHERE survey_id = v_survey_id\r\n    AND required = true;\r\n  \r\n  -- Count answered required questions\r\n  SELECT COUNT(DISTINCT q.id) INTO v_answered_count\r\n  FROM portal_survey_questions q\r\n  JOIN portal_survey_answers a ON a.question_id = q.id\r\n  WHERE q.survey_id = v_survey_id\r\n    AND q.required = true\r\n    AND a.response_id = p_response_id;\r\n  \r\n  RETURN v_required_count = v_answered_count;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "clean_old_schedules",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.clean_old_schedules()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  retention_days INTEGER := 60; -- Keep 60 days of history\r\nBEGIN\r\n  -- Soft delete old schedules\r\n  UPDATE driver_schedules\r\n  SET is_deleted = true\r\n  WHERE shift_date < CURRENT_DATE - INTERVAL '1 day' * retention_days\r\n    AND is_deleted = false;\r\n  \r\n  -- Hard delete very old soft-deleted records\r\n  DELETE FROM driver_schedules\r\n  WHERE is_deleted = true\r\n    AND shift_date < CURRENT_DATE - INTERVAL '1 day' * (retention_days * 2);\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "cleanup_old_rate_limits",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.cleanup_old_rate_limits()\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    deleted_count INTEGER;\r\nBEGIN\r\n    DELETE FROM public.portal_referral_rate_limits\r\n    WHERE action_timestamp < NOW() - INTERVAL '7 days';\r\n\r\n    GET DIAGNOSTICS deleted_count = ROW_COUNT;\r\n    RETURN deleted_count;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "clear_test_responses",
    "arguments": "p_survey_id uuid, p_admin_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.clear_test_responses(p_survey_id uuid DEFAULT NULL::uuid, p_admin_id uuid DEFAULT NULL::uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  deleted_responses INTEGER;\r\n  deleted_answers INTEGER;\r\nBEGIN\r\n  -- Delete test response answers\r\n  DELETE FROM portal_survey_answers \r\n  WHERE response_id IN (\r\n    SELECT id FROM portal_survey_responses \r\n    WHERE is_test_response = true\r\n    AND (p_survey_id IS NULL OR survey_id = p_survey_id)\r\n  );\r\n  \r\n  GET DIAGNOSTICS deleted_answers = ROW_COUNT;\r\n  \r\n  -- Delete test responses\r\n  DELETE FROM portal_survey_responses \r\n  WHERE is_test_response = true\r\n  AND (p_survey_id IS NULL OR survey_id = p_survey_id);\r\n  \r\n  GET DIAGNOSTICS deleted_responses = ROW_COUNT;\r\n  \r\n  -- Log the action if admin ID provided\r\n  IF p_admin_id IS NOT NULL AND deleted_responses > 0 THEN\r\n    INSERT INTO portal_audit_log (\r\n      action, \r\n      entity_type, \r\n      entity_id, \r\n      admin_id, \r\n      details\r\n    ) VALUES (\r\n      'clear_test_responses',\r\n      'survey',\r\n      p_survey_id,\r\n      p_admin_id,\r\n      json_build_object(\r\n        'responses_deleted', deleted_responses,\r\n        'answers_deleted', deleted_answers,\r\n        'survey_specific', p_survey_id IS NOT NULL,\r\n        'cleared_at', NOW()\r\n      )\r\n    );\r\n  END IF;\r\n  \r\n  RETURN json_build_object(\r\n    'success', true,\r\n    'deleted_responses', deleted_responses,\r\n    'deleted_answers', deleted_answers\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "close_overdue_surveys",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.close_overdue_surveys()\n RETURNS integer\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  closed_count INTEGER := 0;\r\nBEGIN\r\n  UPDATE portal_surveys\r\n  SET \r\n    status = 'closed',\r\n    closed_at = NOW()\r\n  WHERE \r\n    status = 'published' \r\n    AND due_date IS NOT NULL \r\n    AND due_date < NOW()\r\n    AND status != 'closed';\r\n    \r\n  GET DIAGNOSTICS closed_count = ROW_COUNT;\r\n  \r\n  RETURN closed_count;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "count_search_contacts",
    "arguments": "search_query text, p_market_id uuid, p_station_id uuid, p_dsp_id uuid, p_status text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.count_search_contacts(search_query text, p_market_id uuid DEFAULT NULL::uuid, p_station_id uuid DEFAULT NULL::uuid, p_dsp_id uuid DEFAULT NULL::uuid, p_status text DEFAULT NULL::text)\n RETURNS integer\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n    total_count INTEGER;\r\nBEGIN\r\n    WITH contact_locations AS (\r\n      SELECT \r\n        cdl.contact_id,\r\n        STRING_AGG(DISTINCT m.name || ' - ' || s.station_code, ', ' ORDER BY m.name || ' - ' || s.station_code) as locations\r\n      FROM contact_dsp_locations cdl\r\n      INNER JOIN dsp_locations dl ON dl.id = cdl.dsp_location_id\r\n      INNER JOIN stations s ON s.id = dl.station_id\r\n      LEFT JOIN markets m ON m.id = s.market_id\r\n      WHERE dl.is_active = true\r\n      GROUP BY cdl.contact_id\r\n    )\r\n    SELECT COUNT(DISTINCT c.id) INTO total_count\r\n    FROM public.contacts c\r\n    LEFT JOIN public.dsps d ON c.dsp_id = d.id\r\n    LEFT JOIN contact_locations cl ON cl.contact_id = c.id\r\n    WHERE c.is_active = true\r\n        AND (p_market_id IS NULL OR c.market_id = p_market_id)\r\n        AND (p_station_id IS NULL OR c.station_id = p_station_id)\r\n        AND (p_dsp_id IS NULL OR c.dsp_id = p_dsp_id)\r\n        AND (p_status IS NULL OR c.contact_status = p_status)\r\n        AND (\r\n            search_query IS NULL \r\n            OR search_query = ''\r\n            OR to_tsvector('english', \r\n                coalesce(c.first_name, '') || ' ' || \r\n                coalesce(c.last_name, '') || ' ' || \r\n                coalesce(c.email, '') || ' ' ||\r\n                coalesce(c.phone, '') || ' ' ||\r\n                coalesce(c.notes, '') || ' ' ||\r\n                coalesce(d.dsp_code, '') || ' ' ||\r\n                coalesce(d.dsp_name, '') || ' ' ||\r\n                coalesce(cl.locations, '')\r\n            ) @@ plainto_tsquery('english', search_query)\r\n        );\r\n    \r\n    RETURN total_count;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "create_campaign_link",
    "arguments": "p_funnel_id uuid, p_campaign_name text, p_campaign_code text, p_notes text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_campaign_link(p_funnel_id uuid, p_campaign_name text, p_campaign_code text DEFAULT NULL::text, p_notes text DEFAULT NULL::text)\n RETURNS TABLE(link_id uuid, link_campaign_code text, link_landing_url text, link_direct_url text)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_campaign_code VARCHAR(50);\r\n  v_referral_code TEXT;\r\n  v_referral_source VARCHAR(50);\r\n  v_base_domain TEXT;\r\n  v_landing_url TEXT;\r\n  v_direct_url TEXT;\r\n  v_link_id UUID;\r\nBEGIN\r\n  -- Get funnel details (REMOVED status check - allow all statuses)\r\n  SELECT referral_code, referral_source\r\n  INTO v_referral_code, v_referral_source\r\n  FROM portal_referrals\r\n  WHERE id = p_funnel_id\r\n    AND referral_type = 'marketing';\r\n\r\n  IF v_referral_code IS NULL THEN\r\n    RAISE EXCEPTION 'Funnel not found.';\r\n  END IF;\r\n\r\n  -- Generate campaign code if not provided\r\n  IF p_campaign_code IS NULL OR p_campaign_code = '' THEN\r\n    v_campaign_code := LOWER(REGEXP_REPLACE(p_campaign_name, '[^a-zA-Z0-9]+', '-', 'g'));\r\n    v_campaign_code := TRIM(BOTH '-' FROM v_campaign_code);\r\n  ELSE\r\n    v_campaign_code := LOWER(REGEXP_REPLACE(p_campaign_code, '[^a-zA-Z0-9-]+', '-', 'g'));\r\n    v_campaign_code := TRIM(BOTH '-' FROM v_campaign_code);\r\n  END IF;\r\n\r\n  -- Ensure campaign code is unique for this funnel\r\n  WHILE EXISTS (\r\n    SELECT 1 FROM marketing_campaign_links\r\n    WHERE funnel_id = p_funnel_id\r\n      AND campaign_code = v_campaign_code\r\n  ) LOOP\r\n    v_campaign_code := v_campaign_code || '-' || SUBSTRING(MD5(RANDOM()::TEXT) FROM 1 FOR 3);\r\n  END LOOP;\r\n\r\n  -- Base domain for production\r\n  v_base_domain := 'fleetdrms.com';\r\n\r\n  -- Generate URLs with https:// protocol\r\n  -- Landing URL: Goes to the source landing page (e.g., https://foundry.fleetdrms.com?campaign=xxx)\r\n  v_landing_url := 'https://' || v_referral_source || '.' || v_base_domain || '?campaign=' || v_campaign_code;\r\n\r\n  -- Direct URL: Skips landing page, goes straight to auth\r\n  v_direct_url := 'https://portal.' || v_base_domain || '/auth?ref=' || v_referral_code || '&campaign=' || v_campaign_code;\r\n\r\n  -- Insert the campaign link\r\n  INSERT INTO marketing_campaign_links (\r\n    funnel_id,\r\n    campaign_name,\r\n    campaign_code,\r\n    landing_url,\r\n    direct_url,\r\n    notes\r\n  ) VALUES (\r\n    p_funnel_id,\r\n    p_campaign_name,\r\n    v_campaign_code,\r\n    v_landing_url,\r\n    v_direct_url,\r\n    p_notes\r\n  ) RETURNING id INTO v_link_id;\r\n\r\n  -- Return the created link info\r\n  RETURN QUERY\r\n  SELECT\r\n    v_link_id,\r\n    v_campaign_code,\r\n    v_landing_url,\r\n    v_direct_url;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "create_campaign_link",
    "arguments": "p_funnel_id uuid, p_campaign_name text, p_campaign_code character varying, p_notes text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_campaign_link(p_funnel_id uuid, p_campaign_name text, p_campaign_code character varying DEFAULT NULL::character varying, p_notes text DEFAULT NULL::text)\n RETURNS TABLE(link_id uuid, link_campaign_code character varying, link_landing_url text, link_direct_url text)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_campaign_code VARCHAR(50);\r\n  v_referral_code TEXT;\r\n  v_referral_source VARCHAR(50);\r\n  v_base_domain TEXT;\r\n  v_landing_url TEXT;\r\n  v_direct_url TEXT;\r\n  v_link_id UUID;\r\nBEGIN\r\n  -- Get funnel details\r\n  SELECT referral_code, referral_source\r\n  INTO v_referral_code, v_referral_source\r\n  FROM portal_referrals\r\n  WHERE id = p_funnel_id\r\n    AND referral_type = 'marketing'\r\n    AND status = 'sent'; -- Only allow on published funnels\r\n\r\n  IF v_referral_code IS NULL THEN\r\n    RAISE EXCEPTION 'Funnel not found or not published. Only published funnels can generate campaign links.';\r\n  END IF;\r\n\r\n  -- Generate campaign code if not provided\r\n  -- Format: lowercase, replace spaces/special chars with hyphens\r\n  IF p_campaign_code IS NULL OR p_campaign_code = '' THEN\r\n    v_campaign_code := LOWER(REGEXP_REPLACE(p_campaign_name, '[^a-zA-Z0-9]+', '-', 'g'));\r\n    v_campaign_code := TRIM(BOTH '-' FROM v_campaign_code);\r\n  ELSE\r\n    v_campaign_code := LOWER(REGEXP_REPLACE(p_campaign_code, '[^a-zA-Z0-9-]+', '-', 'g'));\r\n    v_campaign_code := TRIM(BOTH '-' FROM v_campaign_code);\r\n  END IF;\r\n\r\n  -- Ensure campaign code is unique for this funnel\r\n  WHILE EXISTS (\r\n    SELECT 1 FROM marketing_campaign_links\r\n    WHERE funnel_id = p_funnel_id\r\n      AND campaign_code = v_campaign_code\r\n  ) LOOP\r\n    -- Append a number to make it unique\r\n    v_campaign_code := v_campaign_code || '-' || SUBSTRING(MD5(RANDOM()::TEXT) FROM 1 FOR 3);\r\n  END LOOP;\r\n\r\n  -- Determine base domain (production vs localhost)\r\n  -- This will be overridden by frontend in practice, but provides a default\r\n  v_base_domain := 'fleetdrms.com';\r\n\r\n  -- Generate URLs\r\n  -- Landing URL: Goes to the source landing page (e.g., foundry.fleetdrms.com)\r\n  v_landing_url := v_referral_source || '.' || v_base_domain || '?campaign=' || v_campaign_code;\r\n\r\n  -- Direct URL: Skips landing page, goes straight to auth\r\n  v_direct_url := 'portal.' || v_base_domain || '/auth?ref=' || v_referral_code || '&campaign=' || v_campaign_code;\r\n\r\n  -- Insert the campaign link\r\n  INSERT INTO marketing_campaign_links (\r\n    funnel_id,\r\n    campaign_name,\r\n    campaign_code,\r\n    landing_url,\r\n    direct_url,\r\n    notes\r\n  ) VALUES (\r\n    p_funnel_id,\r\n    p_campaign_name,\r\n    v_campaign_code,\r\n    v_landing_url,\r\n    v_direct_url,\r\n    p_notes\r\n  ) RETURNING id INTO v_link_id;\r\n\r\n  -- Return the created link info - use different column names to avoid ambiguity\r\n  RETURN QUERY\r\n  SELECT\r\n    v_link_id,\r\n    v_campaign_code,\r\n    v_landing_url,\r\n    v_direct_url;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "create_maintenance_record_with_vehicle_update",
    "arguments": "record_data jsonb, vehicle_id uuid, severity integer",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_maintenance_record_with_vehicle_update(record_data jsonb, vehicle_id uuid, severity integer DEFAULT 1)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  new_record_id uuid;\n  current_status text;\n  record_state maintenance_state;\n  v_organization_id uuid;\nBEGIN\n  -- Log for debugging\n  RAISE NOTICE 'Creating maintenance record with data: %, vehicle_id: %, severity: %', \n               record_data, vehicle_id, severity;\n  \n  -- Set default state if not provided\n  record_state := COALESCE(\n    (record_data->>'state')::maintenance_state, \n    'in-maintenance'::maintenance_state\n  );\n  \n  -- If organization_id is not provided, get it from the vehicle\n  IF (record_data->>'organization_id') IS NULL THEN\n    SELECT organization_id INTO v_organization_id\n    FROM fleet\n    WHERE id = vehicle_id;\n    \n    IF v_organization_id IS NULL THEN\n      RAISE EXCEPTION 'Cannot find organization_id for vehicle %', vehicle_id;\n    END IF;\n  ELSE\n    v_organization_id := (record_data->>'organization_id')::uuid;\n  END IF;\n\n  -- Create the maintenance record\n  INSERT INTO maintenance_records (\n    vehicle_id,\n    organization_id,\n    issue,\n    location,\n    severity,\n    afs_eligible,\n    support_ticket,\n    maintenance_notes,\n    date_due,\n    created_by,\n    state  -- Use state instead of is_active\n  ) VALUES (\n    vehicle_id,\n    v_organization_id,\n    record_data->>'issue',\n    (record_data->>'location')::maintenance_location,\n    COALESCE((record_data->>'severity')::integer, severity),\n    record_data->>'afs_eligible',\n    CASE \n      WHEN record_data->>'support_ticket' = '' THEN NULL \n      ELSE (record_data->>'support_ticket')::integer \n    END,\n    record_data->>'maintenance_notes',\n    CASE \n      WHEN record_data->>'date_due' = '' THEN NULL \n      ELSE (record_data->>'date_due')::date \n    END,\n    COALESCE((record_data->>'created_by')::uuid, auth.uid()),\n    record_state  -- Use the new state field\n  )\n  RETURNING id INTO new_record_id;\n  \n  -- Get current vehicle status for logging purposes\n  SELECT status_maintenance::text INTO current_status\n  FROM fleet\n  WHERE id = vehicle_id;\n  \n  -- Call the update vehicle status function with status_maintenance if provided\n  IF record_data->>'status_maintenance' IS NOT NULL THEN\n    PERFORM update_vehicle_maintenance_status(vehicle_id, record_data->>'status_maintenance');\n  ELSE\n    PERFORM update_vehicle_maintenance_status(vehicle_id);\n  END IF;\n  \n  RETURN new_record_id;\nEXCEPTION\n  WHEN others THEN\n    RAISE NOTICE 'Error creating maintenance record: %', SQLERRM;\n    RAISE;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "create_maintenance_record_with_vehicle_update",
    "arguments": "record_data jsonb, vehicle_id uuid, severity integer, operational_state text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_maintenance_record_with_vehicle_update(record_data jsonb, vehicle_id uuid, severity integer DEFAULT 1, operational_state text DEFAULT NULL::text)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  new_record_id uuid;\n  v_maintenance_record_status maintenance_record_status;\n  v_organization_id uuid;\n  v_operational_state text;\nBEGIN\n  -- Store the input parameter in a variable to avoid ambiguity\n  v_operational_state := operational_state;\n  \n  -- Set default status if not provided\n  v_maintenance_record_status := COALESCE(\n    (record_data->>'maintenance_record_status')::maintenance_record_status, \n    'New Request'::maintenance_record_status\n  );\n  \n  -- If organization_id is not provided, get it from the vehicle\n  IF (record_data->>'organization_id') IS NULL THEN\n    SELECT organization_id INTO v_organization_id\n    FROM fleet\n    WHERE id = vehicle_id;\n    \n    IF v_organization_id IS NULL THEN\n      RAISE EXCEPTION 'Cannot find organization_id for vehicle %', vehicle_id;\n    END IF;\n  ELSE\n    v_organization_id := (record_data->>'organization_id')::uuid;\n  END IF;\n\n  -- Create the maintenance record\n  INSERT INTO maintenance_records (\n    vehicle_id,\n    organization_id,\n    issue_title,\n    issue,\n    location,\n    severity,\n    afs_eligible,\n    support_ticket,\n    maintenance_notes,\n    date_due,\n    created_by,\n    maintenance_record_status,\n    assignee\n  ) VALUES (\n    vehicle_id,\n    v_organization_id,\n    record_data->>'issue_title',\n    record_data->>'issue',\n    (record_data->>'location')::maintenance_location,\n    COALESCE((record_data->>'severity')::integer, severity),\n    record_data->>'afs_eligible',\n    CASE \n      WHEN record_data->>'support_ticket' = '' THEN NULL \n      ELSE (record_data->>'support_ticket')::integer \n    END,\n    record_data->>'maintenance_notes',\n    CASE \n      WHEN record_data->>'date_due' = '' THEN NULL \n      ELSE (record_data->>'date_due')::date \n    END,\n    COALESCE((record_data->>'created_by')::uuid, auth.uid()),\n    v_maintenance_record_status,\n    (record_data->>'assignee')::uuid\n  )\n  RETURNING id INTO new_record_id;\n  \n  -- Call the update vehicle operational state function\n  IF v_operational_state IS NOT NULL THEN\n    PERFORM update_vehicle_operational_state(vehicle_id, v_operational_state);\n  ELSE\n    -- Set operational state based on new maintenance record\n    PERFORM update_vehicle_operational_state(vehicle_id, 'Grounded');\n  END IF;\n  \n  -- Insert the initial status history record\n  INSERT INTO maintenance_status_history (\n    maintenance_record_id,\n    previous_status,\n    new_status,\n    changed_by\n  ) VALUES (\n    new_record_id,\n    NULL,\n    v_maintenance_record_status,\n    COALESCE((record_data->>'created_by')::uuid, auth.uid())\n  );\n  \n  RETURN new_record_id;\nEXCEPTION\n  WHEN others THEN\n    RAISE NOTICE 'Error creating maintenance record: %', SQLERRM;\n    RAISE;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "create_marketing_funnel",
    "arguments": "p_source character varying, p_source_name text, p_metadata jsonb, p_max_uses integer, p_expires_at timestamp with time zone",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_marketing_funnel(p_source character varying, p_source_name text, p_metadata jsonb DEFAULT NULL::jsonb, p_max_uses integer DEFAULT NULL::integer, p_expires_at timestamp with time zone DEFAULT NULL::timestamp with time zone)\n RETURNS TABLE(funnel_id uuid, funnel_code text, funnel_source character varying)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_system_user_id UUID;\r\n  v_referral_code TEXT;\r\n  v_referral_id UUID;\r\nBEGIN\r\n  -- Get system user ID\r\n  SELECT profiles.id INTO v_system_user_id\r\n  FROM profiles\r\n  WHERE email = 'portal@fleetdrms.com'\r\n  LIMIT 1;\r\n\r\n  IF v_system_user_id IS NULL THEN\r\n    RAISE EXCEPTION 'System user (portal@fleetdrms.com) not found';\r\n  END IF;\r\n\r\n  -- Generate unique referral code\r\n  -- Format: First 6 chars of source (uppercase) + 4 random chars\r\n  v_referral_code := UPPER(\r\n    SUBSTRING(REGEXP_REPLACE(p_source, '[^a-zA-Z0-9]', '', 'g') FROM 1 FOR 6) ||\r\n    SUBSTRING(MD5(RANDOM()::TEXT) FROM 1 FOR 4)\r\n  );\r\n\r\n  -- Ensure uniqueness\r\n  WHILE EXISTS (SELECT 1 FROM portal_referrals WHERE referral_code = v_referral_code) LOOP\r\n    v_referral_code := UPPER(\r\n      SUBSTRING(REGEXP_REPLACE(p_source, '[^a-zA-Z0-9]', '', 'g') FROM 1 FOR 6) ||\r\n      SUBSTRING(MD5(RANDOM()::TEXT) FROM 1 FOR 4)\r\n    );\r\n  END LOOP;\r\n\r\n  -- Create the marketing funnel referral\r\n  INSERT INTO portal_referrals (\r\n    referrer_id,\r\n    referral_code,\r\n    referral_type,\r\n    referral_source,\r\n    is_reusable,\r\n    usage_count,\r\n    max_uses,\r\n    source_metadata,\r\n    expires_at,\r\n    status,\r\n    created_at,\r\n    referee_email,\r\n    referee_first_name,\r\n    referee_last_name\r\n  ) VALUES (\r\n    v_system_user_id,\r\n    v_referral_code,\r\n    'marketing',\r\n    p_source,\r\n    true,\r\n    0,\r\n    p_max_uses,\r\n    COALESCE(p_metadata, '{}'::jsonb) || jsonb_build_object('source_name', p_source_name),\r\n    p_expires_at,\r\n    'pending',\r\n    NOW(),\r\n    '',\r\n    '',\r\n    ''\r\n  ) RETURNING id INTO v_referral_id;\r\n\r\n  -- Return the created referral info\r\n  -- Using only variable names without aliases to avoid ambiguity\r\n  RETURN QUERY\r\n  SELECT\r\n    v_referral_id,\r\n    v_referral_code,\r\n    p_source;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "decrypt_credentials",
    "arguments": "p_encrypted bytea, p_key text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.decrypt_credentials(p_encrypted bytea, p_key text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  RETURN pgp_sym_decrypt(p_encrypted, p_key)::JSONB;\r\nEXCEPTION\r\n  WHEN OTHERS THEN\r\n    RETURN NULL;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "delete_campaign_link",
    "arguments": "p_link_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.delete_campaign_link(p_link_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  DELETE FROM marketing_campaign_links\r\n  WHERE id = p_link_id;\r\n\r\n  RETURN FOUND;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "delete_maintenance_document_file",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.delete_maintenance_document_file()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_catalog', 'storage'\nAS $function$\r\nBEGIN\r\n  PERFORM storage.delete_object('maintenance_documents', OLD.file_path);\r\n  RETURN OLD;\r\nEXCEPTION\r\n  WHEN OTHERS THEN\r\n    RAISE NOTICE 'Failed to delete file from storage: %', SQLERRM;\r\n    RETURN OLD;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "delete_survey_complete",
    "arguments": "p_survey_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.delete_survey_complete(p_survey_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  -- Delete all survey answers first (foreign key constraint)\r\n  DELETE FROM portal_survey_answers \r\n  WHERE response_id IN (\r\n    SELECT id FROM portal_survey_responses \r\n    WHERE survey_id = p_survey_id\r\n  );\r\n  \r\n  -- Delete all survey responses\r\n  DELETE FROM portal_survey_responses \r\n  WHERE survey_id = p_survey_id;\r\n  \r\n  -- Delete all survey questions\r\n  DELETE FROM portal_survey_questions \r\n  WHERE survey_id = p_survey_id;\r\n  \r\n  -- Finally delete the survey itself\r\n  DELETE FROM portal_surveys \r\n  WHERE id = p_survey_id;\r\n  \r\n  RETURN TRUE;\r\nEXCEPTION\r\n  WHEN OTHERS THEN\r\n    RAISE EXCEPTION 'Failed to delete survey: %', SQLERRM;\r\n    RETURN FALSE;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "delete_survey_force",
    "arguments": "p_survey_id uuid, p_confirm_title text, p_admin_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.delete_survey_force(p_survey_id uuid, p_confirm_title text, p_admin_id uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  actual_title TEXT;\r\n  deleted_responses INTEGER;\r\n  deleted_questions INTEGER;\r\n  deleted_answers INTEGER;\r\n  result JSON;\r\nBEGIN\r\n  -- Get actual survey title\r\n  SELECT title INTO actual_title \r\n  FROM portal_surveys \r\n  WHERE id = p_survey_id;\r\n  \r\n  -- Check if survey exists\r\n  IF actual_title IS NULL THEN\r\n    RAISE EXCEPTION 'Survey not found';\r\n  END IF;\r\n  \r\n  -- Verify title matches exactly (case-sensitive)\r\n  IF actual_title != p_confirm_title THEN\r\n    RAISE EXCEPTION 'Title confirmation does not match. Expected: %, Got: %', actual_title, p_confirm_title;\r\n  END IF;\r\n  \r\n  -- Count what we're deleting for audit trail\r\n  SELECT COUNT(*) INTO deleted_responses \r\n  FROM portal_survey_responses \r\n  WHERE survey_id = p_survey_id;\r\n  \r\n  SELECT COUNT(*) INTO deleted_questions \r\n  FROM portal_survey_questions \r\n  WHERE survey_id = p_survey_id;\r\n  \r\n  SELECT COUNT(*) INTO deleted_answers\r\n  FROM portal_survey_answers \r\n  WHERE response_id IN (\r\n    SELECT id FROM portal_survey_responses \r\n    WHERE survey_id = p_survey_id\r\n  );\r\n  \r\n  -- Delete in correct order (foreign key constraints)\r\n  DELETE FROM portal_survey_answers \r\n  WHERE response_id IN (\r\n    SELECT id FROM portal_survey_responses \r\n    WHERE survey_id = p_survey_id\r\n  );\r\n  \r\n  DELETE FROM portal_survey_responses \r\n  WHERE survey_id = p_survey_id;\r\n  \r\n  DELETE FROM portal_survey_questions \r\n  WHERE survey_id = p_survey_id;\r\n  \r\n  DELETE FROM portal_surveys \r\n  WHERE id = p_survey_id;\r\n  \r\n  -- Create audit log entry\r\n  INSERT INTO portal_audit_log (\r\n    action, \r\n    entity_type, \r\n    entity_id, \r\n    admin_id, \r\n    details\r\n  ) VALUES (\r\n    'force_delete_survey',\r\n    'survey',\r\n    p_survey_id,\r\n    p_admin_id,\r\n    json_build_object(\r\n      'title', actual_title,\r\n      'responses_deleted', deleted_responses,\r\n      'questions_deleted', deleted_questions,\r\n      'answers_deleted', deleted_answers,\r\n      'deleted_at', NOW()\r\n    )\r\n  );\r\n  \r\n  result := json_build_object(\r\n    'success', true,\r\n    'title', actual_title,\r\n    'deleted_responses', deleted_responses,\r\n    'deleted_questions', deleted_questions,\r\n    'deleted_answers', deleted_answers\r\n  );\r\n  \r\n  RETURN result;\r\nEXCEPTION\r\n  WHEN OTHERS THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', SQLERRM\r\n    );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "delete_update_force",
    "arguments": "p_update_id uuid, p_confirm_title text, p_admin_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.delete_update_force(p_update_id uuid, p_confirm_title text, p_admin_id uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  actual_title TEXT;\r\n  update_status TEXT;\r\n  update_type TEXT;\r\n  acknowledgment_count INTEGER := 0;\r\nBEGIN\r\n  -- Get actual update title and details\r\n  SELECT title, status, COALESCE(type, 'general') INTO actual_title, update_status, update_type\r\n  FROM portal_updates \r\n  WHERE id = p_update_id;\r\n  \r\n  -- Check if update exists\r\n  IF actual_title IS NULL THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'Update not found'\r\n    );\r\n  END IF;\r\n  \r\n  -- Verify title matches exactly (case-sensitive)\r\n  IF actual_title != p_confirm_title THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', format('Title confirmation does not match. Expected: %s, Got: %s', actual_title, p_confirm_title)\r\n    );\r\n  END IF;\r\n  \r\n  -- Check for acknowledgments if compulsory update\r\n  IF update_type = 'compulsory' THEN\r\n    -- Check if acknowledgments table exists\r\n    IF EXISTS (\r\n      SELECT 1 FROM information_schema.tables \r\n      WHERE table_name = 'compulsory_updates_acknowledgments'\r\n    ) THEN\r\n      EXECUTE 'SELECT COUNT(*) FROM compulsory_updates_acknowledgments WHERE update_id = $1'\r\n      INTO acknowledgment_count\r\n      USING p_update_id;\r\n    END IF;\r\n  END IF;\r\n  \r\n  -- Delete any acknowledgments first (if table exists)\r\n  IF EXISTS (\r\n    SELECT 1 FROM information_schema.tables \r\n    WHERE table_name = 'compulsory_updates_acknowledgments'\r\n  ) THEN\r\n    EXECUTE 'DELETE FROM compulsory_updates_acknowledgments WHERE update_id = $1'\r\n    USING p_update_id;\r\n  END IF;\r\n  \r\n  -- Delete the update\r\n  DELETE FROM portal_updates WHERE id = p_update_id;\r\n  \r\n  -- Create audit log entry\r\n  INSERT INTO portal_audit_log (\r\n    action, \r\n    entity_type, \r\n    entity_id, \r\n    admin_id, \r\n    details\r\n  ) VALUES (\r\n    'force_delete_update',\r\n    'update',\r\n    p_update_id,\r\n    p_admin_id,\r\n    json_build_object(\r\n      'title', actual_title,\r\n      'status', update_status,\r\n      'type', update_type,\r\n      'acknowledgments_deleted', acknowledgment_count,\r\n      'deleted_at', NOW()\r\n    )\r\n  );\r\n  \r\n  RETURN json_build_object(\r\n    'success', true,\r\n    'title', actual_title,\r\n    'acknowledgments_deleted', acknowledgment_count\r\n  );\r\nEXCEPTION\r\n  WHEN OTHERS THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', SQLERRM\r\n    );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "dev_set_temp_password",
    "arguments": "user_email text, new_password text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.dev_set_temp_password(user_email text, new_password text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  RETURN admin_reset_password(user_email, new_password);\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "dismiss_update",
    "arguments": "p_update_id uuid, p_user_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.dismiss_update(p_update_id uuid, p_user_id uuid)\n RETURNS void\n LANGUAGE sql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\n    -- Insert or update the read record with dismissed status\r\n    INSERT INTO public.portal_update_reads (\r\n        update_id, \r\n        user_id, \r\n        first_viewed_at,\r\n        last_viewed_at,\r\n        dismissed_at\r\n    )\r\n    VALUES (\r\n        p_update_id, \r\n        p_user_id, \r\n        NOW(),\r\n        NOW(),\r\n        NOW()\r\n    )\r\n    ON CONFLICT (update_id, user_id) \r\n    DO UPDATE SET\r\n        dismissed_at = NOW(),\r\n        last_viewed_at = NOW();\r\n        \r\n    -- Update dismissal count on the update\r\n    UPDATE public.portal_updates \r\n    SET dismissal_count = COALESCE(dismissal_count, 0) + 1\r\n    WHERE id = p_update_id;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "encrypt_credentials",
    "arguments": "p_credentials jsonb, p_key text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.encrypt_credentials(p_credentials jsonb, p_key text)\n RETURNS bytea\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  RETURN pgp_sym_encrypt(\r\n    p_credentials::TEXT,\r\n    p_key,\r\n    'compress-algo=2, cipher-algo=aes256'\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "ensure_admin_roles",
    "arguments": "user_email text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.ensure_admin_roles(user_email text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n    v_user_id uuid;\r\n    v_existing_roles text[];\r\n    v_added_roles text[] := ARRAY[]::text[];\r\nBEGIN\r\n    -- Get user ID\r\n    SELECT id INTO v_user_id\r\n    FROM profiles\r\n    WHERE lower(email) = lower(user_email);\r\n    \r\n    IF v_user_id IS NULL THEN\r\n        RETURN json_build_object(\r\n            'success', false,\r\n            'error', 'User not found'\r\n        );\r\n    END IF;\r\n    \r\n    -- Get existing roles as text array\r\n    SELECT array_agg(role::text) INTO v_existing_roles\r\n    FROM user_roles\r\n    WHERE user_id = v_user_id;\r\n    \r\n    -- Add admin role if not present\r\n    IF v_existing_roles IS NULL OR NOT ('admin' = ANY(v_existing_roles)) THEN\r\n        INSERT INTO user_roles (user_id, role, created_at)\r\n        VALUES (v_user_id, 'admin'::app_role, NOW())\r\n        ON CONFLICT (user_id, role) DO NOTHING;\r\n        v_added_roles := array_append(v_added_roles, 'admin');\r\n    END IF;\r\n    \r\n    -- Add super_admin role if email suggests it or if requested\r\n    IF (user_email LIKE '%admin%' OR user_email LIKE '%super%') \r\n        AND (v_existing_roles IS NULL OR NOT ('super_admin' = ANY(v_existing_roles))) THEN\r\n        INSERT INTO user_roles (user_id, role, created_at)\r\n        VALUES (v_user_id, 'super_admin'::app_role, NOW())\r\n        ON CONFLICT (user_id, role) DO NOTHING;\r\n        v_added_roles := array_append(v_added_roles, 'super_admin');\r\n    END IF;\r\n    \r\n    RETURN json_build_object(\r\n        'success', true,\r\n        'user_id', v_user_id,\r\n        'email', user_email,\r\n        'existing_roles', CASE \r\n            WHEN v_existing_roles IS NULL THEN ARRAY[]::text[]\r\n            ELSE v_existing_roles\r\n        END,\r\n        'added_roles', v_added_roles,\r\n        'message', CASE \r\n            WHEN array_length(v_added_roles, 1) > 0 THEN \r\n                'Roles added: ' || array_to_string(v_added_roles, ', ')\r\n            ELSE \r\n                'User already has admin roles'\r\n        END\r\n    );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "ensure_primary_business",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.ensure_primary_business()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  -- If this is the first business for a user, make it primary\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM public.businesses \r\n    WHERE user_id = NEW.user_id \r\n    AND id != COALESCE(NEW.id, gen_random_uuid())\r\n  ) THEN\r\n    NEW.is_primary := TRUE;\r\n  END IF;\r\n  \r\n  -- If setting this as primary, unset others\r\n  IF NEW.is_primary = TRUE THEN\r\n    UPDATE public.businesses \r\n    SET is_primary = FALSE \r\n    WHERE user_id = NEW.user_id \r\n    AND id != NEW.id;\r\n  END IF;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "export_event_registrations",
    "arguments": "event_uuid uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.export_event_registrations(event_uuid uuid)\n RETURNS TABLE(registration_id uuid, user_email text, user_name text, company_name text, registration_date timestamp with time zone, attendance_status character varying, payment_status character varying, check_in_time timestamp with time zone, notes text)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  -- Check if user is admin\r\n  IF NOT is_portal_admin(auth.uid()) THEN\r\n    RAISE EXCEPTION 'Unauthorized: Admin access required';\r\n  END IF;\r\n\r\n  RETURN QUERY\r\n  SELECT \r\n    r.id as registration_id,\r\n    p.email as user_email,\r\n    p.full_name as user_name,\r\n    p.company_name,\r\n    r.registration_date,\r\n    r.attendance_status,\r\n    r.payment_status,\r\n    r.check_in_time,\r\n    r.notes\r\n  FROM public.portal_event_registrations r\r\n  JOIN public.profiles p ON p.id = r.user_id\r\n  WHERE r.event_id = event_uuid\r\n  ORDER BY r.registration_date;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "export_survey_responses",
    "arguments": "survey_uuid uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.export_survey_responses(survey_uuid uuid)\n RETURNS TABLE(response_id uuid, user_email text, user_name text, started_at timestamp with time zone, completed_at timestamp with time zone, is_complete boolean, question_text text, answer_text text, answer_options jsonb)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  -- Check if user is admin\r\n  IF NOT is_portal_admin(auth.uid()) THEN\r\n    RAISE EXCEPTION 'Unauthorized: Admin access required';\r\n  END IF;\r\n\r\n  RETURN QUERY\r\n  SELECT \r\n    r.id as response_id,\r\n    p.email as user_email,\r\n    p.full_name as user_name,\r\n    r.started_at,\r\n    r.completed_at,\r\n    r.is_complete,\r\n    q.question_text,\r\n    a.answer_text,\r\n    a.answer_options\r\n  FROM public.portal_survey_responses r\r\n  LEFT JOIN public.profiles p ON p.id = r.user_id\r\n  JOIN public.portal_survey_answers a ON a.response_id = r.id\r\n  JOIN public.portal_survey_questions q ON q.id = a.question_id\r\n  WHERE r.survey_id = survey_uuid\r\n  ORDER BY r.started_at, q.display_order;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "generate_event_slug",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.generate_event_slug()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  IF NEW.slug IS NULL OR NEW.slug = '' THEN\r\n    -- Use start_datetime if available, otherwise use NOW()\r\n    NEW.slug := generate_slug(NEW.title) || '-' || TO_CHAR(COALESCE(NEW.start_datetime, NOW()), 'YYYY-MM-DD');\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "generate_slug",
    "arguments": "title text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.generate_slug(title text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  RETURN LOWER(\r\n    REGEXP_REPLACE(\r\n      REGEXP_REPLACE(title, '[^a-zA-Z0-9\\s-]', '', 'g'),\r\n      '\\s+', '-', 'g'\r\n    )\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_active_impersonations",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_active_impersonations()\n RETURNS TABLE(id uuid, admin_id uuid, impersonated_user_id uuid, started_at timestamp with time zone, admin_email text, impersonated_email text)\n LANGUAGE plpgsql\n SET search_path TO 'public', 'pg_catalog'\nAS $function$\r\nBEGIN\r\n    -- Only admins can see impersonations\r\n    IF NOT EXISTS (\r\n        SELECT 1 FROM user_roles \r\n        WHERE user_id = auth.uid() \r\n        AND role IN ('admin', 'super_admin', 'developer')\r\n    ) THEN\r\n        RETURN; -- Return empty set for non-admins\r\n    END IF;\r\n\r\n    RETURN QUERY\r\n    SELECT \r\n        i.id,\r\n        i.admin_id,\r\n        i.impersonated_user_id,\r\n        i.started_at,\r\n        a.email AS admin_email,\r\n        p.email AS impersonated_email\r\n    FROM impersonation_sessions i\r\n    JOIN profiles a ON a.id = i.admin_id\r\n    JOIN profiles p ON p.id = i.impersonated_user_id\r\n    WHERE i.ended_at IS NULL;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_all_permissions",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_all_permissions()\n RETURNS TABLE(id uuid, name text, resource text, action text, description text, scope text)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_catalog'\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT \r\n    p.id,\r\n    p.name,\r\n    p.resource,\r\n    p.action,\r\n    p.description,\r\n    p.scope\r\n  FROM permissions p\r\n  ORDER BY p.resource, p.action;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_contact_analytics",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_contact_analytics()\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n    v_result JSONB;\r\nBEGIN\r\n    SELECT jsonb_build_object(\r\n        'summary', (\r\n            SELECT jsonb_build_object(\r\n                'total_contacts', COUNT(DISTINCT c.id),\r\n                'total_markets', COUNT(DISTINCT m.id),\r\n                'total_stations', COUNT(DISTINCT s.id),\r\n                'total_dsps', COUNT(DISTINCT d.id),\r\n                'total_interactions', COUNT(DISTINCT i.id)\r\n            )\r\n            FROM public.contacts c\r\n            LEFT JOIN public.markets m ON m.is_active = true\r\n            LEFT JOIN public.stations s ON s.is_active = true\r\n            LEFT JOIN public.dsps d ON d.is_active = true\r\n            LEFT JOIN public.interactions i ON true\r\n            WHERE c.is_active = true\r\n        ),\r\n        'contacts_by_status', (\r\n            SELECT jsonb_object_agg(\r\n                COALESCE(contact_status, 'unknown'), \r\n                count\r\n            )\r\n            FROM (\r\n                SELECT contact_status, COUNT(*) as count\r\n                FROM public.contacts\r\n                WHERE is_active = true\r\n                GROUP BY contact_status\r\n            ) t\r\n        ),\r\n        'contacts_by_title', (\r\n            SELECT jsonb_object_agg(\r\n                COALESCE(title::text, 'none'), \r\n                count\r\n            )\r\n            FROM (\r\n                SELECT title, COUNT(*) as count\r\n                FROM public.contacts\r\n                WHERE is_active = true\r\n                GROUP BY title\r\n            ) t\r\n        ),\r\n        'interactions_by_type', (\r\n            SELECT jsonb_object_agg(\r\n                interaction_type::text, \r\n                count\r\n            )\r\n            FROM (\r\n                SELECT interaction_type, COUNT(*) as count\r\n                FROM public.interactions\r\n                GROUP BY interaction_type\r\n            ) t\r\n        ),\r\n        'recent_activity', (\r\n            SELECT jsonb_agg(\r\n                jsonb_build_object(\r\n                    'date', date,\r\n                    'new_contacts', new_contacts,\r\n                    'interactions', interactions\r\n                )\r\n                ORDER BY date DESC\r\n            )\r\n            FROM (\r\n                SELECT \r\n                    d.date,\r\n                    COALESCE(c.count, 0) as new_contacts,\r\n                    COALESCE(i.count, 0) as interactions\r\n                FROM (\r\n                    SELECT generate_series(\r\n                        CURRENT_DATE - INTERVAL '29 days',\r\n                        CURRENT_DATE,\r\n                        '1 day'::interval\r\n                    )::date as date\r\n                ) d\r\n                LEFT JOIN (\r\n                    SELECT DATE(created_at) as date, COUNT(*) as count\r\n                    FROM public.contacts\r\n                    WHERE is_active = true\r\n                    GROUP BY DATE(created_at)\r\n                ) c ON d.date = c.date\r\n                LEFT JOIN (\r\n                    SELECT DATE(interaction_date) as date, COUNT(*) as count\r\n                    FROM public.interactions\r\n                    GROUP BY DATE(interaction_date)\r\n                ) i ON d.date = i.date\r\n                ORDER BY d.date DESC\r\n                LIMIT 30\r\n            ) t\r\n        ),\r\n        'conversion_funnel', (\r\n            WITH status_counts AS (\r\n                SELECT \r\n                    COUNT(*) FILTER (WHERE contact_status = 'new') as new_count,\r\n                    COUNT(*) FILTER (WHERE contact_status = 'contacted') as contacted_count,\r\n                    COUNT(*) FILTER (WHERE contact_status = 'qualified') as qualified_count,\r\n                    COUNT(*) FILTER (WHERE contact_status = 'active') as active_count\r\n                FROM public.contacts\r\n                WHERE is_active = true\r\n            )\r\n            SELECT jsonb_build_object(\r\n                'new', new_count,\r\n                'contacted', contacted_count,\r\n                'qualified', qualified_count,\r\n                'active', active_count,\r\n                'new_to_contacted', \r\n                    CASE WHEN new_count > 0 \r\n                    THEN ROUND((contacted_count::numeric / new_count::numeric) * 100, 2) \r\n                    ELSE 0 END,\r\n                'contacted_to_qualified', \r\n                    CASE WHEN contacted_count > 0 \r\n                    THEN ROUND((qualified_count::numeric / contacted_count::numeric) * 100, 2) \r\n                    ELSE 0 END,\r\n                'qualified_to_active', \r\n                    CASE WHEN qualified_count > 0 \r\n                    THEN ROUND((active_count::numeric / qualified_count::numeric) * 100, 2) \r\n                    ELSE 0 END\r\n            )\r\n            FROM status_counts\r\n        )\r\n    ) INTO v_result;\r\n    \r\n    RETURN v_result;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_contact_full_name",
    "arguments": "p_first_name text, p_last_name text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_contact_full_name(p_first_name text, p_last_name text)\n RETURNS text\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\r\nBEGIN\r\n    IF p_first_name IS NOT NULL AND p_last_name IS NOT NULL THEN\r\n        RETURN p_first_name || ' ' || p_last_name;\r\n    ELSIF p_first_name IS NOT NULL THEN\r\n        RETURN p_first_name;\r\n    ELSIF p_last_name IS NOT NULL THEN\r\n        RETURN p_last_name;\r\n    ELSE\r\n        RETURN 'Unknown Contact';\r\n    END IF;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_contact_identifier",
    "arguments": "p_first_name text, p_last_name text, p_email text, p_phone text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_contact_identifier(p_first_name text, p_last_name text, p_email text, p_phone text)\n RETURNS text\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\r\nBEGIN\r\n    IF p_email IS NOT NULL THEN\r\n        RETURN COALESCE(get_contact_full_name(p_first_name, p_last_name) || ' - ', '') || p_email;\r\n    ELSIF p_phone IS NOT NULL THEN\r\n        RETURN COALESCE(get_contact_full_name(p_first_name, p_last_name) || ' - ', '') || p_phone;\r\n    ELSE\r\n        RETURN get_contact_full_name(p_first_name, p_last_name);\r\n    END IF;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_contact_submission_stats",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_contact_submission_stats()\n RETURNS TABLE(total_submissions bigint, new_submissions bigint, in_progress_submissions bigint, resolved_submissions bigint, submissions_today bigint, submissions_this_week bigint, submissions_this_month bigint)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT\r\n    COUNT(*) AS total_submissions,\r\n    COUNT(*) FILTER (WHERE status = 'new') AS new_submissions,\r\n    COUNT(*) FILTER (WHERE status = 'in_progress') AS in_progress_submissions,\r\n    COUNT(*) FILTER (WHERE status = 'resolved') AS resolved_submissions,\r\n    COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE) AS submissions_today,\r\n    COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE - INTERVAL '7 days') AS submissions_this_week,\r\n    COUNT(*) FILTER (WHERE created_at >= DATE_TRUNC('month', CURRENT_DATE)) AS submissions_this_month\r\n  FROM public.contact_submissions;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_dsp_contacts",
    "arguments": "p_dsp_id uuid, p_location_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_dsp_contacts(p_dsp_id uuid, p_location_id uuid DEFAULT NULL::uuid)\n RETURNS TABLE(contact_id uuid, first_name character varying, last_name character varying, email character varying, phone character varying, title contact_title_enum, location_ids uuid[], location_names text[])\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT \r\n    c.id as contact_id,\r\n    c.first_name,\r\n    c.last_name,\r\n    c.email,\r\n    c.phone,\r\n    c.title,\r\n    ARRAY_AGG(DISTINCT dl.id) as location_ids,\r\n    ARRAY_AGG(DISTINCT m.name || ' - ' || s.station_code ORDER BY m.name || ' - ' || s.station_code) as location_names\r\n  FROM contacts c\r\n  INNER JOIN contact_dsp_locations cdl ON cdl.contact_id = c.id\r\n  INNER JOIN dsp_locations dl ON dl.id = cdl.dsp_location_id\r\n  INNER JOIN stations s ON s.id = dl.station_id\r\n  LEFT JOIN markets m ON m.id = s.market_id\r\n  WHERE dl.dsp_id = p_dsp_id\r\n    AND dl.is_active = true\r\n    AND c.is_active = true\r\n    AND (p_location_id IS NULL OR dl.id = p_location_id)\r\n  GROUP BY c.id, c.first_name, c.last_name, c.email, c.phone, c.title\r\n  ORDER BY c.last_name, c.first_name;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_dsp_locations",
    "arguments": "p_dsp_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_dsp_locations(p_dsp_id uuid)\n RETURNS TABLE(location_id uuid, station_id uuid, station_code character varying, market_id uuid, market_name character varying, is_primary boolean, is_active boolean)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT \r\n    dl.id as location_id,\r\n    s.id as station_id,\r\n    s.station_code,\r\n    m.id as market_id,\r\n    m.name as market_name,\r\n    dl.is_primary,\r\n    dl.is_active\r\n  FROM dsp_locations dl\r\n  INNER JOIN stations s ON s.id = dl.station_id\r\n  LEFT JOIN markets m ON m.id = s.market_id\r\n  WHERE dl.dsp_id = p_dsp_id\r\n    AND dl.is_active = true\r\n  ORDER BY dl.is_primary DESC, m.name, s.station_code;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_event_with_registration",
    "arguments": "event_uuid uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_event_with_registration(event_uuid uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  event_data JSON;\r\nBEGIN\r\n  SELECT json_build_object(\r\n    'event', row_to_json(e),\r\n    'registration_count', (\r\n      SELECT COUNT(*) \r\n      FROM public.portal_event_registrations \r\n      WHERE event_id = event_uuid\r\n      AND attendance_status IN ('registered', 'attended')\r\n    ),\r\n    'spots_remaining', CASE\r\n      WHEN e.registration_limit IS NULL THEN NULL\r\n      ELSE GREATEST(0, e.registration_limit - (\r\n        SELECT COUNT(*) \r\n        FROM public.portal_event_registrations \r\n        WHERE event_id = event_uuid\r\n        AND attendance_status IN ('registered', 'attended')\r\n      ))\r\n    END,\r\n    'user_registration', (\r\n      SELECT row_to_json(r)\r\n      FROM public.portal_event_registrations r\r\n      WHERE r.event_id = event_uuid\r\n      AND r.user_id = auth.uid()\r\n      LIMIT 1\r\n    )\r\n  )\r\n  FROM public.portal_events e\r\n  WHERE e.id = event_uuid\r\n  INTO event_data;\r\n\r\n  RETURN event_data;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_filtered_maintenance_records",
    "arguments": "p_organization_id uuid, p_include_all_orgs boolean",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_filtered_maintenance_records(p_organization_id uuid, p_include_all_orgs boolean DEFAULT false)\n RETURNS SETOF maintenance_records\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_catalog'\nAS $function$\r\nBEGIN\r\n  -- For admin requesting all orgs\r\n  IF p_include_all_orgs AND EXISTS (\r\n    SELECT 1 FROM user_roles \r\n    WHERE user_id = auth.uid() \r\n    AND role IN ('admin', 'super_admin', 'developer')\r\n  ) THEN\r\n    RETURN QUERY\r\n    SELECT * FROM maintenance_records;\r\n    RETURN;\r\n  END IF;\r\n  \r\n  -- If specific organization requested, verify access first\r\n  IF p_organization_id IS NOT NULL THEN\r\n    -- Check admin status directly\r\n    IF EXISTS (\r\n      SELECT 1 FROM user_roles \r\n      WHERE user_id = auth.uid() \r\n      AND role IN ('admin', 'super_admin', 'developer')\r\n    ) THEN\r\n      -- Admin can access any organization\r\n      RETURN QUERY\r\n      SELECT * FROM maintenance_records\r\n      WHERE organization_id = p_organization_id;\r\n      RETURN;\r\n    END IF;\r\n    \r\n    -- For owner role, check if organization matches\r\n    IF EXISTS (\r\n      SELECT 1 FROM user_roles \r\n      WHERE user_id = auth.uid() \r\n      AND role = 'owner'\r\n    ) THEN\r\n      -- Get user's organization - direct query to avoid RLS\r\n      DECLARE\r\n        v_user_org_id uuid;\r\n      BEGIN\r\n        SELECT organization_id INTO v_user_org_id\r\n        FROM profiles\r\n        WHERE id = auth.uid();\r\n        \r\n        -- Only allow if organization matches\r\n        IF v_user_org_id = p_organization_id THEN\r\n          RETURN QUERY\r\n          SELECT * FROM maintenance_records\r\n          WHERE organization_id = p_organization_id;\r\n        ELSE\r\n          -- No access, return empty set\r\n          RETURN;\r\n        END IF;\r\n        \r\n        RETURN;\r\n      END;\r\n    END IF;\r\n    \r\n    -- For all other users, check if organization matches\r\n    DECLARE\r\n      v_user_org_id uuid;\r\n    BEGIN\r\n      SELECT organization_id INTO v_user_org_id\r\n      FROM profiles\r\n      WHERE id = auth.uid();\r\n      \r\n      IF v_user_org_id = p_organization_id THEN\r\n        RETURN QUERY\r\n        SELECT * FROM maintenance_records\r\n        WHERE organization_id = p_organization_id;\r\n      ELSE\r\n        -- No access, return empty set\r\n        RETURN;\r\n      END IF;\r\n      \r\n      RETURN;\r\n    END;\r\n  END IF;\r\n  \r\n  -- If no specific org requested, use user's organization\r\n  DECLARE\r\n    v_user_org_id uuid;\r\n    v_is_admin boolean;\r\n  BEGIN\r\n    -- Check admin status directly\r\n    SELECT EXISTS (\r\n      SELECT 1 FROM user_roles \r\n      WHERE user_id = auth.uid() \r\n      AND role IN ('admin', 'super_admin', 'developer')\r\n    ) INTO v_is_admin;\r\n    \r\n    -- Admin with no specific organization sees all\r\n    IF v_is_admin THEN\r\n      RETURN QUERY\r\n      SELECT * FROM maintenance_records;\r\n      RETURN;\r\n    END IF;\r\n    \r\n    -- Non-admin users see only their organization\r\n    SELECT organization_id INTO v_user_org_id\r\n    FROM profiles\r\n    WHERE id = auth.uid();\r\n    \r\n    RETURN QUERY\r\n    SELECT * FROM maintenance_records\r\n    WHERE organization_id = v_user_org_id;\r\n    RETURN;\r\n  END;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_fleet_vehicles_with_context",
    "arguments": "p_organization_id uuid, p_search_term text, p_operational_state text, p_dev_user_email text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_fleet_vehicles_with_context(p_organization_id uuid DEFAULT NULL::uuid, p_search_term text DEFAULT NULL::text, p_operational_state text DEFAULT NULL::text, p_dev_user_email text DEFAULT NULL::text)\n RETURNS SETOF fleet\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_user_context RECORD;\r\n  v_is_company_user boolean;\r\nBEGIN\r\n  -- Get user context\r\n  IF p_dev_user_email IS NOT NULL THEN\r\n    SELECT * INTO v_user_context FROM get_user_context(p_dev_user_email);\r\n    \r\n    -- Check if user has company-level roles\r\n    v_is_company_user := EXISTS (\r\n      SELECT 1 FROM unnest(v_user_context.roles) AS role\r\n      WHERE role IN ('super_admin', 'admin', 'developer', 'finance')\r\n    );\r\n  ELSE\r\n    -- For regular auth, check roles directly\r\n    v_is_company_user := EXISTS (\r\n      SELECT 1 \r\n      FROM user_roles ur\r\n      WHERE ur.user_id = auth.uid()\r\n      AND ur.role IN ('super_admin', 'admin', 'developer', 'finance')\r\n    );\r\n  END IF;\r\n  \r\n  RETURN QUERY\r\n  SELECT f.*\r\n  FROM fleet f\r\n  WHERE \r\n    -- Organization filter\r\n    (\r\n      p_organization_id IS NULL -- Show all if no org specified\r\n      OR f.organization_id = p_organization_id -- Or match specific org\r\n      OR (\r\n        -- For non-company users, restrict to their org\r\n        NOT v_is_company_user \r\n        AND f.organization_id = v_user_context.organization_id\r\n      )\r\n    )\r\n    -- Access control\r\n    AND (\r\n      v_is_company_user -- Company users see all\r\n      OR f.organization_id = v_user_context.organization_id -- Or user's own org\r\n      OR can_access_organization_data(f.organization_id, p_dev_user_email)\r\n    )\r\n    -- Search filter\r\n    AND (\r\n      p_search_term IS NULL\r\n      OR f.vehicle_name ILIKE '%' || p_search_term || '%'\r\n      OR f.vin ILIKE '%' || p_search_term || '%'\r\n      OR f.make ILIKE '%' || p_search_term || '%'\r\n      OR f.model ILIKE '%' || p_search_term || '%'\r\n    )\r\n    -- Operational state filter - cast to text for comparison\r\n    AND (\r\n      p_operational_state IS NULL\r\n      OR f.operational_state::text = p_operational_state\r\n    )\r\n  ORDER BY f.vehicle_name;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_funnel_campaign_analytics",
    "arguments": "p_funnel_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_funnel_campaign_analytics(p_funnel_id uuid)\n RETURNS TABLE(campaign_code character varying, campaign_name text, total_conversions bigint, last_30_days bigint, last_7_days bigint, conversion_rate numeric, last_conversion_at timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  WITH campaign_conversions AS (\r\n    SELECT\r\n      COALESCE(\r\n        rc.conversion_metadata->>'campaign',\r\n        'direct'\r\n      ) as campaign,\r\n      COUNT(*) as conversions,\r\n      COUNT(*) FILTER (WHERE rc.converted_at >= NOW() - INTERVAL '30 days') as last_30d,\r\n      COUNT(*) FILTER (WHERE rc.converted_at >= NOW() - INTERVAL '7 days') as last_7d,\r\n      MAX(rc.converted_at) as last_conversion\r\n    FROM referral_conversions rc\r\n    WHERE rc.referral_id = p_funnel_id\r\n    GROUP BY campaign\r\n  )\r\n  SELECT\r\n    cc.campaign::VARCHAR(50) as campaign_code,\r\n    COALESCE(mcl.campaign_name, 'Direct (no campaign)') as campaign_name,\r\n    cc.conversions::BIGINT as total_conversions,\r\n    cc.last_30d::BIGINT as last_30_days,\r\n    cc.last_7d::BIGINT as last_7_days,\r\n    ROUND(\r\n      (cc.conversions::NUMERIC / NULLIF(SUM(cc.conversions) OVER (), 0)) * 100,\r\n      1\r\n    ) as conversion_rate,\r\n    cc.last_conversion as last_conversion_at\r\n  FROM campaign_conversions cc\r\n  LEFT JOIN marketing_campaign_links mcl\r\n    ON mcl.funnel_id = p_funnel_id\r\n    AND mcl.campaign_code = cc.campaign\r\n  ORDER BY cc.conversions DESC;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_latest_odometer",
    "arguments": "p_vehicle_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_latest_odometer(p_vehicle_id uuid)\n RETURNS integer\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_odometer INTEGER;\nBEGIN\n  SELECT odometer INTO v_odometer\n  FROM public.fleet\n  WHERE id = p_vehicle_id;\n  \n  RETURN v_odometer;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_maintenance_assignees",
    "arguments": "p_organization_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_maintenance_assignees(p_organization_id uuid)\n RETURNS TABLE(id uuid, first_name text, last_name text, email text, is_current_user boolean)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  -- Admin users can see eligible assignees across all organizations\n  IF (SELECT EXISTS(SELECT 1 FROM admin_users_view WHERE user_id = auth.uid())) THEN\n    RETURN QUERY\n    SELECT DISTINCT ON (p.id)\n      p.id, \n      p.first_name, \n      p.last_name, \n      p.email,\n      p.id = auth.uid() as is_current_user\n    FROM profiles p\n    JOIN user_roles ur ON p.id = ur.user_id\n    WHERE ur.role IN ('owner', 'manager', 'tech')\n    ORDER BY \n      p.id,\n      p.id = auth.uid() DESC, -- Current user first\n      p.first_name, \n      p.last_name;\n    RETURN;\n  END IF;\n  \n  -- Organization users can see only users from their organization with eligible roles\n  RETURN QUERY\n  SELECT DISTINCT ON (p.id)\n    p.id, \n    p.first_name, \n    p.last_name, \n    p.email,\n    p.id = auth.uid() as is_current_user\n  FROM profiles p\n  JOIN user_roles ur ON p.id = ur.user_id\n  WHERE p.organization_id = p_organization_id\n  AND ur.role IN ('owner', 'manager', 'tech')\n  ORDER BY \n    p.id,\n    p.id = auth.uid() DESC, -- Current user first\n    p.first_name, \n    p.last_name;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_maintenance_records_with_context",
    "arguments": "p_organization_id uuid, p_search_term text, p_status text, p_operational_state text, p_severity text, p_vehicle_id uuid, p_include_resolved boolean, p_dev_user_email text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_maintenance_records_with_context(p_organization_id uuid DEFAULT NULL::uuid, p_search_term text DEFAULT NULL::text, p_status text DEFAULT NULL::text, p_operational_state text DEFAULT NULL::text, p_severity text DEFAULT NULL::text, p_vehicle_id uuid DEFAULT NULL::uuid, p_include_resolved boolean DEFAULT false, p_dev_user_email text DEFAULT NULL::text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_user_context RECORD;\r\n  v_is_company_user boolean := false;\r\n  v_result JSON;\r\nBEGIN\r\n  -- Get user context from dev email if provided\r\n  IF p_dev_user_email IS NOT NULL THEN\r\n    SELECT * INTO v_user_context FROM get_user_context(p_dev_user_email);\r\n    \r\n    -- Check if user has company-level roles\r\n    IF v_user_context.roles IS NOT NULL THEN\r\n      v_is_company_user := EXISTS (\r\n        SELECT 1 FROM unnest(v_user_context.roles) AS role\r\n        WHERE role IN ('super_admin', 'admin', 'developer', 'finance')\r\n      );\r\n    END IF;\r\n  END IF;\r\n\r\n  -- Build and execute query\r\n  SELECT json_build_object(\r\n    'records', COALESCE(json_agg(record_data ORDER BY created_at DESC), '[]'::json),\r\n    'count', COUNT(*)\r\n  ) INTO v_result\r\n  FROM (\r\n    SELECT \r\n      m.id,\r\n      m.vehicle_id,\r\n      m.organization_id,\r\n      m.issue_title,\r\n      m.issue,\r\n      m.maintenance_record_status::text as maintenance_record_status,\r\n      m.location,\r\n      m.severity,\r\n      m.date_due,\r\n      m.created_at,\r\n      m.updated_at,\r\n      m.created_by,\r\n      m.assignee,\r\n      m.resolved_at,\r\n      m.resolved_by,\r\n      m.resolution,\r\n      m.resolution_reason,\r\n      m.maintenance_notes,\r\n      m.support_ticket,\r\n      m.afs_eligible,\r\n      m.odometer,\r\n      json_build_object(\r\n        'id', f.id,\r\n        'vehicle_name', f.vehicle_name,\r\n        'vin', f.vin,\r\n        'make', f.make,\r\n        'model', f.model,\r\n        'year', f.year,\r\n        'vehicle_type', f.vehicle_type,\r\n        'operational_state', f.operational_state::text,\r\n        'organization_id', f.organization_id,\r\n        'odometer', f.odometer\r\n      ) as fleet,\r\n      CASE \r\n        WHEN p.id IS NOT NULL THEN json_build_object(\r\n          'first_name', p.first_name,\r\n          'last_name', p.last_name\r\n        )\r\n        ELSE NULL\r\n      END as profiles,\r\n      CASE \r\n        WHEN ap.id IS NOT NULL THEN json_build_object(\r\n          'id', ap.id,\r\n          'first_name', ap.first_name,\r\n          'last_name', ap.last_name,\r\n          'email', ap.email\r\n        )\r\n        ELSE NULL\r\n      END as assignee_profile,\r\n      CASE \r\n        WHEN rp.id IS NOT NULL THEN json_build_object(\r\n          'first_name', rp.first_name,\r\n          'last_name', rp.last_name\r\n        )\r\n        ELSE NULL\r\n      END as resolved_by_profile\r\n    FROM maintenance_records m\r\n    JOIN fleet f ON f.id = m.vehicle_id\r\n    LEFT JOIN profiles p ON p.id = m.created_by\r\n    LEFT JOIN profiles ap ON ap.id = m.assignee\r\n    LEFT JOIN profiles rp ON rp.id = m.resolved_by\r\n    WHERE \r\n      -- Organization filter\r\n      (\r\n        -- If specific org requested, filter by it\r\n        (p_organization_id IS NOT NULL AND m.organization_id = p_organization_id)\r\n        OR\r\n        -- If no org specified and user is company user, show all\r\n        (p_organization_id IS NULL AND v_is_company_user = true)\r\n        OR\r\n        -- If no org specified and user is not company user, show only their org\r\n        (p_organization_id IS NULL AND v_is_company_user = false AND m.organization_id = v_user_context.organization_id)\r\n      )\r\n      -- Status filter (cast to text for comparison)\r\n      AND (\r\n        p_status IS NULL \r\n        OR p_status = 'all'\r\n        OR (p_status = 'active' AND m.maintenance_record_status::text != 'Resolved')\r\n        OR (p_status != 'active' AND m.maintenance_record_status::text = p_status)\r\n      )\r\n      -- Include resolved filter (only apply if not already filtered by status)\r\n      AND (\r\n        p_include_resolved = true \r\n        OR p_status = 'active'  -- Don't double-filter if status is already 'active'\r\n        OR m.maintenance_record_status::text != 'Resolved'\r\n      )\r\n      -- Vehicle filter\r\n      AND (p_vehicle_id IS NULL OR m.vehicle_id = p_vehicle_id)\r\n      -- Search filter\r\n      AND (\r\n        p_search_term IS NULL \r\n        OR p_search_term = ''\r\n        OR m.issue_title ILIKE '%' || p_search_term || '%'\r\n        OR m.issue ILIKE '%' || p_search_term || '%'\r\n        OR f.vehicle_name ILIKE '%' || p_search_term || '%'\r\n        OR f.vin ILIKE '%' || p_search_term || '%'\r\n      )\r\n      -- Severity filter\r\n      AND (p_severity IS NULL OR m.severity::text = p_severity)\r\n      -- Operational state filter (cast to text for comparison)\r\n      AND (p_operational_state IS NULL OR f.operational_state::text = p_operational_state)\r\n  ) as record_data;\r\n\r\n  RETURN v_result;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_marketing_funnel_stats",
    "arguments": "p_referral_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_marketing_funnel_stats(p_referral_id uuid)\n RETURNS TABLE(total_conversions bigint, last_30_days bigint, last_7_days bigint, last_conversion_at timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT\r\n    COUNT(*)::BIGINT as total_conversions,\r\n    COUNT(*) FILTER (WHERE converted_at >= NOW() - INTERVAL '30 days')::BIGINT as last_30_days,\r\n    COUNT(*) FILTER (WHERE converted_at >= NOW() - INTERVAL '7 days')::BIGINT as last_7_days,\r\n    MAX(converted_at) as last_conversion_at\r\n  FROM referral_conversions\r\n  WHERE referral_id = p_referral_id;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_my_active_impersonations",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_my_active_impersonations()\n RETURNS TABLE(session_id text, target_user_id uuid, started_at timestamp with time zone, started_by uuid)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Only return impersonations for the current user\r\n    -- This enforces proper access control\r\n    RETURN QUERY\r\n    SELECT \r\n        i.session_id::TEXT,\r\n        i.target_user_id,\r\n        i.started_at,\r\n        i.started_by\r\n    FROM impersonation_sessions i\r\n    WHERE i.started_by = auth.uid()\r\n    AND i.ended_at IS NULL;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_organization_modules",
    "arguments": "org_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_organization_modules(org_id uuid)\n RETURNS TABLE(id uuid, name text, type module_type, description text, is_enabled boolean)\n LANGUAGE sql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\n  SELECT \n    m.id,\n    m.name,\n    m.type,\n    m.description,\n    COALESCE(mc.is_enabled, false) as is_enabled\n  FROM \n    modules m\n  LEFT JOIN \n    module_configurations mc ON m.id = mc.module_id AND mc.organization_id = org_id\n  ORDER BY \n    m.name;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_organizations_secure",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_organizations_secure()\n RETURNS SETOF organizations\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_is_admin BOOLEAN;\n  v_user_org_id UUID;\nBEGIN\n  -- Check if user is admin - if so, return all organizations\n  SELECT EXISTS (\n    SELECT 1 FROM admin_users_view\n    WHERE user_id = auth.uid()\n  ) INTO v_is_admin;\n  \n  IF v_is_admin THEN\n    RETURN QUERY\n    SELECT * FROM organizations\n    ORDER BY name;\n    RETURN;\n  END IF;\n  \n  -- If not admin, get user's organization\n  SELECT organization_id INTO v_user_org_id\n  FROM profiles\n  WHERE id = auth.uid();\n  \n  -- If user has owner role, return only their organization\n  IF EXISTS (\n    SELECT 1 FROM user_roles\n    WHERE user_id = auth.uid()\n    AND role = 'owner'\n  ) THEN\n    RETURN QUERY\n    SELECT * FROM organizations\n    WHERE id = v_user_org_id\n    ORDER BY name;\n    RETURN;\n  END IF;\n  \n  -- For all other roles or cases, return empty set\n  RETURN;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_owner_permissions",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_owner_permissions()\n RETURNS TABLE(permission text)\n LANGUAGE sql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\n  -- Owner has all these permissions, but only for their organization\r\n  SELECT 'organization:view' AS permission\r\n  UNION SELECT 'organization:edit'\r\n  UNION SELECT 'user:view'\r\n  UNION SELECT 'user:create'\r\n  UNION SELECT 'user:edit'\r\n  UNION SELECT 'module:view'\r\n  UNION SELECT 'module:toggle'\r\n  UNION SELECT 'fleet:view'\r\n  UNION SELECT 'fleet:edit'\r\n  UNION SELECT 'fleet:create'\r\n  UNION SELECT 'fleet:archive'\r\n  UNION SELECT 'fleet_maintenance:view'\r\n  UNION SELECT 'fleet_maintenance:edit'\r\n  UNION SELECT 'fleet_maintenance:create'\r\n  UNION SELECT 'fleet_maintenance:archive'\r\n  UNION SELECT 'profile:view'\r\n  UNION SELECT 'profile:edit';\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_region_from_state",
    "arguments": "state_code character varying",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_region_from_state(state_code character varying)\n RETURNS uuid\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\r\nDECLARE\r\n    v_region_id UUID;\r\nBEGIN\r\n    SELECT id INTO v_region_id\r\n    FROM public.regions\r\n    WHERE UPPER(state_code) = ANY(states);\r\n    \r\n    RETURN v_region_id;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_setting",
    "arguments": "setting_key text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_setting(setting_key text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  RETURN (\r\n    SELECT value \r\n    FROM public.system_settings \r\n    WHERE key = setting_key\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_survey_analytics",
    "arguments": "survey_uuid uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_survey_analytics(survey_uuid uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  analytics JSON;\r\nBEGIN\r\n  -- Check if user is admin\r\n  IF NOT is_portal_admin(auth.uid()) THEN\r\n    RAISE EXCEPTION 'Unauthorized: Admin access required';\r\n  END IF;\r\n\r\n  SELECT json_build_object(\r\n    'survey', row_to_json(s),\r\n    'response_stats', json_build_object(\r\n      'total_responses', (\r\n        SELECT COUNT(*) FROM public.portal_survey_responses \r\n        WHERE survey_id = survey_uuid\r\n      ),\r\n      'completed_responses', (\r\n        SELECT COUNT(*) FROM public.portal_survey_responses \r\n        WHERE survey_id = survey_uuid AND is_complete = true\r\n      ),\r\n      'completion_rate', (\r\n        SELECT ROUND(\r\n          100.0 * COUNT(CASE WHEN is_complete THEN 1 END) / NULLIF(COUNT(*), 0), \r\n          2\r\n        )\r\n        FROM public.portal_survey_responses \r\n        WHERE survey_id = survey_uuid\r\n      ),\r\n      'avg_completion_time', (\r\n        SELECT AVG(EXTRACT(EPOCH FROM (completed_at - started_at)) / 60)::INTEGER\r\n        FROM public.portal_survey_responses\r\n        WHERE survey_id = survey_uuid AND is_complete = true\r\n      )\r\n    ),\r\n    'question_analytics', (\r\n      SELECT json_agg(\r\n        json_build_object(\r\n          'question', q.question_text,\r\n          'question_type', q.question_type,\r\n          'response_count', (\r\n            SELECT COUNT(*) FROM public.portal_survey_answers a\r\n            WHERE a.question_id = q.id\r\n          ),\r\n          'answers', (\r\n            SELECT json_agg(\r\n              json_build_object(\r\n                'answer_text', a.answer_text,\r\n                'answer_options', a.answer_options,\r\n                'count', COUNT(*)\r\n              )\r\n            )\r\n            FROM public.portal_survey_answers a\r\n            WHERE a.question_id = q.id\r\n            GROUP BY a.answer_text, a.answer_options\r\n          )\r\n        ) ORDER BY q.display_order\r\n      )\r\n      FROM public.portal_survey_questions q\r\n      WHERE q.survey_id = survey_uuid\r\n    )\r\n  )\r\n  FROM public.portal_surveys s\r\n  WHERE s.id = survey_uuid\r\n  INTO analytics;\r\n\r\n  RETURN analytics;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_survey_with_questions",
    "arguments": "survey_uuid uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_survey_with_questions(survey_uuid uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  survey_data JSON;\r\nBEGIN\r\n  SELECT json_build_object(\r\n    'survey', row_to_json(s),\r\n    'questions', (\r\n      SELECT json_agg(row_to_json(q) ORDER BY q.display_order)\r\n      FROM public.portal_survey_questions q\r\n      WHERE q.survey_id = survey_uuid\r\n    ),\r\n    'response_count', (\r\n      SELECT COUNT(*) \r\n      FROM public.portal_survey_responses \r\n      WHERE survey_id = survey_uuid\r\n    ),\r\n    'user_response', (\r\n      SELECT row_to_json(r)\r\n      FROM public.portal_survey_responses r\r\n      WHERE r.survey_id = survey_uuid\r\n      AND r.user_id = auth.uid()\r\n      LIMIT 1\r\n    )\r\n  )\r\n  FROM public.portal_surveys s\r\n  WHERE s.id = survey_uuid\r\n  INTO survey_data;\r\n\r\n  RETURN survey_data;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_survey_with_sections",
    "arguments": "p_survey_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_survey_with_sections(p_survey_id uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_result jsonb;\r\nBEGIN\r\n  SELECT jsonb_build_object(\r\n    'survey', to_jsonb(s.*),\r\n    'sections', (\r\n      SELECT jsonb_agg(\r\n        jsonb_build_object(\r\n          'section', to_jsonb(sec.*),\r\n          'questions', (\r\n            SELECT jsonb_agg(to_jsonb(q.*) ORDER BY q.section_order, q.question_order)\r\n            FROM portal_survey_questions q\r\n            WHERE q.section_id = sec.id\r\n          )\r\n        )\r\n        ORDER BY sec.display_order\r\n      )\r\n      FROM portal_survey_sections sec\r\n      WHERE sec.survey_id = p_survey_id\r\n    ),\r\n    'ungrouped_questions', (\r\n      SELECT jsonb_agg(to_jsonb(q.*) ORDER BY q.question_order)\r\n      FROM portal_survey_questions q\r\n      WHERE q.survey_id = p_survey_id\r\n      AND q.section_id IS NULL\r\n    )\r\n  )\r\n  INTO v_result\r\n  FROM portal_surveys s\r\n  WHERE s.id = p_survey_id;\r\n\r\n  RETURN v_result;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_technicians",
    "arguments": "p_organization_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_technicians(p_organization_id uuid)\n RETURNS TABLE(id uuid, first_name text, last_name text, email text, is_current_user boolean)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  -- Admin users can see all technicians\n  IF (SELECT EXISTS(SELECT 1 FROM admin_users_view WHERE user_id = auth.uid())) THEN\n    RETURN QUERY\n    SELECT \n      p.id, \n      p.first_name, \n      p.last_name, \n      p.email,\n      p.id = auth.uid() as is_current_user\n    FROM profiles p\n    WHERE p.id NOT IN (\n      SELECT ur.user_id \n      FROM user_roles ur \n      WHERE ur.role = 'driver'\n    )\n    ORDER BY \n      p.id = auth.uid() DESC, -- Current user first\n      p.first_name, \n      p.last_name;\n    RETURN;\n  END IF;\n  \n  -- Organization users can see only users from their organization\n  RETURN QUERY\n  SELECT \n    p.id, \n    p.first_name, \n    p.last_name, \n    p.email,\n    p.id = auth.uid() as is_current_user\n  FROM profiles p\n  WHERE p.organization_id = p_organization_id\n  AND p.id NOT IN (\n    SELECT ur.user_id \n    FROM user_roles ur \n    WHERE ur.role = 'driver'\n  )\n  ORDER BY \n    p.id = auth.uid() DESC, -- Current user first\n    p.first_name, \n    p.last_name;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_test_response_stats",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_test_response_stats()\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  stats JSON;\r\n  response_count INTEGER;\r\nBEGIN\r\n  -- First check if there are any test responses\r\n  SELECT COUNT(*) INTO response_count\r\n  FROM portal_survey_responses\r\n  WHERE is_test_response = true;\r\n\r\n  IF response_count = 0 THEN\r\n    -- Return empty stats if no test responses exist\r\n    RETURN json_build_object(\r\n      'total_test_responses', 0,\r\n      'test_surveys', 0,\r\n      'oldest_test_response', NULL,\r\n      'newest_test_response', NULL,\r\n      'by_survey', '[]'::json\r\n    );\r\n  END IF;\r\n\r\n  -- Otherwise calculate full stats\r\n  SELECT json_build_object(\r\n    'total_test_responses', COUNT(*)::INTEGER,\r\n    'test_surveys', COUNT(DISTINCT survey_id)::INTEGER,\r\n    'oldest_test_response', MIN(started_at),\r\n    'newest_test_response', MAX(started_at),\r\n    'by_survey', COALESCE(\r\n      (\r\n        SELECT json_agg(\r\n          json_build_object(\r\n            'survey_id', s.id,\r\n            'survey_title', s.title,\r\n            'test_responses', COUNT(r.id)::INTEGER\r\n          )\r\n        )\r\n        FROM portal_surveys s\r\n        JOIN portal_survey_responses r ON r.survey_id = s.id\r\n        WHERE r.is_test_response = true\r\n        GROUP BY s.id, s.title\r\n      ),\r\n      '[]'::json\r\n    )\r\n  ) INTO stats\r\n  FROM portal_survey_responses\r\n  WHERE is_test_response = true;\r\n  \r\n  RETURN stats;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_top_calculator_savers",
    "arguments": "p_limit integer",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_top_calculator_savers(p_limit integer DEFAULT 10)\n RETURNS TABLE(submission_id uuid, user_email text, user_name text, company_name text, total_monthly_savings numeric, total_annual_savings numeric, submission_date timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT \r\n    cs.id,\r\n    cs.user_email,\r\n    cs.user_name,\r\n    cs.company_name,\r\n    cs.total_monthly_savings,\r\n    cs.total_annual_savings,\r\n    cs.submission_date\r\n  FROM public.calculator_submissions cs\r\n  WHERE cs.is_latest = true\r\n  ORDER BY cs.total_monthly_savings DESC\r\n  LIMIT p_limit;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_total_admins_count",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_total_admins_count()\n RETURNS integer\n LANGUAGE sql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\n  SELECT COUNT(*)::integer \n  FROM user_roles \n  WHERE role = 'admin';\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_total_organizations_count",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_total_organizations_count()\n RETURNS integer\n LANGUAGE sql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\n  SELECT COUNT(*)::integer \n  FROM organizations;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_unread_updates_count",
    "arguments": "user_uuid uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_unread_updates_count(user_uuid uuid)\n RETURNS integer\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  RETURN (\r\n    SELECT COUNT(*)\r\n    FROM public.portal_updates u\r\n    WHERE u.status = 'published'\r\n    AND u.publish_at <= NOW()\r\n    AND (u.expires_at IS NULL OR u.expires_at > NOW())\r\n    AND NOT EXISTS (\r\n      SELECT 1 FROM public.portal_update_reads r\r\n      WHERE r.update_id = u.id\r\n      AND r.user_id = user_uuid\r\n    )\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "get_updates_admin_stats",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_updates_admin_stats()\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  stats JSON;\r\nBEGIN\r\n  SELECT json_build_object(\r\n    'total_updates', COUNT(*)::INTEGER,\r\n    'draft_count', COUNT(CASE WHEN status = 'draft' THEN 1 END)::INTEGER,\r\n    'published_count', COUNT(CASE WHEN status = 'published' THEN 1 END)::INTEGER,\r\n    'archived_count', COUNT(CASE WHEN status = 'archived' THEN 1 END)::INTEGER,\r\n    'compulsory_count', COUNT(CASE WHEN \"type\" = 'compulsory' THEN 1 END)::INTEGER,\r\n    'advisory_count', COUNT(CASE WHEN \"type\" = 'general' OR \"type\" = 'advisory' THEN 1 END)::INTEGER,\r\n    'recent_archives', (\r\n      SELECT json_agg(\r\n        json_build_object(\r\n          'id', id,\r\n          'title', title,\r\n          'archived_at', archived_at,\r\n          'archived_by', archived_by\r\n        )\r\n      )\r\n      FROM (\r\n        SELECT id, title, archived_at, archived_by\r\n        FROM portal_updates\r\n        WHERE archived_at IS NOT NULL\r\n        ORDER BY archived_at DESC\r\n        LIMIT 5\r\n      ) recent\r\n    )\r\n  ) INTO stats\r\n  FROM portal_updates;\r\n  \r\n  RETURN stats;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "handle_calculator_submission",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_calculator_submission()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_notification_result JSONB;\r\nBEGIN\r\n  -- Send notification for new calculator submission\r\n  v_notification_result := public.send_calculator_notification(\r\n    jsonb_build_object(\r\n      'user_id', NEW.user_id,\r\n      'user_name', NEW.user_name,\r\n      'user_email', NEW.user_email,\r\n      'company_name', NEW.company_name,\r\n      'fleet_size', NEW.fleet_size,\r\n      'submission_date', NEW.submission_date,\r\n      'total_monthly_savings', NEW.total_monthly_savings,\r\n      'total_annual_savings', NEW.total_annual_savings,\r\n      'labor_savings_total', NEW.labor_savings_total,\r\n      'system_savings_total', NEW.system_savings_total,\r\n      'fixed_savings_total', NEW.fixed_savings_total,\r\n      'labor_savings_items', NEW.labor_savings_items,\r\n      'system_replacement_items', NEW.system_replacement_items,\r\n      'fixed_savings_items', NEW.fixed_savings_items,\r\n      'notes', NEW.notes\r\n    )\r\n  );\r\n\r\n  -- Log the notification result\r\n  RAISE NOTICE 'Calculator submission notification result: %', v_notification_result;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "handle_survey_completion",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_survey_completion()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_survey RECORD;\r\n  v_user RECORD;\r\n  v_questions_answers JSON;\r\n  v_response_count INTEGER;\r\n  v_result JSON;\r\nBEGIN\r\n  -- Only trigger on completion (when completed_at is set)\r\n  IF NEW.completed_at IS NULL OR (TG_OP = 'UPDATE' AND OLD.completed_at IS NOT NULL) THEN\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  -- Get survey details\r\n  SELECT * INTO v_survey\r\n  FROM public.portal_surveys\r\n  WHERE id = NEW.survey_id;\r\n\r\n  IF v_survey IS NULL THEN\r\n    RAISE WARNING 'Survey not found for response %', NEW.id;\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  -- Get user details\r\n  SELECT * INTO v_user\r\n  FROM public.profiles\r\n  WHERE id = NEW.user_id;\r\n\r\n  -- Get questions and answers\r\n  SELECT json_agg(\r\n    json_build_object(\r\n      'question', q.question_text,\r\n      'answer', COALESCE(a.answer_text, a.answer_value, 'No answer')\r\n    ) ORDER BY q.question_order\r\n  ) INTO v_questions_answers\r\n  FROM public.portal_survey_questions q\r\n  LEFT JOIN public.portal_survey_answers a ON a.question_id = q.id AND a.response_id = NEW.id\r\n  WHERE q.survey_id = NEW.survey_id;\r\n\r\n  -- Get total response count for this survey\r\n  SELECT COUNT(*) INTO v_response_count\r\n  FROM public.portal_survey_responses\r\n  WHERE survey_id = NEW.survey_id\r\n  AND completed_at IS NOT NULL;\r\n\r\n  -- Queue the notification\r\n  v_result := public.queue_notification(\r\n    'survey_completed',\r\n    jsonb_build_object(\r\n      'response_id', NEW.id,\r\n      'survey_id', NEW.survey_id,\r\n      'survey_title', v_survey.title,\r\n      'survey_description', v_survey.description,\r\n      'user_id', NEW.user_id,\r\n      'user_email', COALESCE(v_user.email, 'unknown@example.com'),\r\n      'user_name', COALESCE(\r\n        v_user.first_name || ' ' || v_user.last_name,\r\n        v_user.email,\r\n        'Anonymous User'\r\n      ),\r\n      'completed_at', NEW.completed_at,\r\n      'response_count', v_response_count,\r\n      'questions_answers', v_questions_answers\r\n    ),\r\n    NEW.user_id\r\n  );\r\n\r\n  -- Log if queueing failed (but don't fail the transaction)\r\n  IF NOT (v_result->>'success')::boolean THEN\r\n    RAISE WARNING 'Failed to queue survey completion notification: %', v_result->>'error';\r\n  END IF;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "handle_survey_published",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_survey_published()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_result JSON;\r\n  v_portal_url TEXT;\r\nBEGIN\r\n  -- Only trigger on status change to 'published'\r\n  IF NEW.status = 'published' AND (OLD.status IS NULL OR OLD.status != 'published') THEN\r\n\r\n    -- Build portal URL\r\n    v_portal_url := 'https://portal.fleetdrms.com/portal/surveys/' || NEW.id;\r\n\r\n    -- Queue the notification using the unified system\r\n    v_result := public.queue_notification(\r\n      'survey_published',\r\n      jsonb_build_object(\r\n        'survey_id', NEW.id,\r\n        'title', NEW.title,\r\n        'description', NEW.description,\r\n        'deadline', NEW.deadline,\r\n        'target_audience', COALESCE(NEW.target_audience, 'all'),\r\n        'published_at', COALESCE(NEW.published_at, NOW()),\r\n        'created_by', NEW.created_by,\r\n        'portal_url', v_portal_url\r\n      ),\r\n      NEW.created_by\r\n    );\r\n\r\n    -- Log if queueing failed (but don't fail the transaction)\r\n    IF NOT (v_result->>'success')::boolean THEN\r\n      RAISE WARNING 'Failed to queue survey published notification: %', v_result->>'error';\r\n    ELSE\r\n      RAISE NOTICE 'Successfully queued survey published notification for: %', NEW.title;\r\n    END IF;\r\n\r\n  END IF;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "handle_update_published",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_update_published()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_result JSON;\r\n  v_portal_url TEXT;\r\nBEGIN\r\n  -- Only trigger on status change to 'published'\r\n  IF NEW.status = 'published' AND (OLD.status IS NULL OR OLD.status != 'published') THEN\r\n\r\n    -- Build portal URL\r\n    v_portal_url := 'https://portal.fleetdrms.com/portal/updates/' || NEW.id;\r\n\r\n    -- Queue the notification\r\n    v_result := public.queue_notification(\r\n      'update_published',\r\n      jsonb_build_object(\r\n        'update_id', NEW.id,\r\n        'title', NEW.title,\r\n        'content', NEW.content,\r\n        'update_type', NEW.update_type,\r\n        'target_audience', COALESCE(NEW.target_audience, 'all'),\r\n        'published_at', COALESCE(NEW.published_at, NOW()),\r\n        'created_by', NEW.created_by,\r\n        'portal_url', v_portal_url\r\n      ),\r\n      NEW.created_by\r\n    );\r\n\r\n    -- Log result\r\n    IF (v_result->>'success')::boolean THEN\r\n      RAISE NOTICE 'Successfully queued % update notifications for: %', v_result->>'queued_count', NEW.title;\r\n    ELSE\r\n      RAISE WARNING 'Failed to queue notifications: %', v_result->>'error';\r\n    END IF;\r\n  END IF;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "handle_updated_at",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\n SET search_path TO 'public', 'pg_catalog'\nAS $function$\r\nBEGIN\r\n    NEW.updated_at = now();\r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "has_fleet_maintenance_permission",
    "arguments": "p_permission text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.has_fleet_maintenance_permission(p_permission text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  -- Check if user has admin privileges using the materialized view\n  IF EXISTS (SELECT 1 FROM admin_users_view WHERE user_id = auth.uid()) THEN\n    RETURN TRUE;\n  END IF;\n  \n  -- Check for specific permission without using RLS\n  RETURN EXISTS (\n    SELECT 1 \n    FROM public.get_user_permissions()\n    WHERE permission IN (p_permission, 'fleet_maintenance:*')\n  );\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "has_fleet_permission",
    "arguments": "p_permission text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.has_fleet_permission(p_permission text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  -- Check if user is admin\n  IF EXISTS (SELECT 1 FROM admin_users_view WHERE user_id = auth.uid()) THEN\n    RETURN TRUE;\n  END IF;\n  \n  -- Check for specific permission without triggering RLS recursion\n  RETURN EXISTS (\n    SELECT 1 \n    FROM public.get_user_permissions()\n    WHERE permission IN (p_permission, 'fleet:*')\n  );\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "has_fleet_role",
    "arguments": "p_role text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.has_fleet_role(p_role text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  -- First check if admin\n  IF EXISTS (SELECT 1 FROM admin_users_view WHERE user_id = auth.uid()) THEN\n    RETURN TRUE;\n  END IF;\n  \n  -- Direct table access without triggering RLS\n  RETURN EXISTS (\n    SELECT 1 FROM user_roles\n    WHERE user_id = auth.uid()\n    AND role = p_role::app_role\n  );\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "has_org_role",
    "arguments": "p_user_id uuid, p_org_id uuid, p_roles text[]",
    "function_definition": "CREATE OR REPLACE FUNCTION public.has_org_role(p_user_id uuid, p_org_id uuid, p_roles text[] DEFAULT NULL::text[])\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  IF p_roles IS NULL OR array_length(p_roles, 1) IS NULL THEN\r\n    RETURN EXISTS (\r\n      SELECT 1 FROM public.organization_memberships\r\n      WHERE user_id = p_user_id \r\n      AND organization_id = p_org_id\r\n      AND is_active = true\r\n    );\r\n  ELSE\r\n    RETURN EXISTS (\r\n      SELECT 1 FROM public.organization_memberships\r\n      WHERE user_id = p_user_id \r\n      AND organization_id = p_org_id\r\n      AND org_role = ANY(p_roles)\r\n      AND is_active = true\r\n    );\r\n  END IF;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "has_role",
    "arguments": "user_id uuid, role app_role",
    "function_definition": "CREATE OR REPLACE FUNCTION public.has_role(user_id uuid, role app_role)\n RETURNS boolean\n LANGUAGE sql\n STABLE SECURITY DEFINER\n SET search_path TO 'public', 'pg_catalog'\nAS $function$\r\n  SELECT EXISTS (\r\n    SELECT 1\r\n    FROM public.user_roles\r\n    WHERE user_roles.user_id = $1\r\n      AND user_roles.role = $2\r\n  );\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "has_system_role",
    "arguments": "p_user_id uuid, p_roles text[]",
    "function_definition": "CREATE OR REPLACE FUNCTION public.has_system_role(p_user_id uuid, p_roles text[] DEFAULT NULL::text[])\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  IF p_roles IS NULL OR array_length(p_roles, 1) IS NULL THEN\r\n    RETURN EXISTS (\r\n      SELECT 1 FROM public.system_user_assignments\r\n      WHERE user_id = p_user_id AND is_active = true\r\n    );\r\n  ELSE\r\n    RETURN EXISTS (\r\n      SELECT 1 FROM public.system_user_assignments\r\n      WHERE user_id = p_user_id \r\n      AND system_role = ANY(p_roles)\r\n      AND is_active = true\r\n    );\r\n  END IF;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "increment_event_view_count",
    "arguments": "event_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.increment_event_view_count(event_id uuid)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    UPDATE portal_events \r\n    SET views_count = views_count + 1\r\n    WHERE id = event_id;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "is_admin",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_admin()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_catalog'\nAS $function$\r\nDECLARE\r\n  current_user_id UUID;\r\n  has_admin_role BOOLEAN := FALSE;\r\nBEGIN\r\n  -- Get the current user ID\r\n  current_user_id := auth.uid();\r\n  \r\n  -- Return false if no user is authenticated\r\n  IF current_user_id IS NULL THEN\r\n    RETURN FALSE;\r\n  END IF;\r\n\r\n  -- Check if user has admin, super_admin, or developer role\r\n  -- All of these should be considered \"admin\" for Bridge access\r\n  SELECT EXISTS(\r\n    SELECT 1 FROM user_roles \r\n    WHERE user_id = current_user_id \r\n    AND role IN ('admin', 'super_admin', 'developer')\r\n  ) INTO has_admin_role;\r\n\r\n  RETURN has_admin_role;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "is_being_impersonated",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_being_impersonated()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    RETURN EXISTS (\n        SELECT 1 \n        FROM impersonation_sessions \n        WHERE impersonated_user_id = auth.uid()\n        AND ended_at IS NULL\n    );\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "is_contact_admin",
    "arguments": "user_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_contact_admin(user_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n    IF user_id IS NULL THEN\r\n        RETURN FALSE;\r\n    END IF;\r\n    \r\n    -- Simple check - just look for the role\r\n    RETURN EXISTS (\r\n        SELECT 1 \r\n        FROM public.profiles \r\n        WHERE id = user_id \r\n        AND role IN ('admin', 'superadmin', 'super_admin')\r\n    );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "is_event_published",
    "arguments": "event_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_event_published(event_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  RETURN EXISTS (\r\n    SELECT 1 FROM public.portal_events\r\n    WHERE id = event_id\r\n    AND status = 'published'\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "is_fleet_enabled",
    "arguments": "p_organization_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_fleet_enabled(p_organization_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_is_enabled BOOLEAN;\nBEGIN\n  -- Admin users can access all modules regardless of configuration\n  IF (SELECT EXISTS(SELECT 1 FROM admin_users_view WHERE user_id = auth.uid())) THEN\n    RETURN TRUE;\n  END IF;\n\n  SELECT mc.is_enabled\n  FROM modules m\n  JOIN module_configurations mc ON m.id = mc.module_id\n  WHERE \n    m.type = 'fleet' AND \n    mc.organization_id = p_organization_id\n  INTO v_is_enabled;\n\n  RETURN COALESCE(v_is_enabled, FALSE);\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "is_fleet_maintenance_enabled",
    "arguments": "p_organization_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_fleet_maintenance_enabled(p_organization_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_is_enabled BOOLEAN;\nBEGIN\n  -- Admin users can access all modules regardless of configuration\n  IF (SELECT EXISTS(SELECT 1 FROM admin_users_view WHERE user_id = auth.uid())) THEN\n    RETURN TRUE;\n  END IF;\n\n  SELECT mc.is_enabled\n  FROM modules m\n  JOIN module_configurations mc ON m.id = mc.module_id\n  WHERE \n    m.type = 'fleet_maintenance' AND \n    mc.organization_id = p_organization_id\n  INTO v_is_enabled;\n\n  RETURN COALESCE(v_is_enabled, FALSE);\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "is_module_enabled",
    "arguments": "p_module_type module_type, p_organization_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_module_enabled(p_module_type module_type, p_organization_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_is_enabled BOOLEAN;\nBEGIN\n  -- Admin users can access all modules regardless of configuration\n  IF (SELECT EXISTS(SELECT 1 FROM admin_users_view WHERE user_id = auth.uid())) THEN\n    RETURN TRUE;\n  END IF;\n\n  SELECT mc.is_enabled\n  FROM modules m\n  JOIN module_configurations mc ON m.id = mc.module_id\n  WHERE \n    m.type = p_module_type AND \n    mc.organization_id = p_organization_id\n  INTO v_is_enabled;\n\n  RETURN COALESCE(v_is_enabled, FALSE);\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "is_survey_active",
    "arguments": "survey_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_survey_active(survey_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  RETURN EXISTS (\r\n    SELECT 1 FROM public.portal_surveys\r\n    WHERE id = survey_id\r\n    AND is_active = true\r\n    AND start_date <= NOW()\r\n    AND (end_date IS NULL OR end_date > NOW())\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "is_update_published",
    "arguments": "update_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_update_published(update_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  RETURN EXISTS (\r\n    SELECT 1 FROM public.portal_updates\r\n    WHERE id = update_id\r\n    AND status = 'published'\r\n    AND publish_at <= NOW()\r\n    AND (expires_at IS NULL OR expires_at > NOW())\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "log_admin_activity",
    "arguments": "p_action character varying, p_entity_type character varying, p_entity_id uuid, p_entity_title character varying, p_changes jsonb",
    "function_definition": "CREATE OR REPLACE FUNCTION public.log_admin_activity(p_action character varying, p_entity_type character varying, p_entity_id uuid, p_entity_title character varying, p_changes jsonb DEFAULT NULL::jsonb)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  -- Only admins can log activity\r\n  IF NOT is_portal_admin(auth.uid()) THEN\r\n    RETURN;\r\n  END IF;\r\n\r\n  INSERT INTO public.portal_admin_activity (\r\n    admin_id, action, entity_type, entity_id, entity_title, changes\r\n  ) VALUES (\r\n    auth.uid(), p_action, p_entity_type, p_entity_id, p_entity_title, p_changes\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "log_impersonation",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.log_impersonation()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_catalog', 'auth'\nAS $function$\r\nBEGIN\r\n    IF TG_OP = 'INSERT' THEN\r\n        INSERT INTO auth.audit_log_entries (\r\n            id,           -- Add the required id field\r\n            instance_id,\r\n            ip_address,\r\n            payload,\r\n            created_at\r\n        )\r\n        VALUES (\r\n            gen_random_uuid(),  -- Generate UUID for the id field\r\n            gen_random_uuid(),  -- instance_id\r\n            '0.0.0.0',\r\n            jsonb_build_object(\r\n                'admin_id', NEW.admin_id,\r\n                'impersonated_user_id', NEW.impersonated_user_id,\r\n                'action', 'start_impersonation',\r\n                'event_type', 'impersonation'\r\n            ),\r\n            NEW.started_at\r\n        );\r\n    ELSIF TG_OP = 'UPDATE' AND NEW.ended_at IS NOT NULL AND OLD.ended_at IS NULL THEN\r\n        INSERT INTO auth.audit_log_entries (\r\n            id,           -- Add the required id field\r\n            instance_id,\r\n            ip_address,\r\n            payload,\r\n            created_at\r\n        )\r\n        VALUES (\r\n            gen_random_uuid(),  -- Generate UUID for the id field\r\n            gen_random_uuid(),  -- instance_id\r\n            '0.0.0.0',\r\n            jsonb_build_object(\r\n                'admin_id', NEW.admin_id,\r\n                'impersonated_user_id', NEW.impersonated_user_id,\r\n                'action', 'end_impersonation',\r\n                'event_type', 'impersonation'\r\n            ),\r\n            NEW.ended_at\r\n        );\r\n    END IF;\r\n    RETURN NULL;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "log_org_membership_change",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.log_org_membership_change()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_user_email TEXT;\r\n  v_org_name TEXT;\r\nBEGIN\r\n  -- Check if portal_admin_activity table exists\r\n  IF EXISTS (\r\n    SELECT 1 FROM information_schema.tables \r\n    WHERE table_schema = 'public' \r\n    AND table_name = 'portal_admin_activity'\r\n  ) THEN\r\n    -- Get user email and org name\r\n    SELECT email INTO v_user_email FROM public.profiles WHERE id = NEW.user_id;\r\n    SELECT name INTO v_org_name FROM public.organizations WHERE id = NEW.organization_id;\r\n    \r\n    IF TG_OP = 'INSERT' THEN\r\n      INSERT INTO public.portal_admin_activity (\r\n        admin_id,\r\n        action,\r\n        entity_type,\r\n        entity_id,\r\n        entity_title,\r\n        changes,\r\n        created_at\r\n      ) VALUES (\r\n        COALESCE(NEW.invited_by, auth.uid()),\r\n        'org_role_assignment',\r\n        'org_member',\r\n        NEW.id,\r\n        COALESCE(v_user_email, 'Unknown User') || ' - ' || COALESCE(v_org_name, 'Unknown Org') || ': ' || NEW.org_role,\r\n        jsonb_build_object(\r\n          'user_id', NEW.user_id,\r\n          'organization_id', NEW.organization_id,\r\n          'organization_name', v_org_name,\r\n          'role', NEW.org_role,\r\n          'operation', 'create',\r\n          'context', 'organization'\r\n        ),\r\n        NOW()\r\n      );\r\n    ELSIF TG_OP = 'UPDATE' THEN\r\n      IF OLD.is_active != NEW.is_active THEN\r\n        INSERT INTO public.portal_admin_activity (\r\n          admin_id,\r\n          action,\r\n          entity_type,\r\n          entity_id,\r\n          entity_title,\r\n          changes,\r\n          created_at\r\n        ) VALUES (\r\n          auth.uid(),\r\n          CASE WHEN NEW.is_active THEN 'org_role_activation' ELSE 'org_role_deactivation' END,\r\n          'org_member',\r\n          NEW.id,\r\n          COALESCE(v_user_email, 'Unknown User') || ' - ' || COALESCE(v_org_name, 'Unknown Org') || ': ' || NEW.org_role,\r\n          jsonb_build_object(\r\n            'user_id', NEW.user_id,\r\n            'organization_id', NEW.organization_id,\r\n            'organization_name', v_org_name,\r\n            'role', NEW.org_role,\r\n            'is_active', NEW.is_active,\r\n            'operation', 'update',\r\n            'context', 'organization'\r\n          ),\r\n          NOW()\r\n        );\r\n      END IF;\r\n    END IF;\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "log_system_assignment_change",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.log_system_assignment_change()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_user_email TEXT;\r\nBEGIN\r\n  -- Check if portal_admin_activity table exists\r\n  IF EXISTS (\r\n    SELECT 1 FROM information_schema.tables \r\n    WHERE table_schema = 'public' \r\n    AND table_name = 'portal_admin_activity'\r\n  ) THEN\r\n    -- Get user email for entity_title\r\n    SELECT email INTO v_user_email FROM public.profiles WHERE id = NEW.user_id;\r\n    \r\n    IF TG_OP = 'INSERT' THEN\r\n      INSERT INTO public.portal_admin_activity (\r\n        admin_id,\r\n        action,\r\n        entity_type,\r\n        entity_id,\r\n        entity_title,\r\n        changes,\r\n        created_at\r\n      ) VALUES (\r\n        COALESCE(NEW.assigned_by, auth.uid()),\r\n        'system_role_assignment',\r\n        'system_user',\r\n        NEW.id,\r\n        COALESCE(v_user_email, 'Unknown User') || ' - System: ' || NEW.system_role,\r\n        jsonb_build_object(\r\n          'user_id', NEW.user_id,\r\n          'role', NEW.system_role,\r\n          'operation', 'create',\r\n          'context', 'system'\r\n        ),\r\n        NOW()\r\n      );\r\n    ELSIF TG_OP = 'UPDATE' THEN\r\n      IF OLD.is_active != NEW.is_active THEN\r\n        INSERT INTO public.portal_admin_activity (\r\n          admin_id,\r\n          action,\r\n          entity_type,\r\n          entity_id,\r\n          entity_title,\r\n          changes,\r\n          created_at\r\n        ) VALUES (\r\n          auth.uid(),\r\n          CASE WHEN NEW.is_active THEN 'system_role_activation' ELSE 'system_role_deactivation' END,\r\n          'system_user',\r\n          NEW.id,\r\n          COALESCE(v_user_email, 'Unknown User') || ' - System: ' || NEW.system_role,\r\n          jsonb_build_object(\r\n            'user_id', NEW.user_id,\r\n            'role', NEW.system_role,\r\n            'is_active', NEW.is_active,\r\n            'operation', 'update',\r\n            'context', 'system'\r\n          ),\r\n          NOW()\r\n        );\r\n      END IF;\r\n    END IF;\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "mark_all_updates_as_read",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.mark_all_updates_as_read()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  INSERT INTO public.portal_update_reads (update_id, user_id)\r\n  SELECT id, auth.uid()\r\n  FROM public.portal_updates\r\n  WHERE status = 'published'\r\n  AND publish_at <= NOW()\r\n  AND (expires_at IS NULL OR expires_at > NOW())\r\n  ON CONFLICT (update_id, user_id) DO NOTHING;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "mark_update_as_read",
    "arguments": "update_uuid uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.mark_update_as_read(update_uuid uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  INSERT INTO public.portal_update_reads (update_id, user_id)\r\n  VALUES (update_uuid, auth.uid())\r\n  ON CONFLICT (update_id, user_id) DO NOTHING;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "mark_update_viewed",
    "arguments": "p_update_id uuid, p_user_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.mark_update_viewed(p_update_id uuid, p_user_id uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nBEGIN\r\n    INSERT INTO public.portal_update_reads (\r\n        update_id, \r\n        user_id, \r\n        first_viewed_at, \r\n        last_viewed_at, \r\n        view_count\r\n    )\r\n    VALUES (\r\n        p_update_id, \r\n        p_user_id, \r\n        NOW(), \r\n        NOW(), \r\n        1\r\n    )\r\n    ON CONFLICT (update_id, user_id) \r\n    DO UPDATE SET\r\n        last_viewed_at = NOW(),\r\n        view_count = portal_update_reads.view_count + 1;\r\n        \r\n    -- Update view count on the update itself\r\n    UPDATE public.portal_updates \r\n    SET view_count = COALESCE(view_count, 0) + 1\r\n    WHERE id = p_update_id;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "migrate_recipient_types_to_lists",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.migrate_recipient_types_to_lists()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  rule RECORD;\r\n  list_id uuid;\r\nBEGIN\r\n  FOR rule IN\r\n    SELECT id, event_id, recipient_type, recipient_config\r\n    FROM notification_rules\r\n    WHERE recipient_list_id IS NULL\r\n  LOOP\r\n    -- Determine which list to use based on recipient_type and event_id\r\n    IF rule.event_id IN ('update_published', 'survey_published', 'event_published') THEN\r\n      -- Published content goes to All Users\r\n      SELECT id INTO list_id FROM recipient_lists WHERE code = 'all_users';\r\n    ELSIF rule.recipient_type = 'admin' OR rule.recipient_type = 'static' THEN\r\n      SELECT id INTO list_id FROM recipient_lists WHERE code = 'portal_admins';\r\n    ELSIF rule.recipient_type = 'user' THEN\r\n      SELECT id INTO list_id FROM recipient_lists WHERE code = 'triggering_user';\r\n    ELSIF rule.recipient_type = 'dynamic' THEN\r\n      -- Check if this is a referral\r\n      IF rule.event_id = 'referral_created' THEN\r\n        SELECT id INTO list_id FROM recipient_lists WHERE code = 'referred_user';\r\n      ELSE\r\n        SELECT id INTO list_id FROM recipient_lists WHERE code = 'triggering_user';\r\n      END IF;\r\n    ELSIF rule.recipient_type = 'role' THEN\r\n      -- Check the config for specific roles\r\n      IF rule.recipient_config::text ILIKE '%investor%' THEN\r\n        SELECT id INTO list_id FROM recipient_lists WHERE code = 'investors';\r\n      ELSE\r\n        SELECT id INTO list_id FROM recipient_lists WHERE code = 'all_users';\r\n      END IF;\r\n    ELSE\r\n      -- Default to portal admins for unknown types\r\n      SELECT id INTO list_id FROM recipient_lists WHERE code = 'portal_admins';\r\n    END IF;\r\n\r\n    -- Update the rule with the new recipient_list_id\r\n    IF list_id IS NOT NULL THEN\r\n      UPDATE notification_rules\r\n      SET recipient_list_id = list_id\r\n      WHERE id = rule.id;\r\n    END IF;\r\n  END LOOP;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "record_rate_limit_action",
    "arguments": "p_user_id uuid, p_action_type text, p_referral_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.record_rate_limit_action(p_user_id uuid, p_action_type text, p_referral_id uuid DEFAULT NULL::uuid)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    INSERT INTO public.portal_referral_rate_limits (user_id, action_type, referral_id)\r\n    VALUES (p_user_id, p_action_type, p_referral_id);\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "register_for_event",
    "arguments": "event_uuid uuid, registration_data jsonb",
    "function_definition": "CREATE OR REPLACE FUNCTION public.register_for_event(event_uuid uuid, registration_data jsonb DEFAULT '{}'::jsonb)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_registration_id UUID;\r\n  v_event RECORD;\r\nBEGIN\r\n  -- Get event details\r\n  SELECT * INTO v_event\r\n  FROM public.portal_events\r\n  WHERE id = event_uuid\r\n  AND status = 'published';\r\n\r\n  IF NOT FOUND THEN\r\n    RAISE EXCEPTION 'Event not found or not published';\r\n  END IF;\r\n\r\n  -- Check registration limit\r\n  IF v_event.registration_limit IS NOT NULL THEN\r\n    IF (SELECT COUNT(*) FROM public.portal_event_registrations \r\n        WHERE event_id = event_uuid \r\n        AND attendance_status NOT IN ('cancelled', 'waitlisted')) >= v_event.registration_limit THEN\r\n      -- Add to waitlist\r\n      INSERT INTO public.portal_event_registrations (\r\n        event_id, user_id, attendance_status, metadata\r\n      ) VALUES (\r\n        event_uuid, auth.uid(), 'waitlisted', registration_data\r\n      )\r\n      ON CONFLICT (event_id, user_id) DO UPDATE SET\r\n        attendance_status = 'waitlisted',\r\n        metadata = EXCLUDED.metadata\r\n      RETURNING id INTO v_registration_id;\r\n    ELSE\r\n      -- Register normally\r\n      INSERT INTO public.portal_event_registrations (\r\n        event_id, user_id, attendance_status, metadata\r\n      ) VALUES (\r\n        event_uuid, auth.uid(), 'registered', registration_data\r\n      )\r\n      ON CONFLICT (event_id, user_id) DO UPDATE SET\r\n        attendance_status = 'registered',\r\n        metadata = EXCLUDED.metadata\r\n      RETURNING id INTO v_registration_id;\r\n    END IF;\r\n  ELSE\r\n    -- No limit, register normally\r\n    INSERT INTO public.portal_event_registrations (\r\n      event_id, user_id, attendance_status, metadata\r\n    ) VALUES (\r\n      event_uuid, auth.uid(), 'registered', registration_data\r\n    )\r\n    ON CONFLICT (event_id, user_id) DO UPDATE SET\r\n      attendance_status = 'registered',\r\n      metadata = EXCLUDED.metadata\r\n    RETURNING id INTO v_registration_id;\r\n  END IF;\r\n\r\n  RETURN v_registration_id;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "render_template",
    "arguments": "template_text text, variables jsonb",
    "function_definition": "CREATE OR REPLACE FUNCTION public.render_template(template_text text, variables jsonb)\n RETURNS text\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\r\nDECLARE\r\n  result TEXT := template_text;\r\n  key TEXT;\r\n  value TEXT;\r\nBEGIN\r\n  -- Loop through all variables and replace placeholders\r\n  FOR key, value IN SELECT * FROM jsonb_each_text(variables)\r\n  LOOP\r\n    -- Replace {{key}} with value\r\n    result := REPLACE(result, '{{' || key || '}}', COALESCE(value, ''));\r\n  END LOOP;\r\n  \r\n  RETURN result;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "reopen_survey",
    "arguments": "p_survey_id uuid, p_new_due_date timestamp with time zone, p_clear_responses boolean, p_admin_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.reopen_survey(p_survey_id uuid, p_new_due_date timestamp with time zone DEFAULT NULL::timestamp with time zone, p_clear_responses boolean DEFAULT false, p_admin_id uuid DEFAULT NULL::uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  survey_title TEXT;\r\n  current_status TEXT;\r\n  response_count INTEGER;\r\n  cleared_count INTEGER := 0;\r\nBEGIN\r\n  -- Get survey details\r\n  SELECT title, status INTO survey_title, current_status\r\n  FROM public.portal_surveys\r\n  WHERE id = p_survey_id;\r\n\r\n  -- Check if survey exists\r\n  IF survey_title IS NULL THEN\r\n    RAISE EXCEPTION 'Survey not found';\r\n  END IF;\r\n\r\n  -- Check if survey is closed\r\n  IF current_status != 'closed' THEN\r\n    RAISE EXCEPTION 'Survey is not closed. Current status: %', current_status;\r\n  END IF;\r\n\r\n  -- Get current response count\r\n  SELECT COUNT(*) INTO response_count\r\n  FROM public.portal_survey_responses\r\n  WHERE survey_id = p_survey_id;\r\n\r\n  -- Clear responses if requested\r\n  IF p_clear_responses AND response_count > 0 THEN\r\n    -- Delete answers first (foreign key constraint)\r\n    DELETE FROM public.portal_survey_answers\r\n    WHERE response_id IN (\r\n      SELECT id FROM public.portal_survey_responses\r\n      WHERE survey_id = p_survey_id\r\n    );\r\n\r\n    -- Delete responses\r\n    DELETE FROM public.portal_survey_responses\r\n    WHERE survey_id = p_survey_id;\r\n\r\n    cleared_count := response_count;\r\n  END IF;\r\n\r\n  -- Reopen the survey by setting status to 'published'\r\n  UPDATE public.portal_surveys\r\n  SET\r\n    status = 'published',\r\n    closed_at = NULL,\r\n    due_date = COALESCE(p_new_due_date, due_date),\r\n    updated_at = NOW()\r\n  WHERE id = p_survey_id;\r\n\r\n  -- Log the action if audit log exists\r\n  IF EXISTS (\r\n    SELECT 1 FROM information_schema.tables\r\n    WHERE table_schema = 'public'\r\n    AND table_name = 'portal_audit_log'\r\n  ) THEN\r\n    INSERT INTO public.portal_audit_log (\r\n      action,\r\n      entity_type,\r\n      entity_id,\r\n      admin_id,\r\n      details\r\n    ) VALUES (\r\n      'reopen_survey',\r\n      'survey',\r\n      p_survey_id,\r\n      p_admin_id,\r\n      json_build_object(\r\n        'title', survey_title,\r\n        'new_due_date', p_new_due_date,\r\n        'responses_cleared', p_clear_responses,\r\n        'cleared_count', cleared_count,\r\n        'reopened_at', NOW()\r\n      )\r\n    );\r\n  END IF;\r\n\r\n  RETURN json_build_object(\r\n    'success', true,\r\n    'title', survey_title,\r\n    'responses_cleared', cleared_count,\r\n    'new_due_date', p_new_due_date,\r\n    'status', 'published'\r\n  );\r\n\r\nEXCEPTION\r\n  WHEN OTHERS THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', SQLERRM\r\n    );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "resolve_maintenance_record",
    "arguments": "p_record_id uuid, p_resolution text, p_resolved_at timestamp with time zone, p_vehicle_id uuid, p_operational_state text, p_additional_data jsonb",
    "function_definition": "CREATE OR REPLACE FUNCTION public.resolve_maintenance_record(p_record_id uuid, p_resolution text, p_resolved_at timestamp with time zone, p_vehicle_id uuid, p_operational_state text, p_additional_data jsonb DEFAULT '{}'::jsonb)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  -- Check permissions\n  IF NOT can_access_maintenance_record(p_record_id) THEN\n    RAISE EXCEPTION 'Permission denied';\n  END IF;\n  \n  -- Update maintenance record\n  UPDATE maintenance_records\n  SET \n    resolution = p_resolution,\n    resolved_at = p_resolved_at,\n    resolved_by = auth.uid(),\n    maintenance_record_status = 'Resolved'::maintenance_record_status,\n    updated_at = now()\n  WHERE id = p_record_id;\n  \n  -- Only update vehicle state if specifically provided\n  IF p_operational_state IS NOT NULL AND p_vehicle_id IS NOT NULL THEN\n    PERFORM update_vehicle_operational_state(p_vehicle_id, p_operational_state);\n  ELSE\n    -- Check if vehicle has any other active maintenance records\n    -- If not, set to Available\n    PERFORM update_vehicle_operational_state(p_vehicle_id);\n  END IF;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "resolve_maintenance_record",
    "arguments": "p_record_id uuid, p_resolution text, p_resolved_at timestamp with time zone, p_vehicle_id uuid, p_operational_state text, p_resolution_reason text, p_odometer integer, p_assignee uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.resolve_maintenance_record(p_record_id uuid, p_resolution text, p_resolved_at timestamp with time zone, p_vehicle_id uuid, p_operational_state text, p_resolution_reason text DEFAULT 'Repairs Completed'::text, p_odometer integer DEFAULT NULL::integer, p_assignee uuid DEFAULT NULL::uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_operational_state operational_state;\n  v_old_assignee uuid;\nBEGIN\n  -- Check permissions\n  IF NOT can_access_maintenance_record(p_record_id) THEN\n    RAISE EXCEPTION 'Permission denied';\n  END IF;\n  \n  -- Convert operational_state string to enum type\n  IF p_operational_state IS NOT NULL THEN\n    v_operational_state := p_operational_state::operational_state;\n  ELSE\n    v_operational_state := 'Available'::operational_state;\n  END IF;\n  \n  -- Get the current assignee for history tracking\n  SELECT assignee INTO v_old_assignee\n  FROM maintenance_records\n  WHERE id = p_record_id;\n  \n  -- If assignee is changing during resolution, track it\n  IF p_assignee IS NOT NULL AND p_assignee IS DISTINCT FROM v_old_assignee THEN\n    INSERT INTO maintenance_assignment_history (\n      maintenance_record_id,\n      previous_assignee,\n      new_assignee,\n      assigned_by\n    ) VALUES (\n      p_record_id,\n      v_old_assignee,\n      p_assignee,\n      auth.uid()\n    );\n  END IF;\n  \n  -- Update maintenance record\n  UPDATE maintenance_records\n  SET \n    resolution = p_resolution,\n    resolved_at = p_resolved_at,\n    resolved_by = auth.uid(),\n    maintenance_record_status = 'Resolved'::maintenance_record_status,\n    resolution_reason = p_resolution_reason::resolution_reason,\n    updated_at = now(),\n    odometer = COALESCE(p_odometer, odometer),\n    assignee = COALESCE(p_assignee, assignee)\n  WHERE id = p_record_id;\n  \n  -- If odometer is provided, update the vehicle's odometer as well\n  IF p_odometer IS NOT NULL THEN\n    -- First record in odometer history\n    INSERT INTO odometer_history (\n      vehicle_id,\n      odometer,\n      recorded_by,\n      maintenance_record_id,\n      notes\n    ) VALUES (\n      p_vehicle_id,\n      p_odometer,\n      auth.uid(),\n      p_record_id,\n      'Updated during maintenance record resolution'\n    );\n    \n    -- Then try to update the vehicle if the new reading is higher or equal\n    PERFORM update_odometer_with_validation(p_vehicle_id, p_odometer);\n  END IF;\n  \n  -- Always set vehicle operational state when resolving\n  IF p_vehicle_id IS NOT NULL THEN\n    PERFORM update_vehicle_operational_state(p_vehicle_id, v_operational_state);\n  END IF;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "resolve_maintenance_record",
    "arguments": "p_record_id uuid, p_resolution text, p_resolved_at timestamp with time zone, p_vehicle_id uuid, p_operational_state text, p_resolution_reason resolution_reason, p_additional_data jsonb",
    "function_definition": "CREATE OR REPLACE FUNCTION public.resolve_maintenance_record(p_record_id uuid, p_resolution text, p_resolved_at timestamp with time zone, p_vehicle_id uuid, p_operational_state text, p_resolution_reason resolution_reason, p_additional_data jsonb DEFAULT '{}'::jsonb)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  -- Check permissions\n  IF NOT can_access_maintenance_record(p_record_id) THEN\n    RAISE EXCEPTION 'Permission denied';\n  END IF;\n  \n  -- Update maintenance record\n  UPDATE maintenance_records\n  SET \n    resolution = p_resolution,\n    resolved_at = p_resolved_at,\n    resolved_by = auth.uid(),\n    maintenance_record_status = 'Resolved'::maintenance_record_status,\n    resolution_reason = p_resolution_reason,\n    updated_at = now()\n  WHERE id = p_record_id;\n  \n  -- Always set vehicle operational state to Available when resolving\n  PERFORM update_vehicle_operational_state(p_vehicle_id, 'Available');\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "resolve_maintenance_record_status",
    "arguments": "p_record_id uuid, p_resolution text, p_resolved_at timestamp with time zone, p_vehicle_status text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.resolve_maintenance_record_status(p_record_id uuid, p_resolution text, p_resolved_at timestamp with time zone, p_vehicle_status text)\n RETURNS SETOF maintenance_records\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_vehicle_id uuid;\nBEGIN\n  -- Check permissions\n  IF NOT can_access_maintenance_record(p_record_id) THEN\n    RAISE EXCEPTION 'Permission denied';\n  END IF;\n  \n  -- Get the vehicle_id for later use\n  SELECT vehicle_id INTO v_vehicle_id\n  FROM maintenance_records\n  WHERE id = p_record_id;\n  \n  IF v_vehicle_id IS NULL THEN\n    RAISE EXCEPTION 'Maintenance record not found';\n  END IF;\n  \n  -- Update maintenance record\n  RETURN QUERY\n  UPDATE maintenance_records\n  SET \n    resolution = p_resolution,\n    resolved_at = p_resolved_at,\n    resolved_by = auth.uid(),\n    state = 'in-service'::maintenance_state,  -- Set state to in-service (not operational)\n    updated_at = now()\n  WHERE id = p_record_id\n  RETURNING *;\n  \n  -- Update vehicle status if provided\n  IF p_vehicle_status IS NOT NULL AND v_vehicle_id IS NOT NULL THEN\n    PERFORM update_vehicle_maintenance_status(v_vehicle_id, p_vehicle_status);\n  END IF;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "save_survey_response",
    "arguments": "p_survey_id uuid, p_answers jsonb, p_is_complete boolean",
    "function_definition": "CREATE OR REPLACE FUNCTION public.save_survey_response(p_survey_id uuid, p_answers jsonb, p_is_complete boolean DEFAULT false)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_response_id UUID;\r\n  v_answer JSONB;\r\nBEGIN\r\n  -- Create or update response\r\n  INSERT INTO public.portal_survey_responses (\r\n    survey_id, user_id, is_complete, completed_at, completion_percentage\r\n  ) VALUES (\r\n    p_survey_id, \r\n    auth.uid(), \r\n    p_is_complete,\r\n    CASE WHEN p_is_complete THEN NOW() ELSE NULL END,\r\n    CASE WHEN p_is_complete THEN 100 ELSE 50 END\r\n  )\r\n  ON CONFLICT (survey_id, user_id) DO UPDATE SET\r\n    is_complete = EXCLUDED.is_complete,\r\n    completed_at = EXCLUDED.completed_at,\r\n    completion_percentage = EXCLUDED.completion_percentage\r\n  RETURNING id INTO v_response_id;\r\n\r\n  -- Save answers\r\n  FOR v_answer IN SELECT * FROM jsonb_array_elements(p_answers)\r\n  LOOP\r\n    INSERT INTO public.portal_survey_answers (\r\n      response_id, question_id, answer_text, answer_options, \r\n      answer_number, answer_date\r\n    ) VALUES (\r\n      v_response_id,\r\n      (v_answer->>'question_id')::UUID,\r\n      v_answer->>'answer_text',\r\n      v_answer->'answer_options',\r\n      (v_answer->>'answer_number')::NUMERIC,\r\n      (v_answer->>'answer_date')::DATE\r\n    )\r\n    ON CONFLICT (response_id, question_id) DO UPDATE SET\r\n      answer_text = EXCLUDED.answer_text,\r\n      answer_options = EXCLUDED.answer_options,\r\n      answer_number = EXCLUDED.answer_number,\r\n      answer_date = EXCLUDED.answer_date,\r\n      answered_at = NOW();\r\n  END LOOP;\r\n\r\n  RETURN v_response_id;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "search_contacts",
    "arguments": "search_query text, p_market_id uuid, p_station_id uuid, p_dsp_id uuid, p_status text, p_limit integer, p_offset integer",
    "function_definition": "CREATE OR REPLACE FUNCTION public.search_contacts(search_query text, p_market_id uuid DEFAULT NULL::uuid, p_station_id uuid DEFAULT NULL::uuid, p_dsp_id uuid DEFAULT NULL::uuid, p_status text DEFAULT NULL::text, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0)\n RETURNS TABLE(id uuid, first_name character varying, last_name character varying, email character varying, phone character varying, title contact_title_enum, contact_status character varying, market_id uuid, market_name character varying, station_id uuid, station_code character varying, dsp_id uuid, dsp_name character varying, dsp_code character varying, dsp_locations text, interaction_count bigint, last_contacted_at timestamp with time zone, created_at timestamp with time zone, rank real)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    WITH contact_locations AS (\r\n      SELECT \r\n        cdl.contact_id,\r\n        STRING_AGG(DISTINCT m.name || ' - ' || s.station_code, ', ' ORDER BY m.name || ' - ' || s.station_code) as locations\r\n      FROM contact_dsp_locations cdl\r\n      INNER JOIN dsp_locations dl ON dl.id = cdl.dsp_location_id\r\n      INNER JOIN stations s ON s.id = dl.station_id\r\n      LEFT JOIN markets m ON m.id = s.market_id\r\n      WHERE dl.is_active = true\r\n      GROUP BY cdl.contact_id\r\n    )\r\n    SELECT \r\n        c.id,\r\n        c.first_name,\r\n        c.last_name,\r\n        c.email,\r\n        c.phone,\r\n        c.title,\r\n        c.contact_status,\r\n        c.market_id,\r\n        m.name as market_name,\r\n        c.station_id,\r\n        s.station_code,\r\n        c.dsp_id,\r\n        d.dsp_name,\r\n        d.dsp_code,\r\n        cl.locations as dsp_locations,\r\n        COUNT(DISTINCT i.id) as interaction_count,\r\n        c.last_contacted_at,\r\n        c.created_at,\r\n        CASE \r\n            WHEN search_query IS NULL OR search_query = '' THEN 1.0\r\n            ELSE ts_rank(\r\n                to_tsvector('english', \r\n                    coalesce(c.first_name, '') || ' ' || \r\n                    coalesce(c.last_name, '') || ' ' || \r\n                    coalesce(c.email, '') || ' ' ||\r\n                    coalesce(c.phone, '') || ' ' ||\r\n                    coalesce(c.notes, '') || ' ' ||\r\n                    coalesce(d.dsp_code, '') || ' ' ||\r\n                    coalesce(d.dsp_name, '') || ' ' ||\r\n                    coalesce(cl.locations, '')\r\n                ),\r\n                plainto_tsquery('english', search_query)\r\n            )\r\n        END as rank\r\n    FROM public.contacts c\r\n    LEFT JOIN public.markets m ON c.market_id = m.id\r\n    LEFT JOIN public.stations s ON c.station_id = s.id\r\n    LEFT JOIN public.dsps d ON c.dsp_id = d.id\r\n    LEFT JOIN public.interactions i ON c.id = i.contact_id\r\n    LEFT JOIN contact_locations cl ON cl.contact_id = c.id\r\n    WHERE c.is_active = true\r\n        AND (p_market_id IS NULL OR c.market_id = p_market_id)\r\n        AND (p_station_id IS NULL OR c.station_id = p_station_id)\r\n        AND (p_dsp_id IS NULL OR c.dsp_id = p_dsp_id)\r\n        AND (p_status IS NULL OR c.contact_status = p_status)\r\n        AND (\r\n            search_query IS NULL \r\n            OR search_query = ''\r\n            OR to_tsvector('english', \r\n                coalesce(c.first_name, '') || ' ' || \r\n                coalesce(c.last_name, '') || ' ' || \r\n                coalesce(c.email, '') || ' ' ||\r\n                coalesce(c.phone, '') || ' ' ||\r\n                coalesce(c.notes, '') || ' ' ||\r\n                coalesce(d.dsp_code, '') || ' ' ||\r\n                coalesce(d.dsp_name, '') || ' ' ||\r\n                coalesce(cl.locations, '')\r\n            ) @@ plainto_tsquery('english', search_query)\r\n        )\r\n    GROUP BY \r\n        c.id, c.first_name, c.last_name, c.email, c.phone, \r\n        c.title, c.contact_status, c.last_contacted_at, c.created_at,\r\n        c.market_id, m.name, c.station_id, s.station_code, \r\n        c.dsp_id, d.dsp_name, d.dsp_code, cl.locations\r\n    ORDER BY rank DESC, c.created_at DESC\r\n    LIMIT p_limit\r\n    OFFSET p_offset;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "set_dev_password",
    "arguments": "user_email text, new_password text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.set_dev_password(user_email text, new_password text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n    v_user_id uuid;\r\n    v_password_hash text;\r\n    v_calling_user_role text;\r\nBEGIN\r\n    -- Check admin permission\r\n    SELECT role INTO v_calling_user_role\r\n    FROM user_roles \r\n    WHERE user_id = auth.uid() \r\n    AND role IN ('super_admin', 'admin', 'developer')\r\n    LIMIT 1;\r\n\r\n    IF v_calling_user_role IS NULL THEN\r\n        RETURN json_build_object(\r\n            'success', false,\r\n            'error', 'Only administrators can set dev passwords'\r\n        );\r\n    END IF;\r\n\r\n    -- Get user ID from profiles\r\n    SELECT id INTO v_user_id\r\n    FROM profiles\r\n    WHERE lower(email) = lower(user_email);\r\n\r\n    IF v_user_id IS NULL THEN\r\n        RETURN json_build_object(\r\n            'success', false,\r\n            'error', 'User not found'\r\n        );\r\n    END IF;\r\n\r\n    -- Use pre-computed hashes for known passwords\r\n    CASE new_password\r\n        WHEN 'FleetDRMS!' THEN \r\n            v_password_hash := '$2a$10$knWloUPDUEOUR8dKz.RUyuwTtiTROffQfWPqVy4wlT1Ys3hVF8NXy';\r\n        WHEN 'TempPassword123!' THEN \r\n            v_password_hash := '$2a$10$AY6ls4T2C6r1kN3O/i/lLOuKJF5voH0eKpCU50zl6cRLHtP0rEQCy';\r\n        WHEN 'Password123!' THEN \r\n            v_password_hash := '$2a$10$aJg4ss4FzAn6hOuzDPPKK.EXVQWQHZ8J7wN/uHN6Aav15.RdYrYKO';\r\n        ELSE\r\n            -- For development, just store the plain password with a prefix\r\n            v_password_hash := 'PLAIN:' || new_password;\r\n    END CASE;\r\n\r\n    -- Insert or update dev_auth\r\n    INSERT INTO public.dev_auth (user_id, email, password_hash, updated_at)\r\n    VALUES (v_user_id, user_email, v_password_hash, NOW())\r\n    ON CONFLICT (user_id) DO UPDATE\r\n    SET \r\n        password_hash = EXCLUDED.password_hash,\r\n        updated_at = NOW();\r\n\r\n    RETURN json_build_object(\r\n        'success', true,\r\n        'message', 'Dev password set successfully',\r\n        'user_email', user_email,\r\n        'password', new_password,\r\n        'note', 'Use the Dev Login button on the auth page'\r\n    );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "simple_password_test",
    "arguments": "email_to_test text, password_to_test text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.simple_password_test(email_to_test text, password_to_test text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'extensions', 'auth'\nAS $function$\r\nDECLARE\r\n  v_user_id uuid;\r\n  v_encrypted_password text;\r\n  v_test_result boolean;\r\n  v_search_path text;\r\nBEGIN\r\n  -- Get current search path for diagnostics\r\n  SHOW search_path INTO v_search_path;\r\n\r\n  -- Find user by email\r\n  SELECT id, encrypted_password \r\n  INTO v_user_id, v_encrypted_password\r\n  FROM auth.users\r\n  WHERE lower(email) = lower(email_to_test);\r\n  \r\n  -- If no user found\r\n  IF v_user_id IS NULL THEN\r\n    RETURN jsonb_build_object(\r\n      'success', false,\r\n      'error', format('User with email %s not found', email_to_test),\r\n      'search_path', v_search_path\r\n    );\r\n  END IF;\r\n\r\n  -- Test the password using each approach\r\n  -- Method 1: Direct crypt comparison\r\n  BEGIN\r\n    v_test_result := (extensions.crypt(password_to_test, v_encrypted_password) = v_encrypted_password);\r\n  \r\n    RETURN jsonb_build_object(\r\n      'success', true,\r\n      'user_id', v_user_id,\r\n      'password_matches', v_test_result,\r\n      'encrypted_format', substring(v_encrypted_password from 1 for 29),\r\n      'search_path', v_search_path,\r\n      'method', 'extensions.crypt comparison'\r\n    );\r\n  EXCEPTION WHEN OTHERS THEN\r\n    RETURN jsonb_build_object(\r\n      'success', false,\r\n      'error', SQLERRM,\r\n      'error_detail', SQLSTATE,\r\n      'search_path', v_search_path\r\n    );\r\n  END;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "test_admin_permissions",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.test_admin_permissions()\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_user_id UUID;\r\n  v_user_role TEXT;\r\n  v_user_email TEXT;\r\nBEGIN\r\n  v_user_id := auth.uid();\r\n\r\n  SELECT role, email INTO v_user_role, v_user_email\r\n  FROM public.profiles\r\n  WHERE id = v_user_id;\r\n\r\n  RETURN json_build_object(\r\n    'user_id', v_user_id,\r\n    'email', v_user_email,\r\n    'role', v_user_role,\r\n    'is_admin', v_user_role IN ('admin', 'super_admin'),\r\n    'can_delete', CASE\r\n      WHEN v_user_role IN ('admin', 'super_admin') THEN true\r\n      ELSE false\r\n    END\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "test_password_methods",
    "arguments": "email_to_test text, password_to_test text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.test_password_methods(email_to_test text, password_to_test text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'extensions', 'auth'\nAS $function$\r\nDECLARE\r\n  v_user_id uuid;\r\n  v_email text;\r\n  v_encrypted_password text;\r\n  v_result jsonb;\r\n  v_method1 boolean;\r\n  v_method2 boolean;\r\n  v_method3 boolean;\r\n  v_method4 boolean;\r\n  v_method5 boolean;\r\nBEGIN\r\n  -- Find user by email\r\n  SELECT id, email, encrypted_password \r\n  INTO v_user_id, v_email, v_encrypted_password\r\n  FROM auth.users\r\n  WHERE lower(email) = lower(email_to_test);\r\n  \r\n  -- If no user found\r\n  IF v_user_id IS NULL THEN\r\n    RETURN jsonb_build_object(\r\n      'error', format('User with email %s not found', email_to_test)\r\n    );\r\n  END IF;\r\n\r\n  -- Try different verification methods\r\n  \r\n  -- Method 1: Standard comparison with extensions prefix\r\n  BEGIN\r\n    v_method1 := (extensions.crypt(password_to_test, v_encrypted_password) = v_encrypted_password);\r\n  EXCEPTION WHEN OTHERS THEN\r\n    v_method1 := false;\r\n  END;\r\n  \r\n  -- Method 2: Direct crypt with no prefix\r\n  BEGIN\r\n    v_method2 := (crypt(password_to_test, v_encrypted_password) = v_encrypted_password);\r\n  EXCEPTION WHEN OTHERS THEN\r\n    v_method2 := false;\r\n  END;\r\n  \r\n  -- Method 3: Using pgcrypto explicit\r\n  BEGIN\r\n    v_method3 := (pgcrypto.crypt(password_to_test, v_encrypted_password) = v_encrypted_password);\r\n  EXCEPTION WHEN OTHERS THEN\r\n    v_method3 := false;\r\n  END;\r\n  \r\n  -- Method 4: Check if there's an auth.check_password function\r\n  BEGIN\r\n    IF EXISTS (\r\n      SELECT 1 FROM pg_proc p JOIN pg_namespace n ON p.pronamespace = n.oid \r\n      WHERE n.nspname = 'auth' AND p.proname = 'check_password'\r\n    ) THEN\r\n      EXECUTE 'SELECT auth.check_password($1, $2)' INTO v_method4 USING v_email, password_to_test;\r\n    ELSE\r\n      v_method4 := false;\r\n    END IF;\r\n  EXCEPTION WHEN OTHERS THEN\r\n    v_method4 := false;\r\n  END;\r\n  \r\n  -- Method 5: Check for Gotrue format (Supabase auth system)\r\n  BEGIN\r\n    IF v_encrypted_password LIKE '$2a$%' OR v_encrypted_password LIKE '$2b$%' THEN\r\n      -- Likely bcrypt - already tested in methods 1-3\r\n      v_method5 := false;\r\n    ELSIF v_encrypted_password LIKE '$pbkdf2%' THEN\r\n      -- PBKDF2 format - not supported in our direct tests\r\n      v_method5 := false;\r\n    ELSE\r\n      -- Unknown format\r\n      v_method5 := false;\r\n    END IF;\r\n  EXCEPTION WHEN OTHERS THEN\r\n    v_method5 := false;\r\n  END;\r\n  \r\n  -- Return results of all methods\r\n  RETURN jsonb_build_object(\r\n    'user_id', v_user_id,\r\n    'password_format', substring(v_encrypted_password from 1 for 7),\r\n    'password_length', length(v_encrypted_password),\r\n    'method1_extensions_crypt', v_method1,\r\n    'method2_direct_crypt', v_method2,\r\n    'method3_pgcrypto_crypt', v_method3,\r\n    'method4_auth_check_password', v_method4,\r\n    'method5_special_format', v_method5,\r\n    'timestamp', now()\r\n  );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "test_pgcrypto_access",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.test_pgcrypto_access()\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'extensions', 'auth'\nAS $function$\r\nDECLARE\r\n  test_result text;\r\n  schema_search_path text;\r\nBEGIN\r\n  -- First, capture the current search_path for debugging\r\n  SHOW search_path INTO schema_search_path;\r\n  \r\n  -- Try different approaches to access gen_salt\r\n  BEGIN\r\n    -- Attempt 1: Direct call\r\n    SELECT gen_salt('bf', 10) INTO test_result;\r\n    RETURN 'Success using direct gen_salt call: ' || test_result || ', Search path: ' || schema_search_path;\r\n  EXCEPTION WHEN OTHERS THEN\r\n    BEGIN\r\n      -- Attempt 2: With extensions schema prefix\r\n      SELECT extensions.gen_salt('bf', 10) INTO test_result;\r\n      RETURN 'Success using extensions.gen_salt: ' || test_result || ', Search path: ' || schema_search_path;\r\n    EXCEPTION WHEN OTHERS THEN\r\n      BEGIN\r\n        -- Attempt 3: With public schema prefix\r\n        SELECT public.gen_salt('bf', 10) INTO test_result;\r\n        RETURN 'Success using public.gen_salt: ' || test_result || ', Search path: ' || schema_search_path;\r\n      EXCEPTION WHEN OTHERS THEN\r\n        BEGIN\r\n          -- Attempt 4: pgcrypto schema reference\r\n          SELECT pgcrypto.gen_salt('bf', 10) INTO test_result;\r\n          RETURN 'Success using pgcrypto.gen_salt: ' || test_result || ', Search path: ' || schema_search_path;\r\n        EXCEPTION WHEN OTHERS THEN\r\n          BEGIN\r\n            -- Attempt 5: Check if the pgcrypto extension is installed\r\n            SELECT EXISTS (\r\n              SELECT 1 FROM pg_extension WHERE extname = 'pgcrypto'\r\n            ) INTO test_result;\r\n            \r\n            IF test_result = 'true' THEN\r\n              RETURN 'pgcrypto extension is installed, but all gen_salt access attempts failed. Search path: ' || schema_search_path;\r\n            ELSE\r\n              RETURN 'pgcrypto extension is NOT installed. Search path: ' || schema_search_path;\r\n            END IF;\r\n          EXCEPTION WHEN OTHERS THEN\r\n            RETURN 'All attempts failed. Last error: ' || SQLERRM || ', Search path: ' || schema_search_path;\r\n          END;\r\n        END;\r\n      END;\r\n    END;\r\n  END;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "test_simple_function",
    "arguments": "test_input text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.test_simple_function(test_input text)\n RETURNS text\n LANGUAGE sql\n SET search_path TO 'public', 'pg_catalog'\nAS $function$\r\n  SELECT 'Test successful: ' || test_input;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "toggle_module_status",
    "arguments": "p_module_id uuid, p_organization_id uuid, p_is_enabled boolean",
    "function_definition": "CREATE OR REPLACE FUNCTION public.toggle_module_status(p_module_id uuid, p_organization_id uuid, p_is_enabled boolean)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_exists BOOLEAN;\nBEGIN\n  -- Check if caller is an admin\n  IF NOT (SELECT EXISTS(SELECT 1 FROM admin_users_view WHERE user_id = auth.uid())) THEN\n    RAISE EXCEPTION 'Only administrators can toggle module status';\n  END IF;\n\n  -- Check if the configuration already exists\n  SELECT EXISTS(\n    SELECT 1 FROM module_configurations \n    WHERE module_id = p_module_id AND organization_id = p_organization_id\n  ) INTO v_exists;\n\n  IF v_exists THEN\n    -- Update existing configuration\n    UPDATE module_configurations\n    SET \n      is_enabled = p_is_enabled,\n      updated_at = NOW(),\n      updated_by = auth.uid()\n    WHERE \n      module_id = p_module_id AND \n      organization_id = p_organization_id;\n  ELSE\n    -- Insert new configuration\n    INSERT INTO module_configurations (\n      module_id, \n      organization_id, \n      is_enabled, \n      created_by, \n      updated_by\n    )\n    VALUES (\n      p_module_id, \n      p_organization_id, \n      p_is_enabled, \n      auth.uid(), \n      auth.uid()\n    );\n  END IF;\n\n  RETURN TRUE;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "track_maintenance_assignment_change",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.track_maintenance_assignment_change()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  IF (OLD.assignee IS DISTINCT FROM NEW.assignee) THEN\n    INSERT INTO maintenance_assignment_history (\n      maintenance_record_id,\n      previous_assignee,\n      new_assignee,\n      assigned_by\n    ) VALUES (\n      NEW.id,\n      OLD.assignee,\n      NEW.assignee,\n      COALESCE(auth.uid(), NEW.created_by)\n    );\n  END IF;\n  RETURN NEW;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "track_maintenance_status_change",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.track_maintenance_status_change()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  IF (OLD.maintenance_record_status IS DISTINCT FROM NEW.maintenance_record_status) THEN\n    INSERT INTO maintenance_status_history (\n      maintenance_record_id,\n      previous_status,\n      new_status,\n      changed_by\n    ) VALUES (\n      NEW.id,\n      OLD.maintenance_record_status,\n      NEW.maintenance_record_status,\n      COALESCE(auth.uid(), NEW.created_by)\n    );\n  END IF;\n  RETURN NEW;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "unarchive_update",
    "arguments": "p_update_id uuid, p_admin_id uuid, p_new_status text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.unarchive_update(p_update_id uuid, p_admin_id uuid, p_new_status text DEFAULT 'draft'::text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  update_title TEXT;\r\n  current_status TEXT;\r\nBEGIN\r\n  -- Get update details\r\n  SELECT title, status INTO update_title, current_status\r\n  FROM portal_updates \r\n  WHERE id = p_update_id;\r\n  \r\n  -- Check if update exists\r\n  IF update_title IS NULL THEN\r\n    RAISE EXCEPTION 'Update not found';\r\n  END IF;\r\n  \r\n  -- Check if archived\r\n  IF current_status != 'archived' THEN\r\n    RAISE EXCEPTION 'Update is not archived';\r\n  END IF;\r\n  \r\n  -- Validate new status\r\n  IF p_new_status NOT IN ('draft', 'published') THEN\r\n    RAISE EXCEPTION 'Invalid status. Must be draft or published';\r\n  END IF;\r\n  \r\n  -- Unarchive the update\r\n  UPDATE portal_updates\r\n  SET \r\n    status = p_new_status,\r\n    archived_at = NULL,\r\n    archived_by = NULL,\r\n    updated_at = NOW(),\r\n    published_at = CASE WHEN p_new_status = 'published' THEN NOW() ELSE published_at END\r\n  WHERE id = p_update_id;\r\n  \r\n  -- Log the action\r\n  INSERT INTO portal_audit_log (\r\n    action, \r\n    entity_type, \r\n    entity_id, \r\n    admin_id, \r\n    details\r\n  ) VALUES (\r\n    'unarchive_update',\r\n    'update',\r\n    p_update_id,\r\n    p_admin_id,\r\n    json_build_object(\r\n      'title', update_title,\r\n      'new_status', p_new_status,\r\n      'unarchived_at', NOW()\r\n    )\r\n  );\r\n  \r\n  RETURN json_build_object(\r\n    'success', true,\r\n    'title', update_title,\r\n    'new_status', p_new_status\r\n  );\r\nEXCEPTION\r\n  WHEN OTHERS THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', SQLERRM\r\n    );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_businesses_updated_at",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_businesses_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  NEW.updated_at = NOW();\r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_calculator_submission_is_latest",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_calculator_submission_is_latest()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  -- For users with user_id, mark all their submissions as not latest\r\n  IF NEW.user_id IS NOT NULL THEN\r\n    UPDATE calculator_submissions\r\n    SET is_latest = false\r\n    WHERE user_id = NEW.user_id\r\n    AND id != NEW.id;\r\n\r\n    -- Mark the new/updated submission as latest\r\n    NEW.is_latest = true;\r\n\r\n  -- For anonymous submissions (no user_id), use email\r\n  ELSIF NEW.user_email IS NOT NULL THEN\r\n    UPDATE calculator_submissions\r\n    SET is_latest = false\r\n    WHERE user_email = NEW.user_email\r\n    AND user_id IS NULL\r\n    AND id != NEW.id;\r\n\r\n    -- Mark the new/updated submission as latest\r\n    NEW.is_latest = true;\r\n  END IF;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_campaign_link",
    "arguments": "p_link_id uuid, p_campaign_name text, p_notes text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_campaign_link(p_link_id uuid, p_campaign_name text, p_notes text DEFAULT NULL::text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  UPDATE marketing_campaign_links\r\n  SET\r\n    campaign_name = p_campaign_name,\r\n    notes = p_notes,\r\n    updated_at = NOW()\r\n  WHERE id = p_link_id;\r\n\r\n  RETURN FOUND;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_contact_last_contacted",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_contact_last_contacted()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    UPDATE public.contacts \r\n    SET last_contacted_at = NEW.interaction_date\r\n    WHERE id = NEW.contact_id;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_contact_submission_timestamp",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_contact_submission_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  NEW.updated_at = NOW();\r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_event_date_attendees",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_event_date_attendees()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    IF TG_OP = 'INSERT' THEN\r\n        UPDATE portal_event_dates \r\n        SET current_attendees = current_attendees + 1 + (\r\n            SELECT COUNT(*) FROM portal_event_guests \r\n            WHERE registration_id = NEW.id\r\n        )\r\n        WHERE id = NEW.event_date_id;\r\n    ELSIF TG_OP = 'DELETE' OR (TG_OP = 'UPDATE' AND NEW.cancelled_at IS NOT NULL AND OLD.cancelled_at IS NULL) THEN\r\n        UPDATE portal_event_dates \r\n        SET current_attendees = GREATEST(0, current_attendees - 1 - (\r\n            SELECT COUNT(*) FROM portal_event_guests \r\n            WHERE registration_id = COALESCE(OLD.id, NEW.id)\r\n        ))\r\n        WHERE id = COALESCE(OLD.event_date_id, NEW.event_date_id);\r\n    END IF;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_event_date_guests",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_event_date_guests()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_event_date_id UUID;\r\nBEGIN\r\n    SELECT event_date_id INTO v_event_date_id\r\n    FROM portal_event_registrations\r\n    WHERE id = COALESCE(NEW.registration_id, OLD.registration_id);\r\n    \r\n    IF TG_OP = 'INSERT' THEN\r\n        UPDATE portal_event_dates \r\n        SET current_attendees = current_attendees + 1\r\n        WHERE id = v_event_date_id;\r\n    ELSIF TG_OP = 'DELETE' THEN\r\n        UPDATE portal_event_dates \r\n        SET current_attendees = GREATEST(0, current_attendees - 1)\r\n        WHERE id = v_event_date_id;\r\n    END IF;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_latest_submission",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_latest_submission()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  -- Mark all previous submissions by this user as not latest\r\n  UPDATE public.calculator_submissions\r\n  SET is_latest = false\r\n  WHERE user_id = NEW.user_id\r\n  AND id != NEW.id;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_maintenance_record",
    "arguments": "p_id uuid, p_data jsonb",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_maintenance_record(p_id uuid, p_data jsonb)\n RETURNS SETOF maintenance_records\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_maintenance_record_status maintenance_record_status;\n  v_vehicle_id uuid;\n  v_operational_state text;\n  v_odometer integer;\nBEGIN\n  -- Check permissions first\n  IF NOT can_access_maintenance_record(p_id) THEN\n    RAISE EXCEPTION 'Permission denied';\n  END IF;\n\n  -- Get vehicle ID for later use\n  SELECT vehicle_id INTO v_vehicle_id\n  FROM maintenance_records\n  WHERE id = p_id;\n  \n  -- Extract the operational state for vehicle update\n  v_operational_state := p_data->>'operational_state';\n  \n  -- Extract odometer for vehicle update\n  IF p_data->>'odometer' IS NOT NULL AND (p_data->>'odometer')::integer > 0 THEN\n    v_odometer := (p_data->>'odometer')::integer;\n    RAISE NOTICE 'Updating record % with odometer reading: %', p_id, v_odometer;\n  END IF;\n  \n  RAISE NOTICE 'Updating maintenance record % with operational state: %', p_id, v_operational_state;\n  \n  -- Handle maintenance_record_status conversion to ensure we only use valid enum values\n  IF p_data->>'maintenance_record_status' IS NOT NULL THEN\n    BEGIN\n      v_maintenance_record_status := (p_data->>'maintenance_record_status')::maintenance_record_status;\n    EXCEPTION WHEN OTHERS THEN\n      -- Default to previous status if invalid value provided\n      SELECT maintenance_record_status INTO v_maintenance_record_status FROM maintenance_records WHERE id = p_id;\n    END;\n  ELSE\n    -- No status provided, keep existing\n    SELECT maintenance_record_status INTO v_maintenance_record_status FROM maintenance_records WHERE id = p_id;\n  END IF;\n  \n  -- Update and return the record\n  -- CRITICAL: Removed operational_state column from UPDATE statement as it doesn't exist\n  RETURN QUERY\n  UPDATE maintenance_records\n  SET \n    vehicle_id = COALESCE((p_data->>'vehicle_id')::uuid, vehicle_id),\n    issue_title = COALESCE(p_data->>'issue_title', issue_title),\n    issue = COALESCE(p_data->>'issue', issue),\n    location = COALESCE((p_data->>'location')::maintenance_location, location),\n    severity = COALESCE((p_data->>'severity')::smallint, severity),\n    maintenance_record_status = v_maintenance_record_status,\n    support_ticket = CASE\n      WHEN p_data->>'support_ticket' = '' THEN NULL\n      WHEN p_data->>'support_ticket' IS NULL THEN support_ticket\n      ELSE (p_data->>'support_ticket')::integer\n    END,\n    afs_eligible = COALESCE(p_data->>'afs_eligible', afs_eligible),\n    maintenance_notes = COALESCE(p_data->>'maintenance_notes', maintenance_notes),\n    date_due = CASE\n      WHEN p_data->>'date_due' = '' THEN NULL\n      WHEN p_data->>'date_due' IS NULL THEN date_due\n      ELSE (p_data->>'date_due')::date\n    END,\n    resolution = COALESCE(p_data->>'resolution', resolution),\n    resolved_at = CASE\n      WHEN p_data->>'resolved_at' = '' THEN NULL\n      WHEN p_data->>'resolved_at' IS NULL THEN resolved_at\n      ELSE (p_data->>'resolved_at')::timestamp with time zone\n    END,\n    resolved_by = COALESCE((p_data->>'resolved_by')::uuid, resolved_by),\n    assignee = COALESCE((p_data->>'assignee')::uuid, assignee),\n    odometer = CASE\n      WHEN p_data->>'odometer' = '' THEN NULL\n      WHEN p_data->>'odometer' IS NULL THEN odometer\n      ELSE (p_data->>'odometer')::integer\n    END,\n    updated_at = now()\n  WHERE id = p_id\n  RETURNING *;\n  \n  -- If odometer is provided, update the vehicle's odometer as well\n  IF v_odometer IS NOT NULL AND v_odometer > 0 AND v_vehicle_id IS NOT NULL THEN\n    RAISE NOTICE 'Also updating vehicle % odometer to %', v_vehicle_id, v_odometer;\n    PERFORM update_odometer_with_validation(v_vehicle_id, v_odometer);\n  END IF;\n  \n  -- Update vehicle's operational state if provided\n  IF v_operational_state IS NOT NULL AND v_vehicle_id IS NOT NULL THEN\n    -- Validate operational state before updating (only attempt update with valid values)\n    IF v_operational_state IN ('Available', 'Grounded') THEN\n      RAISE NOTICE 'Also updating vehicle % operational state to %', v_vehicle_id, v_operational_state;\n      PERFORM update_vehicle_operational_state(v_vehicle_id, v_operational_state);\n    ELSE\n      RAISE NOTICE 'Skipping vehicle operational state update due to invalid value: %', v_operational_state;\n    END IF;\n  END IF;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_odometer_from_maintenance_record",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_odometer_from_maintenance_record()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_vehicle_id UUID;\n  v_current_odometer INTEGER;\nBEGIN\n  -- Get the vehicle ID from the maintenance record\n  v_vehicle_id := NEW.vehicle_id;\n  \n  -- If odometer is provided in maintenance record, update the vehicle and create history\n  IF NEW.odometer IS NOT NULL THEN\n    -- Get current odometer reading\n    SELECT odometer INTO v_current_odometer\n    FROM public.fleet\n    WHERE id = v_vehicle_id;\n    \n    -- Update vehicle odometer only if the new reading is higher than current\n    IF v_current_odometer IS NULL OR NEW.odometer > v_current_odometer THEN\n      UPDATE public.fleet\n      SET odometer = NEW.odometer\n      WHERE id = v_vehicle_id;\n    END IF;\n    \n    -- Always record in history\n    INSERT INTO public.odometer_history (\n      vehicle_id,\n      odometer,\n      recorded_by,\n      maintenance_record_id,\n      notes\n    ) VALUES (\n      v_vehicle_id,\n      NEW.odometer,\n      NEW.created_by,\n      NEW.id,\n      'Added via maintenance record'\n    );\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_odometer_history",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_odometer_history()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  -- Only create history entry if odometer value has changed and is not null\n  IF (NEW.odometer IS NOT NULL AND (OLD.odometer IS NULL OR NEW.odometer <> OLD.odometer)) THEN\n    INSERT INTO public.odometer_history (\n      vehicle_id,\n      odometer,\n      recorded_by,\n      notes\n    ) VALUES (\n      NEW.id,\n      NEW.odometer,\n      COALESCE(auth.uid(), '00000000-0000-0000-0000-000000000000'::uuid),\n      'Updated via vehicle edit'\n    );\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_odometer_with_validation",
    "arguments": "p_vehicle_id uuid, p_odometer integer",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_odometer_with_validation(p_vehicle_id uuid, p_odometer integer)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_current_odometer INTEGER;\nBEGIN\n  -- Get current odometer reading\n  SELECT odometer INTO v_current_odometer\n  FROM public.fleet\n  WHERE id = p_vehicle_id;\n  \n  -- Update vehicle odometer only if the new reading is higher than current or current is null\n  IF v_current_odometer IS NULL OR p_odometer >= v_current_odometer THEN\n    UPDATE public.fleet\n    SET \n      odometer = p_odometer,\n      updated_at = now()\n    WHERE id = p_vehicle_id;\n    RETURN TRUE;\n  END IF;\n  \n  -- No update needed if current reading is higher\n  RETURN FALSE;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_preferences_timestamp",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_preferences_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  IF (OLD.email_updates IS DISTINCT FROM NEW.email_updates OR\r\n      OLD.email_surveys IS DISTINCT FROM NEW.email_surveys OR\r\n      OLD.email_events IS DISTINCT FROM NEW.email_events) THEN\r\n    NEW.preferences_updated_at = NOW();\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_recipient_lists_updated_at",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_recipient_lists_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  NEW.updated_at = now();\r\n  RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_role_permission",
    "arguments": "p_role app_role, p_permission_id uuid, p_granted boolean",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_role_permission(p_role app_role, p_permission_id uuid, p_granted boolean)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_catalog'\nAS $function$\r\nBEGIN\r\n  -- Check if user is super admin\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM user_roles \r\n    WHERE user_id = auth.uid() AND role = 'super_admin'\r\n  ) THEN\r\n    RAISE EXCEPTION 'Only super admins can modify permissions';\r\n  END IF;\r\n\r\n  IF p_granted THEN\r\n    -- Grant permission\r\n    INSERT INTO role_permissions (role, permission_id, granted_by)\r\n    VALUES (p_role, p_permission_id, auth.uid())\r\n    ON CONFLICT (role, permission_id, organization_id) DO NOTHING;\r\n  ELSE\r\n    -- Revoke permission\r\n    DELETE FROM role_permissions \r\n    WHERE role = p_role AND permission_id = p_permission_id;\r\n  END IF;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_setting",
    "arguments": "setting_key text, setting_value jsonb",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_setting(setting_key text, setting_value jsonb)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nBEGIN\r\n  UPDATE public.system_settings \r\n  SET \r\n    value = setting_value,\r\n    updated_at = NOW(),\r\n    updated_by = auth.uid()\r\n  WHERE key = setting_key;\r\n  \r\n  RETURN FOUND;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_survey_question_count",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_survey_question_count()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\n    BEGIN\r\n      IF TG_OP = 'INSERT' THEN\r\n        UPDATE public.portal_surveys\r\n        SET question_count = (\r\n          SELECT COUNT(*) FROM public.portal_survey_questions\r\n          WHERE survey_id = NEW.survey_id\r\n        )\r\n        WHERE id = NEW.survey_id;\r\n      ELSIF TG_OP = 'DELETE' THEN\r\n        UPDATE public.portal_surveys\r\n        SET question_count = (\r\n          SELECT COUNT(*) FROM public.portal_survey_questions\r\n          WHERE survey_id = OLD.survey_id\r\n        )\r\n        WHERE id = OLD.survey_id;\r\n      END IF;\r\n      RETURN NULL;\r\n    END;\r\n    $function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_updated_at_column",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    NEW.updated_at = now();\r\n    RETURN NEW;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_vehicle_operational_state",
    "arguments": "p_vehicle_id uuid, p_operational_state text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_vehicle_operational_state(p_vehicle_id uuid, p_operational_state text DEFAULT NULL::text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_has_maintenance boolean;\n  v_state text;\nBEGIN\n  -- Log incoming parameters for debugging\n  RAISE NOTICE 'update_vehicle_operational_state called with vehicle_id: %, operational_state: %', p_vehicle_id, p_operational_state;\n  \n  -- First check if vehicle has any active maintenance records\n  SELECT EXISTS (\n    SELECT 1\n    FROM maintenance_records\n    WHERE vehicle_id = p_vehicle_id\n    AND maintenance_record_status != 'Resolved'\n  ) INTO v_has_maintenance;\n  \n  RAISE NOTICE 'Vehicle has active maintenance: %', v_has_maintenance;\n  \n  -- If p_operational_state is provided, use it directly\n  IF p_operational_state IS NOT NULL THEN\n    v_state := p_operational_state;\n    RAISE NOTICE 'Using provided state: %', v_state;\n  ELSE\n    -- Otherwise set a suitable default based on maintenance status\n    IF v_has_maintenance THEN\n      v_state := 'Grounded';\n      RAISE NOTICE 'Vehicle has maintenance, setting to Grounded';\n    ELSE\n      v_state := 'Available';\n      RAISE NOTICE 'No active maintenance, setting to Available';\n    END IF;\n  END IF;\n  \n  -- Update the vehicle state\n  UPDATE fleet\n  SET operational_state = v_state::operational_state,\n      updated_at = now()\n  WHERE id = p_vehicle_id;\n  \n  RAISE NOTICE 'Updated vehicle % state to %', p_vehicle_id, v_state;\n  \n  RETURN TRUE;\nEXCEPTION\n  WHEN OTHERS THEN\n    RAISE NOTICE 'Error updating vehicle operational state: %', SQLERRM;\n    RAISE;\n    RETURN FALSE;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "update_vehicle_type",
    "arguments": "p_vehicle_id uuid, p_vehicle_type vehicle_type",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_vehicle_type(p_vehicle_id uuid, p_vehicle_type vehicle_type)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  UPDATE fleet\n  SET \n    vehicle_type = p_vehicle_type,\n    updated_at = now()\n  WHERE id = p_vehicle_id;\n  \n  RETURN TRUE;\nEXCEPTION\n  WHEN OTHERS THEN\n    RAISE NOTICE 'Error updating vehicle type: %', SQLERRM;\n    RETURN FALSE;\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "vehicle_has_active_maintenance",
    "arguments": "p_vehicle_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.vehicle_has_active_maintenance(p_vehicle_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  RETURN EXISTS (\n    SELECT 1\n    FROM maintenance_records\n    WHERE vehicle_id = p_vehicle_id\n    AND state != 'operational'::maintenance_state  -- Check state instead of is_active\n  );\nEND;\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "verify_dev_password",
    "arguments": "user_email character varying, provided_password character varying",
    "function_definition": "CREATE OR REPLACE FUNCTION public.verify_dev_password(user_email character varying, provided_password character varying)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'extensions'\nAS $function$\r\nDECLARE\r\n    v_user RECORD;\r\n    v_password_matches BOOLEAN;\r\n    v_roles TEXT[];\r\nBEGIN\r\n    -- Find user in dev_auth\r\n    SELECT \r\n        da.user_id,\r\n        da.email,\r\n        da.password_hash,\r\n        p.first_name,\r\n        p.last_name,\r\n        p.status\r\n    INTO v_user\r\n    FROM dev_auth da\r\n    JOIN profiles p ON p.id = da.user_id\r\n    WHERE LOWER(da.email) = LOWER(user_email)\r\n    LIMIT 1;\r\n    \r\n    IF NOT FOUND THEN\r\n        -- Try to find user for logging purposes\r\n        PERFORM record_user_login(\r\n            (SELECT id FROM profiles WHERE LOWER(email) = LOWER(user_email) LIMIT 1),\r\n            'dev',\r\n            NULL,\r\n            NULL,\r\n            false,\r\n            'User not found in dev_auth'\r\n        );\r\n        RETURN jsonb_build_object(\r\n            'success', false,\r\n            'error', 'Invalid credentials'\r\n        );\r\n    END IF;\r\n    \r\n    -- Check if user is active\r\n    IF v_user.status != 'active' THEN\r\n        PERFORM record_user_login(\r\n            v_user.user_id,\r\n            'dev',\r\n            NULL,\r\n            NULL,\r\n            false,\r\n            'Account is not active'\r\n        );\r\n        RETURN jsonb_build_object(\r\n            'success', false,\r\n            'error', 'Account is not active'\r\n        );\r\n    END IF;\r\n    \r\n    -- Verify password using bcrypt\r\n    v_password_matches := (v_user.password_hash = extensions.crypt(provided_password, v_user.password_hash));\r\n    \r\n    IF NOT v_password_matches THEN\r\n        PERFORM record_user_login(\r\n            v_user.user_id,\r\n            'dev',\r\n            NULL,\r\n            NULL,\r\n            false,\r\n            'Invalid password'\r\n        );\r\n        RETURN jsonb_build_object(\r\n            'success', false,\r\n            'error', 'Invalid credentials'\r\n        );\r\n    END IF;\r\n    \r\n    -- Record successful login (if function exists)\r\n    BEGIN\r\n        PERFORM record_user_login(\r\n            v_user.user_id,\r\n            'dev',\r\n            NULL,\r\n            NULL,\r\n            true,\r\n            NULL\r\n        );\r\n    EXCEPTION WHEN undefined_function THEN\r\n        -- record_user_login might not exist yet, that's okay\r\n        NULL;\r\n    END;\r\n    \r\n    -- Get user roles\r\n    SELECT array_agg(role ORDER BY role) INTO v_roles\r\n    FROM user_roles\r\n    WHERE user_id = v_user.user_id;\r\n    \r\n    -- Return success with user data\r\n    RETURN jsonb_build_object(\r\n        'success', true,\r\n        'user', jsonb_build_object(\r\n            'id', v_user.user_id,\r\n            'email', v_user.email,\r\n            'name', COALESCE(v_user.first_name || ' ' || v_user.last_name, v_user.email),\r\n            'first_name', v_user.first_name,\r\n            'last_name', v_user.last_name,\r\n            'roles', COALESCE(v_roles, ARRAY[]::text[])\r\n        )\r\n    );\r\nEXCEPTION WHEN OTHERS THEN\r\n    -- Log the error but return a generic message\r\n    RAISE WARNING 'Error in verify_dev_password: %', SQLERRM;\r\n    RETURN jsonb_build_object(\r\n        'success', false,\r\n        'error', 'Authentication failed'\r\n    );\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  },
  {
    "schema_name": "public",
    "function_name": "verify_temp_password",
    "arguments": "user_email text, provided_password text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.verify_temp_password(user_email text, provided_password text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public', 'pg_temp'\nAS $function$\r\nDECLARE\r\n  v_user_id uuid;\r\n  v_stored_password text;\r\n  v_email text;\r\nBEGIN\r\n  -- Get user and their temp password\r\n  SELECT \r\n    p.id,\r\n    p.email,\r\n    p.metadata->>'temp_password'\r\n  INTO v_user_id, v_email, v_stored_password\r\n  FROM profiles p\r\n  WHERE lower(p.email) = lower(user_email)\r\n  AND p.metadata->>'use_temp_auth' = 'true';\r\n\r\n  IF v_user_id IS NULL THEN\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'User not found or not using temp auth'\r\n    );\r\n  END IF;\r\n\r\n  IF v_stored_password = provided_password THEN\r\n    -- Password matches, create a session token\r\n    RETURN json_build_object(\r\n      'success', true,\r\n      'user_id', v_user_id,\r\n      'email', v_email,\r\n      'message', 'Password verified'\r\n    );\r\n  ELSE\r\n    RETURN json_build_object(\r\n      'success', false,\r\n      'error', 'Invalid password'\r\n    );\r\n  END IF;\r\nEND;\r\n$function$\n",
    "separator": "-- ================================================="
  }
]

Get count by category for verification:

[
  {
    "category": "Other",
    "function_count": 136
  },
  {
    "category": "Auth/User",
    "function_count": 43
  },
  {
    "category": "Email/Notification",
    "function_count": 30
  },
  {
    "category": "Referral",
    "function_count": 15
  },
  {
    "category": "Roles/Permissions",
    "function_count": 11
  },
  {
    "category": "Portal Other",
    "function_count": 7
  }
]


EXPECTED CATEGORIES:
- Email/Notification: ~16 functions
- Referral: ~13 functions
- Portal Events: ~11 functions
- Portal Surveys: ~12 functions
- Portal Updates: ~14 functions
- Portal Other: ~8 functions
- Auth/User: ~15 functions
- Roles/Permissions: ~7 functions
- Other: ~10 functions

TOTAL: ~116 functions

If count is significantly different, investigate why.
*/